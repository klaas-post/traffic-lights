//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "TrafficControl"
	Revision           = "0.0"
	GUID               = "{14BB889B-FF97-4083-85DD-5543A69B92CD}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "100 ms"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(996,120)">
	<Channels>
		<Server Name="ClassSvr" GUID="{0DE37930-FFC9-4395-ACC2-3B7E6DCA5DA3}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server
			Name           = "Svr_AverageWaitingTime"
			GUID           = "{6C025759-54EE-4A35-B405-CCB1D4CAE5C8}"
			Visualized     = "true"
			Initialize     = "false"
			WriteProtected = "true"
			Retentive      = "false">
			<OPCSettingsDefault Visible="true"/>
		</Server>
		<Server
			Name           = "Svr_AverageWaitingTimeMinutes"
			GUID           = "{78D226DD-DEAA-49F3-904D-682FFB818F01}"
			Visualized     = "true"
			Initialize     = "false"
			WriteProtected = "true"
			Retentive      = "false">
			<OPCSettingsDefault Visible="true"/>
		</Server>
		<Server
			Name           = "Svr_AverageWaitingTimeSeconds"
			GUID           = "{3F86744F-E8DD-4B49-BCAA-EEEC8E38CF4A}"
			Visualized     = "true"
			Initialize     = "false"
			WriteProtected = "true"
			Retentive      = "false">
			<OPCSettingsDefault Visible="true"/>
		</Server>
		<Server Name="Svr_BaseCycleTime" GUID="{12759AB7-CF04-4C00-A69A-873ADA8AEA6E}" Visualized="false" Initialize="true" DefValue="12 sec" WriteProtected="false" Retentive="SRam"/>
		<Server Name="Svr_CycleTimeVariable" GUID="{0B8E7F7F-A5D0-45AF-824E-8A1653C880A5}" Visualized="false" Initialize="true" DefValue="0.1" WriteProtected="false" Retentive="SRam"/>
		<Server
			Name           = "Svr_EndlessMode"
			GUID           = "{2C5DFF2D-B70A-4FA5-A4FD-166D5C88DA11}"
			Visualized     = "true"
			Initialize     = "false"
			WriteProtected = "false"
			Retentive      = "false">
			<OPCSettingsDefault Visible="true" WriteProtected="false"/>
		</Server>
		<Server Name="Svr_MinTrafficTreshold" GUID="{D58A9211-EF97-4904-9E21-9715DA55706F}" Visualized="false" Initialize="true" DefValue="8" WriteProtected="false" Retentive="SRam" Comment="This variable sets the minimum amount of cars required for the traffic algorithm to give the the side those cars are waiting at extra time."/>
		<Server
			Name           = "Svr_TrafficDensityFactor"
			GUID           = "{039E5C1A-719E-43D9-8610-CB5FC65EBC28}"
			Visualized     = "true"
			Remotely       = "true"
			Initialize     = "true"
			DefValue       = "900"
			WriteProtected = "false"
			Retentive      = "SRam">
			<OPCSettingsDefault Visible="true" WriteProtected="false"/>
		</Server>
		<Client Name="Obj_Random" Required="true" Internal="false"/>
		<Client Name="Obj_RoadEast" Required="true" Internal="false"/>
		<Client Name="Obj_RoadNorth" Required="true" Internal="false"/>
		<Client Name="Obj_RoadSouth" Required="true" Internal="false"/>
		<Client Name="Obj_RoadWest" Required="true" Internal="false"/>
		<Client Name="Obj_TrafficLightEast" Required="true" Internal="false"/>
		<Client Name="Obj_TrafficLightNorth" Required="true" Internal="false"/>
		<Client Name="Obj_TrafficLightSouth" Required="true" Internal="false"/>
		<Client Name="Obj_TrafficLightWest" Required="true" Internal="false"/>
		<Client Name="Random1" Required="true" Internal="true"/>
	</Channels>
	<Separators>
		<Clients>
			<SepChn Position="6"/>
			<SepChn Position="1"/>
		</Clients>
	</Separators>
	<Network Name="TrafficControl">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "Random1"
				GUID       = "{30344522-5219-4626-8CD7-CE17B25A409E}"
				Class      = "Random"
				Position   = "(180,840)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Random1" Destination="Random1.ClassSvr"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
TrafficControl : CLASS
	TYPE
	  _DominantDirection :
	  (
	    eNone:=0,
	    eEastWest:=1,
	    eNorthSouth:=2
	  )$DINT;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	Svr_BaseCycleTime 	: SvrCh_UDINT;
	Svr_MinTrafficTreshold 	: SvrCh_DINT;
	Svr_CycleTimeVariable 	: SvrCh_REAL;
	Svr_AverageWaitingTime 	: SvrCh_REAL;
	Svr_AverageWaitingTimeSeconds 	: SvrCh_UDINT;
	Svr_AverageWaitingTimeMinutes 	: SvrCh_UDINT;
	Svr_EndlessMode 	: SvrCh_DINT;
	Svr_TrafficDensityFactor 	: SvrCh_DINT;
  //Clients:
	Obj_Random 	: CltChCmd_Random;
	Obj_TrafficLightNorth 	: CltChCmd_TrafficLight;
	Obj_TrafficLightEast 	: CltChCmd_TrafficLight;
	Obj_TrafficLightSouth 	: CltChCmd_TrafficLight;
	Obj_TrafficLightWest 	: CltChCmd_TrafficLight;
	Obj_RoadNorth 	: CltChCmd_Road;
	Obj_RoadEast 	: CltChCmd_Road;
	Obj_RoadSouth 	: CltChCmd_Road;
	Obj_RoadWest 	: CltChCmd_Road;
	Random1 	: CltChCmd_Random;
  //Variables:
		TotalTraffic 	: DINT;
		tSignalChanged 	: UDINT;
		eDominantDirection 	: _DominantDirection;
		NorthSouthCycleTime 	: UDINT;
		EastWestCycleTime 	: UDINT;
		CarsNorth 	: DINT;
		CarsEast 	: DINT;
		CarsSouth 	: DINT;
		CarsWest 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION SetSignals
		VAR_INPUT
			NorthStopSignal 	: BOOL;
			EastStopSignal 	: BOOL;
			SouthStopSignal 	: BOOL;
			WestStopSignal 	: BOOL;
		END_VAR;
	
	FUNCTION SetTraffic;
	
	FUNCTION SetDominantDirection;
	
	FUNCTION CalculateCycleTime
		VAR_INPUT
			TrafficA 	: DINT;
			TrafficB 	: DINT;
		END_VAR
		VAR_OUTPUT
			DirectionCycleTime 	: UDINT;
		END_VAR;
	
	FUNCTION ReadInputs;
	
	FUNCTION WriteOutputs;
	
	FUNCTION AddTraffic;
	
	FUNCTION GetCarsRandom
		VAR_OUTPUT
			Cars 	: DINT;
		END_VAR;
	
	FUNCTION GetExtraDelay
		VAR_INPUT
			CarsDirection1 	: DINT;
			CarsDirection2 	: DINT;
		END_VAR
		VAR_OUTPUT
			ExtraDelay 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using Random
#pragma usingLtd Road
#pragma usingLtd TrafficLight


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB TrafficControl::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_TRAFFICCONTROL
0$UINT, 0$UINT, (SIZEOF(::TrafficControl))$UINT, 
9$UINT, 10$UINT, 0$UINT, 
TO_UDINT(444898770), "TrafficControl", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::TrafficControl.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::TrafficControl.Svr_BaseCycleTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(3148577358), "Svr_BaseCycleTime", 
(::TrafficControl.Svr_MinTrafficTreshold.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(1229737423), "Svr_MinTrafficTreshold", 
(::TrafficControl.Svr_CycleTimeVariable.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(2505978387), "Svr_CycleTimeVariable", 
(::TrafficControl.Svr_AverageWaitingTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(843986990), "Svr_AverageWaitingTime", 
(::TrafficControl.Svr_AverageWaitingTimeSeconds.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3671713535), "Svr_AverageWaitingTimeSeconds", 
(::TrafficControl.Svr_AverageWaitingTimeMinutes.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1432659386), "Svr_AverageWaitingTimeMinutes", 
(::TrafficControl.Svr_EndlessMode.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(157723976), "Svr_EndlessMode", 
(::TrafficControl.Svr_TrafficDensityFactor.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(2904958223), "Svr_TrafficDensityFactor", 
//Clients:
(::TrafficControl.Obj_Random.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1184818257), "Obj_Random", TO_UDINT(3871546707), "Random", 0$UINT, 0$UINT, 
(::TrafficControl.Obj_TrafficLightNorth.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3478640126), "Obj_TrafficLightNorth", TO_UDINT(1430994866), "TrafficLight", 0$UINT, 0$UINT, 
(::TrafficControl.Obj_TrafficLightEast.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(648973330), "Obj_TrafficLightEast", TO_UDINT(1430994866), "TrafficLight", 0$UINT, 0$UINT, 
(::TrafficControl.Obj_TrafficLightSouth.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1382584392), "Obj_TrafficLightSouth", TO_UDINT(1430994866), "TrafficLight", 0$UINT, 0$UINT, 
(::TrafficControl.Obj_TrafficLightWest.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3686251482), "Obj_TrafficLightWest", TO_UDINT(1430994866), "TrafficLight", 0$UINT, 0$UINT, 
(::TrafficControl.Obj_RoadNorth.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(47791540), "Obj_RoadNorth", TO_UDINT(2740267269), "Road", 0$UINT, 0$UINT, 
(::TrafficControl.Obj_RoadEast.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2134922727), "Obj_RoadEast", TO_UDINT(2740267269), "Road", 0$UINT, 0$UINT, 
(::TrafficControl.Obj_RoadSouth.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2682681346), "Obj_RoadSouth", TO_UDINT(2740267269), "Road", 0$UINT, 0$UINT, 
(::TrafficControl.Obj_RoadWest.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2186895919), "Obj_RoadWest", TO_UDINT(2740267269), "Road", 0$UINT, 0$UINT, 
(::TrafficControl.Random1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1901604068), "Random1", TO_UDINT(3871546707), "Random", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_TrafficControl 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_TrafficControl] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION TrafficControl::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_TrafficControl, pCmd := #vmt.CmdTable);
	vmt.CmdTable.CyWork		:= #CyWork();
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Svr_BaseCycleTime.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Svr_BaseCycleTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Svr_MinTrafficTreshold.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Svr_MinTrafficTreshold.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Svr_CycleTimeVariable.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Svr_CycleTimeVariable.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Svr_EndlessMode.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Svr_EndlessMode.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Svr_TrafficDensityFactor.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Svr_TrafficDensityFactor.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

//----------------------------------------------------------------------------------------------------
//  Standard class methods
//----------------------------------------------------------------------------------------------------

FUNCTION VIRTUAL GLOBAL TrafficControl::CyWork
    VAR_INPUT
        EAX            : UDINT;
    END_VAR
    VAR_OUTPUT
        state (EAX)    : UDINT;
    END_VAR

    ReadInputs();
    
    SetDominantDirection();
    
    // Enables traffic simulation where random cars are added. 
    IF Svr_EndlessMode THEN
        AddTraffic();
    END_IF;
    
    // Direction switching. 
    CASE eDominantDirection OF
    
        eNone:
            SetSignals(TRUE, TRUE, TRUE, TRUE); // All red
            
        eNorthSouth:
            SetSignals(FALSE, TRUE, FALSE, TRUE); // North & South to Green, East & West to Red. 
        
        eEastWest:
            SetSignals(TRUE, FALSE, TRUE, FALSE); // North & South to Red, East & West to Green.
        
    END_CASE;
    
    WriteOutputs();

    state := READY;

END_FUNCTION

//----------------------------------------------------------------------------------------------------
//  Internally called methods
//----------------------------------------------------------------------------------------------------

FUNCTION TrafficControl::ReadInputs

    CarsNorth := Obj_RoadNorth.Svr_IncomingCars.Read();
    CarsEast := Obj_RoadEast.Svr_IncomingCars.Read();
    CarsSouth := Obj_RoadSouth.Svr_IncomingCars.Read();
    CarsWest := Obj_RoadWest.Svr_IncomingCars.Read();
    
END_FUNCTION

// Writes the output to the servers so the HMI can show them.
FUNCTION TrafficControl::WriteOutputs
    VAR
        TotalAverageTimeSeconds : UDINT;
    END_VAR

    // Calculate the average between all the roads' averages. 
    Svr_AverageWaitingTime := (Obj_RoadNorth.Svr_AverageWaitingTime + Obj_RoadEast.Svr_AverageWaitingTime 
    + Obj_RoadSouth.Svr_AverageWaitingTime + Obj_RoadWest.Svr_AverageWaitingTime) / 4;
    
    // Format the average time spent waiting in traffic in Minutes/Seconds.
    TotalAverageTimeSeconds := TO_UDINT(Svr_AverageWaitingTime / 1000); 
    Svr_AverageWaitingTimeMinutes := TO_UDINT(TotalAverageTimeSeconds / 60);
    Svr_AverageWaitingTimeSeconds := TO_UDINT(TotalAverageTimeSeconds MOD 60);

END_FUNCTION

// Set the signals so Traffic lights know when to switch to green or to yellow then red.
// Only sets the light to green if there's cars incoming. 
FUNCTION TrafficControl::SetSignals
	VAR_INPUT
		NorthStopSignal 	: BOOL;
		EastStopSignal 	    : BOOL;
		SouthStopSignal 	: BOOL;
		WestStopSignal 	    : BOOL;
	END_VAR
    
        IF NorthStopSignal = FALSE & CarsNorth = 0 THEN
            Obj_TrafficLightNorth.SetSignal(ShouldStop:=TRUE);
        ELSE
            Obj_TrafficLightNorth.SetSignal(ShouldStop:=NorthStopSignal);
        END_IF;
        
        IF EastStopSignal = FALSE & CarsEast = 0 THEN
            Obj_TrafficLightEast.SetSignal(ShouldStop:=TRUE);
        ELSE
            Obj_TrafficLightEast.SetSignal(ShouldStop:=EastStopSignal);
        END_IF;
        
        IF SouthStopSignal = FALSE & CarsSouth = 0 THEN
            Obj_TrafficLightSouth.SetSignal(ShouldStop:=TRUE);
        ELSE
            Obj_TrafficLightSouth.SetSignal(ShouldStop:=SouthStopSignal);
        END_IF;
        
        IF WestStopSignal = FALSE & CarsWest = 0 THEN
            Obj_TrafficLightWest.SetSignal(ShouldStop:=TRUE);
        ELSE
            Obj_TrafficLightWest.SetSignal(ShouldStop:=WestStopSignal);
        END_IF;
        
END_FUNCTION

// Gets the dominant direction, contains all proiritisation logic. 
FUNCTION TrafficControl::SetDominantDirection
    VAR
    	TrafficEastWest         : DINT;
        TrafficNorthSouth       : DINT;
        EastWestExtraDelay      : UDINT;
        NorthSouthExtraDelay    : UDINT;
    END_VAR
    
    // Calculate totals
    TrafficEastWest := CarsEast + CarsWest;
    TrafficNorthSouth := CarsNorth + CarsSouth;
    TotalTraffic := TrafficNorthSouth + TrafficEastWest;
    
    // No traffic
    IF TotalTraffic = 0 THEN
        eDominantDirection := eNone;
        RETURN;
    END_IF;
    
    // No traffic from the North or South.
    IF TrafficNorthSouth = 0 THEN
        eDominantDirection := eEastWest;
        tSignalChanged := OPS.tAbsolute;
        RETURN;
    END_IF;
    
    // No traffic from the East or West.
    IF TrafficEastWest = 0 THEN
        eDominantDirection := eNorthSouth;
        tSignalChanged := OPS.tAbsolute;
        RETURN;
    END_IF;
    
    // Calculate ratios after traffic from both sides has been detected.
    NorthSouthCycleTime := CalculateCycleTime(TrafficA := CarsNorth, TrafficB := CarsSouth);
    EastWestCycleTime := CalculateCycleTime(TrafficA := CarsEast, TrafficB := CarsWest);
    
    // Get extra delay times for cases there's only a few cars left to go. 
    NorthSouthExtraDelay := GetExtraDelay(CarsNorth, CarsSouth);
    EastWestExtraDelay := GetExtraDelay(CarsEast, CarsWest);
    
    // Cycle through directions. Each direction has a cycle time based on the ratio of traffic it contains.
    // This should balance the traffic from each direction over time.  
    CASE eDominantDirection OF
        eNorthSouth:
        IF OPS.tAbsolute - tSignalChanged > (NorthSouthCycleTime + NorthSouthExtraDelay) THEN
            tSignalChanged := OPS.tAbsolute;
            eDominantDirection := eEastWest;
        END_IF;
        
        eEastWest:
        IF OPS.tAbsolute - tSignalChanged > (EastWestCycleTime + EastWestExtraDelay) THEN
            tSignalChanged := OPS.tAbsolute;
            eDominantDirection := eNorthSouth;
        END_IF;
    END_CASE;
    
END_FUNCTION

// Calculates a CycleTime based on the traffic ratio.
FUNCTION TrafficControl::CalculateCycleTime
	VAR_INPUT
		TrafficA 	: DINT;
		TrafficB 	: DINT;
	END_VAR
	VAR_OUTPUT
		DirectionCycleTime 	: UDINT;
	END_VAR
    VAR
    	Traffic     : DINT;
    END_VAR
    
    IF TotalTraffic = 0 THEN
        DirectionCycleTime := Svr_BaseCycleTime;
        RETURN;
    END_IF;

    Traffic := TrafficA + TrafficB;
    
    // Formula to calculate an increased or decreased CycleTime based on the ratio of total traffic.
    DirectionCycleTime := TO_UDINT(Svr_BaseCycleTime * ( Svr_CycleTimeVariable + TO_REAL(Traffic) / TotalTraffic));

END_FUNCTION

// Adds traffic randomly. 
FUNCTION TrafficControl::AddTraffic
    
    Obj_RoadNorth.Svr_IncomingCars += GetCarsRandom();
    Obj_RoadEast.Svr_IncomingCars += GetCarsRandom();
    Obj_RoadSouth.Svr_IncomingCars += GetCarsRandom();
    Obj_RoadWest.Svr_IncomingCars += GetCarsRandom();
    
END_FUNCTION

// Small chance to return a number of cars.
FUNCTION TrafficControl::GetCarsRandom
	VAR_OUTPUT
		Cars    : DINT;
	END_VAR
    VAR
        Rand    : DINT;
    END_VAR

    // 9/860 chance of 1-9 cars being added every cycle. 
    Rand := Obj_Random.GetRandomNumber(Minimum:=1, Maximum:=Svr_TrafficDensityFactor);

    IF Rand > 9 THEN
        Cars := 0;
    ELSE
        Cars := Rand; 
    END_IF;

END_FUNCTION

// Gets an extra delay in case there's only a few cars left to go. 
FUNCTION TrafficControl::GetExtraDelay
	VAR_INPUT
		CarsDirection1 	: DINT;
		CarsDirection2 	: DINT;
	END_VAR
	VAR_OUTPUT
		ExtraDelay 	: UDINT;
	END_VAR
    VAR
    	Passingtime : UDINT;
    END_VAR
    
    // If neither direction has traffic below treshold or at least one, there should be no extra delay.
    IF (CarsDirection1 > Svr_MinTrafficTreshold | CarsDirection1 = 0)
     & (CarsDirection2 > Svr_MinTrafficTreshold | CarsDirection2 = 0) 
    THEN
        ExtraDelay := 0;
        RETURN;
    END_IF;
    
    // Needs to be multiplied by the time it takes for a car to pass, so take that value from a road.
    Passingtime := Obj_RoadNorth.Svr_PassingTime.Read();
    
    // If the direction with most traffic is below treshold, adjust delay to that.
    IF CarsDirection1 > CarsDirection2 THEN
        IF CarsDirection1 <= Svr_MinTrafficTreshold THEN
            ExtraDelay := CarsDirection1$UDINT * Passingtime;
            RETURN;
        END_IF;
        
        // Direction with most traffic is above treshold, so adjust to direction with the least.
        ExtraDelay := CarsDirection2$UDINT * Passingtime;
        
    ELSE
        IF CarsDirection2 <= Svr_MinTrafficTreshold THEN
            ExtraDelay := CarsDirection2$UDINT * Passingtime;
            RETURN;
        END_IF;
        
        // Direction with most traffic is above treshold, so adjust to direction with the least.
        ExtraDelay := CarsDirection2$UDINT * Passingtime;
    END_IF;
     
    // Directions have equal traffic, take the first. 
    ExtraDelay := CarsDirection1$UDINT * Passingtime;

END_FUNCTION