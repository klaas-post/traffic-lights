//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Class\_OpenSSL\lsl_openssl.h"

(*!
<Class
	Name               = "_OpenSSL"
	Revision           = "1.9"
	GUID               = "{F23B5D1F-38BD-484C-9834-C9B61F23C513}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "true"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)"
	Comment            = "OpenSSL API">
	<Channels>
		<Server Name="ClassSvr" GUID="{85AF0D9A-7DF6-4F7C-BB05-7EB4E6593096}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\_OpenSSL\DefineCompiler.h" Include="false"/>
			<File Path=".\Class\_OpenSSL\lsl_c_openssl.h" Include="false"/>
			<File Path=".\Class\_OpenSSL\lsl_openssl.h" Include="true"/>
			<File Path=".\Source\code\OsiBaseNew.h" Include="false"/>
			<File Path=".\Source\code\OsiBaseNew.st"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner/>
		<Dokumentation Revision="1.9" Date="2022-09-02" Author="altman" Company="Sigmatek GmbH &amp; Co KG" Description="Fix function parameters for RSA_size and RSA_public_encrypt."/>
		<Dokumentation Revision="1.8" Date="2022-01-21" Author="altman" Company="Sigmatek GmbH &amp; Co KG" Description="The order of the function pointers (LSL_OPENSSL) has been corrected. &#13;&#10;Added new function (BIO_write, PEM_read_bio_RSA_PUBKEY, SHA512, SHA512_Init, SHA512_Update, SHA512_Final)&#13;&#10;Added new define NID_sha512"/>
		<Dokumentation Revision="1.7" Date="2020-05-05" Author="altman" Company="Sigmatek GmbH &amp; Co KG" Description="Added new function (EVP_sha256, SHA256)"/>
		<Dokumentation Revision="1.6" Date="2018-07-18" Author="FucHer" Company="Sigmatek GmbH &amp; Co KG" Description="Added comments for functions and parameters.&#13;&#10;d2i_RSAPrivateKey(): changed data type of parameter &lt;a&gt; from ^Void to ^pVoid.&#13;&#10;ASN1_TIME_set(): changed data type of parameter &lt;tx&gt; from ^DINT to DINT.&#13;&#10;Use dummy functions with a suitable return value."/>
		<Dokumentation Revision="1.5" Date="2018-06-19" Author="altman" Company="Sigmatek GmbH &amp; Co KG" Description="Added new function (X509_get_notBefore, X509_get_notAfter)&#13;&#10;Added new Type (ASN1_TIME)&#13;&#10;"/>
		<Dokumentation Revision="1.4" Date="2018-06-13" Author="altman" Company="Sigmatek GmbH &amp; Co KG" Description="Add new function (X509_cmp_time)&#13;&#10;Correct function parameter and CIL pointer name."/>
		<Dokumentation Revision="1.3" Date="2018-04-10" Author="altman" Company="Sigmatek GmbH &amp; Co KG" Description="Added new functions"/>
		<Dokumentation Revision="1.2" Date="2018-02-07" Author="fucher" Company="Sigmatek GmbH &amp; Co KG" Description="Added dummy functions to prevent fatal &quot;Ldr syntax error&quot; when CIL is not available.&#13;&#10;Removed duplicate entries from aMeths[]. Added missing entries to aMeths[].&#13;&#10;"/>
	</RevDoku>
</Class>
*)
_OpenSSL : CLASS
	TYPE
#pragma pack(push, 1)
	  LSL_OPENSSL : STRUCT
	    udVersion : UDINT;
	    udSize : UDINT;
	    d2i_X509 : pVoid;
	    X509_get_subject_name : pVoid;
	    X509_NAME_get_index_by_NID : pVoid;
	    X509_NAME_get_entry : pVoid;
	    X509_NAME_ENTRY_get_data : pVoid;
	    ASN1_STRING_to_UTF8 : pVoid;
	    OPENSSL_free : pVoid;
	    X509_free : pVoid;
	    SSLeay_version : pVoid;
	    OpenSSL_add_all_algorithms : pVoid;
	    ERR_load_crypto_strings : pVoid;
	    X509_STORE_CTX_get_ex_new_index : pVoid;
	    EVP_cleanup : pVoid;
	    CRYPTO_cleanup_all_ex_data : pVoid;
	    ERR_remove_state : pVoid;
	    ERR_free_strings : pVoid;
	    AES_set_encrypt_key : pVoid;
	    AES_set_decrypt_key : pVoid;
	    AES_cbc_encrypt : pVoid;
	    EVP_sha1 : pVoid;
	    HMAC : pVoid;
	    X509_STORE_free : pVoid;
	    X509_STORE_add_cert : pVoid;
	    SHA1 : pVoid;
	    RAND_bytes : pVoid;
	    RSA_generate_key : pVoid;
	    i2d_RSAPublicKey : pVoid;
	    i2d_RSAPrivateKey : pVoid;
	    d2i_RSAPrivateKey : pVoid;
	    d2i_PublicKey : pVoid;
	    d2i_PrivateKey : pVoid;
	    RSA_free : pVoid;
	    BIO_new_file : pVoid;
	    PEM_read_bio_PrivateKey : pVoid;
	    d2i_PKCS12_bio : pVoid;
	    PKCS12_parse : pVoid;
	    PKCS12_free : pVoid;
	    EVP_PKEY_get1_RSA : pVoid;
	    EVP_PKEY_free : pVoid;
	    BIO_free : pVoid;
	    PEM_write_bio_RSAPrivateKey : pVoid;
	    RSA_size : pVoid;
	    RSA_public_encrypt : pVoid;
	    RSA_private_decrypt : pVoid;
	    RSA_sign : pVoid;
	    ERR_get_error : pVoid;
	    ERR_error_string : pVoid;
	    RSA_verify : pVoid;
	    OBJ_txt2nid : pVoid;
	    X509_NAME_ENTRY_create_by_NID : pVoid;
	    X509_NAME_add_entry : pVoid;
	    X509V3_EXT_conf : pVoid;
	    X509_add_ext : pVoid;
	    X509_EXTENSION_free : pVoid;
	    X509_new : pVoid;
	    X509_set_version : pVoid;
	    X509_get_serialNumber : pVoid;
	    OPENSSL_Realloc : pVoid;
	    ASN1_INTEGER_set : pVoid;
	    X509_set_pubkey : pVoid;
	    X509_NAME_new : pVoid;
	    X509_set_subject_name : pVoid;
	    X509_set_issuer_name : pVoid;
	    X509_gmtime_adj : pVoid;
	    X509V3_set_ctx : pVoid;
	    X509_sign : pVoid;
	    X509_NAME_free : pVoid;
	    i2d_X509_bio : pVoid;
	    d2i_X509_bio : pVoid;
	    PEM_read_bio_X509 : pVoid;
	    X509_get_pubkey : pVoid;
	    OBJ_obj2nid : pVoid;
	    BIO_new : pVoid;
	    i2d_X509 : pVoid;
	    X509_verify : pVoid;
	    X509_STORE_new : pVoid;
	    CRYPTO_add_lock : pVoid;
	    X509_LOOKUP_file : pVoid;
	    X509_LOOKUP_ctrl : pVoid;
	    X509_verify_cert : pVoid;
	    X509_NAME_oneline : pVoid;
	    X509_load_crl_file : pVoid;
	    X509_STORE_CTX_new : pVoid;
	    X509_STORE_CTX_free : pVoid;
	    X509_STORE_CTX_init : pVoid;
	    X509_get_issuer_name : pVoid;
	    X509_LOOKUP_hash_dir : pVoid;
	    X509_STORE_set_flags : pVoid;
	    X509_STORE_add_lookup : pVoid;
	    X509_STORE_set_default_paths : pVoid;
	    X509_STORE_CTX_get_ex_data : pVoid;
	    X509_STORE_CTX_set_ex_data : pVoid;
	    X509_STORE_CTX_get_error : pVoid;
	    X509_STORE_CTX_get_current_cert : pVoid;
	    X509_STORE_CTX_get_error_depth : pVoid;
	    X509_verify_cert_error_string : pVoid;
	    i2d_PublicKey : pVoid;
	    EVP_PKEY_type : pVoid;
	    CRYPTO_realloc : pVoid;
	    BIO_ctrl : pVoid;
	    BIO_s_mem : pVoid;
	    BIO_s_file : pVoid;
	    X509_get_ext : pVoid;
	    EVP_PKEY_cmp : pVoid;
	    EVP_PKEY_new : pVoid;
	    ASN1_TIME_set : pVoid;
	    X509_CRL_sign : pVoid;
	    X509_PUBKEY_get : pVoid;
	    EVP_PKEY_assign : pVoid;
	    X509V3_EXT_print : pVoid;
	    X509_get_ext_by_NID : pVoid;
	    X509_CRL_set_version : pVoid;
	    X509_CRL_add0_revoked : pVoid;
	    X509_CRL_add1_ext_i2d : pVoid;
	    X509_CRL_set_lastUpdate : pVoid;
	    X509_CRL_set_nextUpdate : pVoid;
	    X509_NAME_add_entry_by_txt : pVoid;
	    X509_REVOKED_set_revocationDate : pVoid;
	    X509_CRL_set_issuer_name : pVoid;
	    X509_REVOKED_set_serialNumber : pVoid;
	    X509_NAME_ENTRY_free : pVoid;
	    X509_CRL_new : pVoid;
	    X509_CRL_free : pVoid;
	    ASN1_TIME_free : pVoid;
	    ASN1_INTEGER_new : pVoid;
	    ASN1_INTEGER_free : pVoid;
	    X509_REVOKED_new : pVoid;
	    X509_REVOKED_free : pVoid;
	    PEM_write_bio_X509_CRL : pVoid;
	    X509_cmp_time : pVoid;
	    X509_get_notBefore : pVoid;
	    X509_get_notAfter : pVoid;
	    EVP_sha256 : pVoid;
	    SHA256 : pVoid;
	    BIO_write : pVoid;
	    PEM_read_bio_RSA_PUBKEY : pVoid;
	    SHA512_Init : pVoid;
	    SHA512_Update : pVoid;
	    SHA512_Final : pVoid;
	    SHA512 : pVoid;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
  //Functions:
	
	FUNCTION _OpenSSL
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="Get the version of the OS interface." Name="GetVersion"/>
	FUNCTION VIRTUAL GLOBAL GetVersion
		VAR_OUTPUT
			ret0 	: UDINT;			//! <Variable Comment="&lt;&gt;0: version number of the OS interface&#13;&#10;  =0: error, no OpenSSL interface available." Name="GetVersion.ret0"/>
		END_VAR;
				//! <Function Comment="d2i_X509() attempts to decode &lt;len&gt; bytes at *&lt;in&gt;. If successful a pointer to the X509 structure is returned. If an error occurred, then NULL is returned.&#13;&#10;If &lt;px&gt; is not NULL, then the returned structure is written to *&lt;px&gt;. If *&lt;px&gt; is not NULL, then it is assumed that *&lt;px&gt; contains a valid X509 structure and an attempt is made to reuse it.&#13;&#10;This &quot;reuse&quot; capability is present for historical compatibility but its use is strongly discouraged (see BUGS in www.openssl.org/docs/man1.0.2/crypto/d2i_X509.html).&#13;&#10;&#13;&#10;NOTES&#13;&#10;The letters i and d in i2d_TYPE stand for &quot;internal&quot; (that is, an internal C structure) and &quot;DER&quot; respectively. So i2d_TYPE converts from internal to DER.&#13;&#10;&#13;&#10;If the call is successful *&lt;in&gt; is incremented to the byte following the parsed data.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/d2i_X509.html" Name="d2i_X509"/>
	FUNCTION __CDECL VIRTUAL GLOBAL d2i_X509
		VAR_INPUT
			px 	: ^pVoid;			//! <Variable Comment="Pointer to pointer to X509 structure (i.e. **X509).&#13;&#10;If &lt;px&gt; is not NULL, then the returned structure is written to *&lt;px&gt;." Name="d2i_X509.px"/>
			in 	: ^pChar;			//! <Variable Comment="Pointer to pointer to input buffer (i.e. **char)." Name="d2i_X509.in"/>
			len 	: DINT;			//! <Variable Comment="Number of bytes to decode." Name="d2i_X509.len"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="If successful a pointer to the X509 structure is returned.&#13;&#10;If an error occurred, then NULL is returned. The error code that can be obtained by ERR_get_error()." Name="d2i_X509.RetAddr"/>
		END_VAR;
				//! <Function Comment="X509_get_subject_name() returns the subject name of certificate &lt;a&gt;. The returned value is an internal pointer which MUST NOT be freed.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_get_subject_name.html" Name="X509_get_subject_name"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_get_subject_name
		VAR_INPUT
			a 	: ^void;			//! <Variable Comment="Pointer to an X509 structure holding certificate &lt;a&gt;." Name="X509_get_subject_name.a"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="RetAddr is a pointer to an X509_NAME structure.&#13;&#10;This pointer is an internal pointer which MUST NOT be freed." Name="X509_get_subject_name.RetAddr"/>
		END_VAR;
				//! <Function Comment="X509_NAME_get_index_by_NID() retrieves the next index matching &lt;nid&gt; after &lt;lastpos&gt;. &lt;lastpos&gt; should initially be set to -1.&#13;&#10;If there are no more entries -1 is returned. If &lt;nid&gt; is invalid (doesn&apos;t correspond to a valid OID) then -2 is returned.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/X509_NAME_get_entry.html" Name="X509_NAME_get_index_by_NID"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_NAME_get_index_by_NID
		VAR_INPUT
			name 	: ^void;			//! <Variable Comment="Pointer to X509_NAME structure." Name="X509_NAME_get_index_by_NID.name"/>
			nid 	: DINT;			//! <Variable Comment="NID.&#13;&#10;Applications which could pass invalid NIDs to X509_NAME_get_index_by_NID() should check for the return value of -2." Name="X509_NAME_get_index_by_NID.nid"/>
			lastpos 	: DINT;			//! <Variable Comment="&lt;lastpos&gt; should initially be set to -1" Name="X509_NAME_get_index_by_NID.lastpos"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Index of the next matching entry or -1 if not found.&#13;&#10;Method can also return -2 if the supplied NID is invalid." Name="X509_NAME_get_index_by_NID.RetVal"/>
		END_VAR;
				//! <Function Comment="X509_NAME_get_entry() retrieves the X509_NAME_ENTRY from &lt;name&gt; corresponding to index &lt;loc&gt;.&#13;&#10;Acceptable values for &lt;loc&gt; run from 0 to (X509_NAME_entry_count(&lt;name&gt;) - 1).&#13;&#10;The value returned is an internal pointer which must not be freed.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/X509_NAME_get_entry.html" Name="X509_NAME_get_entry"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_NAME_get_entry
		VAR_INPUT
			name 	: ^void;			//! <Variable Comment="Pointer to X509_NAME structure." Name="X509_NAME_get_entry.name"/>
			loc 	: DINT;			//! <Variable Comment="0 to (X509_NAME_entry_count(name) - 1)" Name="X509_NAME_get_entry.loc"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Pointer to an X509_NAME_ENTRY structure.&#13;&#10;This is an internal pointer which MUST NOT be freed." Name="X509_NAME_get_entry.RetAddr"/>
		END_VAR;
				//! <Function Comment="X509_NAME_ENTRY_get_data() retrieves the field value of &lt;NeAddr&gt; in an ASN1_STRING structure.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_NAME_ENTRY_get_data.html" Name="X509_NAME_ENTRY_get_data"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_NAME_ENTRY_get_data
		VAR_INPUT
			NeAddr 	: ^void;			//! <Variable Comment="Pointer to X509_NAME_ENTRY structure." Name="X509_NAME_ENTRY_get_data.NeAddr"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Pointer to ASN1_STRING structure." Name="X509_NAME_ENTRY_get_data.RetAddr"/>
		END_VAR;
				//! <Function Comment="ASN1_STRING_to_UTF8() converts the string &lt;in&gt; to UTF8 format, the converted data is allocated in a buffer in *&lt;out&gt;.&#13;&#10;The length of &lt;out&gt; is returned or a negative error code. The buffer *&lt;out&gt; should be freed using OPENSSL_free().&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/ASN1_STRING_to_UTF8.html" Name="ASN1_STRING_to_UTF8"/>
	FUNCTION __CDECL VIRTUAL GLOBAL ASN1_STRING_to_UTF8
		VAR_INPUT
			out 	: ^pChar;			//! <Variable Comment="Pointer to pointer to output buffer (i.e. **char)." Name="ASN1_STRING_to_UTF8.out"/>
			in 	: ^void;			//! <Variable Comment="Pointer to ASN1_STRING structure." Name="ASN1_STRING_to_UTF8.in"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="The length of &lt;out&gt; or a negative error code." Name="ASN1_STRING_to_UTF8.RetVal"/>
		END_VAR;
				//! <Function Comment="OPENSSL_free() is like the C free() function.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/OPENSSL_malloc.html" Name="OPENSSL_free"/>
	FUNCTION __CDECL VIRTUAL GLOBAL OPENSSL_free
		VAR_INPUT
			Addr 	: ^void;			//! <Variable Comment="Void pointer to the buffer that should be freed." Name="OPENSSL_free.Addr"/>
		END_VAR;
				//! <Function Comment="X509_free() frees up the X509 structure &lt;a&gt;.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/X509_free.html" Name="X509_free"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_free
		VAR_INPUT
			a 	: ^void;			//! <Variable Comment="Pointer to an X509 structure." Name="X509_free.a"/>
		END_VAR;
				//! <Function Comment="SSLeay_version() returns a pointer to a constant string describing the version of the OpenSSL library or giving information about the library build.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/SSLeay_version.html" Name="SSLeay_version"/>
	FUNCTION __CDECL VIRTUAL GLOBAL SSLeay_version
		VAR_INPUT
			info_type 	: DINT;			//! <Variable Comment="The following values are supported:&#13;&#10;&#13;&#10;SSLEAY_VERSION&#13;&#10;  The version of the OpenSSL library including the release date.&#13;&#10;SSLEAY_CFLAGS&#13;&#10;  The compiler flags set for the compilation process in the form &quot;compiler: ...&quot; if available or &quot;compiler: information not available&quot; otherwise.&#13;&#10;SSLEAY_BUILT_ON&#13;&#10;  The date of the build process in the form &quot;built on: ...&quot; if available or &quot;built on: date not available&quot; otherwise.&#13;&#10;SSLEAY_PLATFORM&#13;&#10;  The &quot;Configure&quot; target of the library build in the form &quot;platform: ...&quot; if available or &quot;platform: information not available&quot; otherwise.&#13;&#10;SSLEAY_DIR&#13;&#10;  The &quot;OPENSSLDIR&quot; setting of the library build in the form &quot;OPENSSLDIR: &quot;...&quot; if available or &quot;OPENSSLDIR: N/A&quot; otherwise.&#13;&#10;" Name="SSLeay_version.info_type"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^CHAR;			//! <Variable Comment="The following return values can occur:&#13;&#10;&quot;not available&quot;&#13;&#10;  An invalid value for info_type was given.&#13;&#10;Pointer to constant string&#13;&#10;  Textual description.&#13;&#10;" Name="SSLeay_version.RetAddr"/>
		END_VAR;
				//! <Function Comment="OpenSSL keeps an internal table of digest algorithms and ciphers. It uses this table to lookup ciphers via functions such as EVP_get_cipher_byname().&#13;&#10;OpenSSL_add_all_algorithms() adds all algorithms (digests and ciphers) to the table.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/OpenSSL_add_all_algorithms.html&#13;&#10;and       https://wiki.openssl.org/index.php/Libcrypto_API" Name="OpenSSL_add_all_algorithms"/>
	FUNCTION __CDECL VIRTUAL GLOBAL OpenSSL_add_all_algorithms;
				//! <Function Comment="ERR_load_crypto_strings() registers the error strings for all libcrypto functions.&#13;&#10;This function should be called before generating textual error messages. However, this is not required when memory usage is an issue.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/ERR_load_crypto_strings.html&#13;&#10;and       https://wiki.openssl.org/index.php/Libcrypto_API" Name="ERR_load_crypto_strings"/>
	FUNCTION __CDECL VIRTUAL GLOBAL ERR_load_crypto_strings;
				//! <Function Comment="The X509_STORE_CTX_get_ex_new_index() function is initially called to &quot;register&quot; some new application specific data.&#13;&#10;It takes three optional function pointers which are called when the parent structure (in this case an RSA structure) is initially created, when it is copied and when it is freed up.&#13;&#10;If any or all of these function pointer arguments are not used they should be set to NULL.&#13;&#10;It also takes additional long and pointer parameters which will be passed to the supplied functions new_func(), dup_func() and free_func() but which otherwise have no special meaning.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/X509_STORE_CTX_get_ex_new_index.html&#13;&#10;and       www.openssl.org/docs/man1.0.2/crypto/RSA_get_ex_new_index.html" Name="X509_STORE_CTX_get_ex_new_index"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_STORE_CTX_get_ex_new_index
		VAR_INPUT
			argl 	: DINT;			//! <Variable Comment="Will be passed to the supplied functions &lt;new_func&gt;, &lt;dup_func&gt;, &lt;free_func&gt;." Name="X509_STORE_CTX_get_ex_new_index.argl"/>
			argp 	: ^void;			//! <Variable Comment="Will be passed to the supplied functions &lt;new_func&gt;, &lt;dup_func&gt;, &lt;free_func&gt;." Name="X509_STORE_CTX_get_ex_new_index.argp"/>
			new_func 	: ^void;			//! <Variable Comment="Optional function pointer CRYPTO_EX_new which is called when the parent structure (in this case an RSA structure) is initially created.&#13;&#10;&#13;&#10;typedef int CRYPTO_EX_new(void *parent, void *ptr, CRYPTO_EX_DATA *ad, int idx, long argl, void *argp);" Name="X509_STORE_CTX_get_ex_new_index.new_func"/>
			dup_func 	: ^void;			//! <Variable Comment="Optional function pointer CRYPTO_EX_dup which is called when the parent structure (in this case an RSA structure) is copied.&#13;&#10;&#13;&#10;typedef int CRYPTO_EX_dup(CRYPTO_EX_DATA *to, CRYPTO_EX_DATA *from, void *from_d, int idx, long argl, void *argp);" Name="X509_STORE_CTX_get_ex_new_index.dup_func"/>
			free_func 	: ^void;			//! <Variable Comment="Optional function pointer CRYPTO_EX_free which is called when the parent structure (in this case an RSA structure) is freed up.&#13;&#10;&#13;&#10;typedef void CRYPTO_EX_free(void *parent, void *ptr, CRYPTO_EX_DATA *ad, int idx, long argl, void *argp);" Name="X509_STORE_CTX_get_ex_new_index.free_func"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns a new index or -1 on failure (note 0 is a valid index value).&#13;&#10;Each successful call will return an index greater than any previously returned." Name="X509_STORE_CTX_get_ex_new_index.RetVal"/>
		END_VAR;
				//! <Function Comment="EVP_cleanup() removes all ciphers and digests from the table used by OpenSSL_add_all_algorithms().&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/OpenSSL_add_all_algorithms.html&#13;&#10;and       https://wiki.openssl.org/index.php/Libcrypto_API" Name="EVP_cleanup"/>
	FUNCTION __CDECL VIRTUAL GLOBAL EVP_cleanup;
				//! <Function Comment="OpenSSL provides two primary libraries: libssl and libcrypto. The libcrypto library provides the fundamental cryptographic routines used by libssl. &#13;&#10;You can however use libcrypto without using libssl. In order to use libcrypto it must first be initialised.&#13;&#10;Call EVP_cleanup() and CRYPTO_cleanup_all_ex_data() do to the necessary cleanup after using the libcrypto routines.&#13;&#10;&#13;&#10;See also https://wiki.openssl.org/index.php/Libcrypto_API" Name="CRYPTO_cleanup_all_ex_data"/>
	FUNCTION __CDECL VIRTUAL GLOBAL CRYPTO_cleanup_all_ex_data;
				//! <Function Comment="ERR_remove_state() frees the error queue associated with the current thread.&#13;&#10;Since threads in OpenSSL are no longer identified by unsigned long values any argument to this function is ignored.&#13;&#10;&#13;&#10;Since error queue data structures are allocated automatically for new threads, they must be freed when threads are terminated in order to avoid memory leaks.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/ERR_remove_state.html" Name="ERR_remove_state"/>
	FUNCTION __CDECL VIRTUAL GLOBAL ERR_remove_state
		VAR_INPUT
			pid 	: UDINT;			//! <Variable Comment="Since threads in OpenSSL are no longer identified by unsigned long values any argument to this function is ignored." Name="ERR_remove_state.pid"/>
		END_VAR;
				//! <Function Comment="ERR_free_strings() frees all previously loaded error strings.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/ERR_free_strings.html" Name="ERR_free_strings"/>
	FUNCTION __CDECL VIRTUAL GLOBAL ERR_free_strings;
				//! <Function Comment="AES_set_encrypt_key() configures &lt;key&gt; to encrypt with the &lt;bits&gt;-bit key, &lt;userkey&gt;.&#13;&#10;&#13;&#10;&lt;userkey&gt; contains the actual 128-bit AES key. &lt;key&gt; is a data structure holding a transformed version of the &lt;userkey&gt;, for efficiency.&#13;&#10;&#13;&#10;See also https://boringssl.googlesource.com/boringssl/+/2490/include/openssl/aes.h&#13;&#10;and       www.cs.umd.edu/~jkatz/security/example.c" Name="AES_set_encrypt_key"/>
	FUNCTION __CDECL VIRTUAL GLOBAL AES_set_encrypt_key
		VAR_INPUT
			userkey 	: ^USINT;			//! <Variable Comment="Pointer to actual 128-bit AES key." Name="AES_set_encrypt_key.userkey"/>
			bits 	: DINT;			//! <Variable Comment="Number of bits in &lt;userkey&gt;." Name="AES_set_encrypt_key.bits"/>
			key 	: ^void;			//! <Variable Comment="Pointer to an AES_KEY structure. It holds a transformed version of the &lt;userkey&gt;, for efficiency." Name="AES_set_encrypt_key.key"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="WARNING: unlike other OpenSSL functions, this returns zero on success and a negative number on error." Name="AES_set_encrypt_key.RetVal"/>
		END_VAR;
				//! <Function Comment="AES_set_decrypt_key() configures &lt;key&gt; to decrypt with the &lt;bits&gt;-bit key, &lt;userkey&gt;.&#13;&#10;&#13;&#10;&lt;userkey&gt; contains the actual 128-bit AES key. &lt;key&gt; is a data structure holding a transformed version of the &lt;userkey&gt;, for efficiency.&#13;&#10;&#13;&#10;See also https://boringssl.googlesource.com/boringssl/+/2490/include/openssl/aes.h&#13;&#10;and       www.cs.umd.edu/~jkatz/security/example.c" Name="AES_set_decrypt_key"/>
	FUNCTION __CDECL VIRTUAL GLOBAL AES_set_decrypt_key
		VAR_INPUT
			userkey 	: ^USINT;			//! <Variable Comment="Pointer to actual 128-bit AES key." Name="AES_set_decrypt_key.userkey"/>
			bits 	: DINT;			//! <Variable Comment="Number of bits in &lt;userkey&gt;." Name="AES_set_decrypt_key.bits"/>
			key 	: ^void;			//! <Variable Comment="Pointer to an AES_KEY structure. It holds a transformed version of the &lt;userkey&gt;, for efficiency." Name="AES_set_decrypt_key.key"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="WARNING: unlike other OpenSSL functions, this returns zero on success and a negative number on error." Name="AES_set_decrypt_key.RetVal"/>
		END_VAR;
				//! <Function Comment="Low-level symmetric encryption/decryption using the AES block cipher in CBC mode (cipher-block-chaining).&#13;&#10;&#13;&#10;AES_cbc_encrypt() encrypts (or decrypts, if &lt;enc&gt; == AES_DECRYPT) &lt;len&gt; bytes from &lt;in&gt; to &lt;out&gt;.&#13;&#10;The length &lt;len&gt; must be a multiple of the block size.&#13;&#10;&#13;&#10;The initialization vector is an array of 16 bytes containing random data.&#13;&#10;&#13;&#10;See also https://boringssl.googlesource.com/boringssl/+/2490/include/openssl/aes.h&#13;&#10;and       https://tls.mbed.org/kb/how-to/encrypt-with-aes-cbc" Name="AES_cbc_encrypt"/>
	FUNCTION __CDECL VIRTUAL GLOBAL AES_cbc_encrypt
		VAR_INPUT
			in 	: ^USINT;			//! <Variable Comment="Pointer to input buffer." Name="AES_cbc_encrypt.in"/>
			out 	: ^USINT;			//! <Variable Comment="Pointer to output buffer." Name="AES_cbc_encrypt.out"/>
			len 	: DINT;			//! <Variable Comment="Number of bytes. Must be a multiple of the block size (16 bytes).&#13;&#10;&lt;enc&gt; = AES_ENCRYPT: length of the plaintext.&#13;&#10;&lt;enc&gt; = AES_DECRYPT: length of the ciphertext." Name="AES_cbc_encrypt.len"/>
			key 	: ^void;			//! <Variable Comment="Pointer to an AES_KEY structure." Name="AES_cbc_encrypt.key"/>
			ivec 	: ^USINT;			//! <Variable Comment="Pointer to the initialization vector. The initialization vector contains 16 bytes of random data.&#13;&#10;&lt;ivec&gt; will be incremented." Name="AES_cbc_encrypt.ivec"/>
			enc 	: DINT;			//! <Variable Comment="AES_ENCRYPT or AES_DECRYPT." Name="AES_cbc_encrypt.enc"/>
		END_VAR;
				//! <Function Comment="EVP_sha1(): the SHA-1 algorithm which produces a 160-bit output from a given input.&#13;&#10;SHA-1 (Secure Hash Algorithm 1) is a cryptographic hash function standardized in NIST FIPS 180-4.&#13;&#10;&#13;&#10;EVP_sha1() returns an EVP_MD structure for the SHA1 digest algorithm.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/EVP_sha1.html&#13;&#10;and       www.openssl.org/docs/man1.1.1/man3/EVP_sha1.html" Name="EVP_sha1"/>
	FUNCTION __CDECL VIRTUAL GLOBAL EVP_sha1
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Pointer to an EVP_MD structure that contains the implementation of the symmetric cipher." Name="EVP_sha1.RetAddr"/>
		END_VAR;
				//! <Function Comment="HMAC is a MAC (message authentication code), i.e. a keyed hash function used for message authentication, which is based on a hash function.&#13;&#10;&#13;&#10;HMAC() computes the message authentication code of the &lt;n_val&gt; bytes at &lt;d_addr&gt; using the hash function &lt;evp_md&gt; and the key &lt;key&gt; which is &lt;key_len&gt; bytes long.&#13;&#10;&#13;&#10;It places the result in &lt;md&gt; (which must have space for the output of the hash function, which is no more than EVP_MAX_MD_SIZE bytes).&#13;&#10;If &lt;md&gt; is NULL, the digest is placed in a static array. The size of the output is placed in &lt;md_len&gt;, unless it is NULL.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/hmac.html" Name="HMAC"/>
	FUNCTION __CDECL VIRTUAL GLOBAL HMAC
		VAR_INPUT
			evp_md 	: ^void;			//! <Variable Comment="Pointer to a EVP_MD structure containing the hash function." Name="HMAC.evp_md"/>
			key 	: ^void;			//! <Variable Comment="Void pointer to the key." Name="HMAC.key"/>
			key_len 	: DINT;			//! <Variable Comment="Length of &lt;key&gt; in bytes." Name="HMAC.key_len"/>
			d_addr 	: ^USINT;			//! <Variable Comment="Pointer to input buffer." Name="HMAC.d_addr"/>
			n_val 	: DINT;			//! <Variable Comment="Length of the input buffer in bytes." Name="HMAC.n_val"/>
			md 	: ^USINT;			//! <Variable Comment="Pointer to the result buffer (which must have space for the output of the hash function, which is no more than EVP_MAX_MD_SIZE bytes).&#13;&#10;If &lt;md&gt; is NULL, the digest is placed in a static array (WARNING: not thread-safe)." Name="HMAC.md"/>
			md_len 	: ^UDINT;			//! <Variable Comment="Pointer to the size of the output in &lt;md&gt;." Name="HMAC.md_len"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^USINT;			//! <Variable Comment="HMAC() returns a pointer to the message authentication code or NULL if an error occurred." Name="HMAC.RetAddr"/>
		END_VAR;
				//! <Function Comment="X509_STORE_free() frees up a single X509_STORE object.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_STORE_free.html" Name="X509_STORE_free"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_STORE_free
		VAR_INPUT
			ctx 	: ^void;			//! <Variable Comment="Pointer to the X509_STORE object." Name="X509_STORE_free.ctx"/>
		END_VAR;
				//! <Function Comment="X509_STORE_add_cert() adds a certificate to the X509_STORE&apos;s local storage.&#13;&#10;Untrusted certificates should not be added in this way.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/manmaster/man3/X509_STORE_add_cert.html&#13;&#10;and       http://www.umich.edu/~x509/ssleay/x509_store.html" Name="X509_STORE_add_cert"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_STORE_add_cert
		VAR_INPUT
			ctx 	: ^void;			//! <Variable Comment="Pointer to an X509_STORE object." Name="X509_STORE_add_cert.ctx"/>
			x 	: ^void;			//! <Variable Comment="Pointer to an X509 structure containing a certificate." Name="X509_STORE_add_cert.x"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns 1 on success or 0 on failure." Name="X509_STORE_add_cert.RetVal"/>
		END_VAR;
				//! <Function Comment="SHA-1 (Secure Hash Algorithm) is a cryptographic hash function with a 160 bit output.&#13;&#10;&#13;&#10;SHA1() computes the SHA-1 message digest of the &lt;n_val&gt; bytes at &lt;d_addr&gt; and places it in &lt;md&gt; (which must have space for SHA_DIGEST_LENGTH == 20 bytes of output).&#13;&#10;If &lt;md&gt; is NULL, the digest is placed in a static array. Note: setting &lt;md&gt; to NULL is not thread safe.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/SHA1.html" Name="SHA1"/>
	FUNCTION __CDECL VIRTUAL GLOBAL SHA1
		VAR_INPUT
			d_addr 	: ^USINT;			//! <Variable Comment="Pointer to input buffer." Name="SHA1.d_addr"/>
			n_val 	: DINT;			//! <Variable Comment="Length of the input buffer in bytes." Name="SHA1.n_val"/>
			md 	: ^USINT;			//! <Variable Comment="Pointer to the SHA-1 message digest buffer (&lt;md&gt; must have space for SHA_DIGEST_LENGTH == 20 bytes of output). &#13;&#10;If &lt;md&gt; is NULL, the digest is placed in a static array (WARNING: not thread-safe)." Name="SHA1.md"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^USINT;			//! <Variable Comment="Returns a pointer to the hash value." Name="SHA1.RetAddr"/>
		END_VAR;
				//! <Function Comment="RAND_bytes() puts &lt;num&gt; cryptographically strong pseudo-random bytes into &lt;buf&gt;.&#13;&#10;An error occurs if the PRNG has not been seeded with enough randomness to ensure an unpredictable byte sequence.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/RAND_bytes.html" Name="RAND_bytes"/>
	FUNCTION __CDECL VIRTUAL GLOBAL RAND_bytes
		VAR_INPUT
			buf 	: ^USINT;			//! <Variable Comment="Pointer to &lt;num&gt; cryptographically strong pseudo-random bytes." Name="RAND_bytes.buf"/>
			num 	: DINT;			//! <Variable Comment="Number of bytes in &lt;buf&gt;." Name="RAND_bytes.num"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="RAND_bytes() returns 1 on success, 0 otherwise.&#13;&#10;The error code can be obtained by ERR_get_error().&#13;&#10;The function return -1 if it is not supported by the current RAND method." Name="RAND_bytes.RetVal"/>
		END_VAR;
				//! <Function Comment="RSA_generate_key() generates a key pair and returns a pointer to an RSA structure holding these keys.&#13;&#10;The pseudo-random number generator must be seeded prior to calling RSA_generate_key().&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/RSA_generate_key.html&#13;&#10;and       www.openssl.org/docs/man1.1.0/crypto/BN_generate_prime.html&#13;&#10;" Name="RSA_generate_key"/>
	FUNCTION __CDECL VIRTUAL GLOBAL RSA_generate_key
		VAR_INPUT
			bits 	: DINT;			//! <Variable Comment="Modulus size in bits. Key sizes with &lt;bits&gt; less than 1024 should be considered insecure." Name="RSA_generate_key.bits"/>
			e 	: UDINT;			//! <Variable Comment="Public exponent. The exponent is an odd number, typically 3, 17 or 65537." Name="RSA_generate_key.e"/>
			callback 	: pVoid;			//! <Variable Comment="Function pointer to old style callback function.&#13;&#10;&#13;&#10;A callback function may be used to provide feedback about the progress of the key generation.&#13;&#10;If &lt;callback&gt; is not NULL, it will be called as follows using the BN_GENCB_call() function described on the BN_generate_prime page.&#13;&#10;&#13;&#10;    While a random prime number is generated, it is called as described in BN_generate_prime.&#13;&#10;&#13;&#10;    When the n-th randomly generated prime is rejected as not suitable for the key, BN_GENCB_call(callback, 2, n) is called.&#13;&#10;&#13;&#10;    When a random p has been found with p-1 relatively prime to e, it is called as BN_GENCB_call(callback, 3, 0).&#13;&#10;&#13;&#10;The process is then repeated for prime q with BN_GENCB_call(callback, 3, 1)." Name="RSA_generate_key.callback"/>
			cb_arg 	: ^void;			//! <Variable Comment="Will be passed to the callback function:  void (*callback)(int, int, void *cb_arg)." Name="RSA_generate_key.cb_arg"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^UDINT;			//! <Variable Comment="Returns a pointer to an RSA structure holding the generated key pair on success or NULL on error." Name="RSA_generate_key.RetAddr"/>
		END_VAR;
				//! <Function Comment="i2d_RSAPublicKey() converts a PKCS#1 RSAPublicKey structure into DER format.&#13;&#10;The usage of this function is similar to the i2d_X509() described in the d2i_X509 manual page.&#13;&#10;&#13;&#10;NOTES&#13;&#10;The RSA structure passed to the public key encoding function should have all the PKCS#1 public key components present.&#13;&#10;&#13;&#10;The encoded data is in binary form and may contain embedded zeroes. Functions such as strlen() will not return the correct length of the encoded structure.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/i2d_RSAPublicKey.html&#13;&#10;and       www.openssl.org/docs/manmaster/man3/i2d_RSA_PUBKEY.html" Name="i2d_RSAPublicKey"/>
	FUNCTION __CDECL VIRTUAL GLOBAL i2d_RSAPublicKey
		VAR_INPUT
			a 	: ^void;			//! <Variable Comment="Pointer to a PKCS#1 RSA public key structure." Name="i2d_RSAPublicKey.a"/>
			pp 	: ^pChar;			//! <Variable Comment="Pointer to pointer to output buffer (i.e. **char).&#13;&#10;If &lt;pp&gt; is not NULL, the DER encoded data is written to the buffer at *&lt;pp&gt;, and *&lt;pp&gt; is incremented to point after the data just written.&#13;&#10;If *&lt;pp&gt; is NULL memory will be allocated for a buffer and the encoded data written to it. In this case *&lt;pp&gt; is not incremented and it points to the start of the data just written." Name="i2d_RSAPublicKey.pp"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns the number of bytes successfully encoded or a negative value if an error occurs." Name="i2d_RSAPublicKey.RetVal"/>
		END_VAR;
				//! <Function Comment="i2d_RSAPrivateKey() converts a PKCS#1 RSAPrivateKey structure into DER format.&#13;&#10;The usage of this function is similar to the i2d_X509() described in the d2i_X509 manual page.&#13;&#10;&#13;&#10;NOTES&#13;&#10;The RSA structure passed to the private key encoding functions should have all the PKCS#1 private key components present.&#13;&#10;&#13;&#10;The encoded data is in binary form and may contain embedded zeroes. Functions such as strlen() will not return the correct length of the encoded structure.&#13;&#10;&#13;&#10;The data encoded by the private key functions is unencrypted and therefore offers no private key security.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/i2d_RSAPublicKey.html&#13;&#10;and       www.openssl.org/docs/manmaster/man3/i2d_RSA_PUBKEY.html" Name="i2d_RSAPrivateKey"/>
	FUNCTION __CDECL VIRTUAL GLOBAL i2d_RSAPrivateKey
		VAR_INPUT
			a 	: ^void;			//! <Variable Comment="Pointer to a PKCS#1 RSA private key structure." Name="i2d_RSAPrivateKey.a"/>
			pp 	: ^pChar;			//! <Variable Comment="Pointer to pointer to output buffer (i.e. **char).&#13;&#10;If &lt;pp&gt; is not NULL, the DER encoded data is written to the buffer at *&lt;pp&gt;, and *&lt;pp&gt; is incremented to point after the data just written.&#13;&#10;If *&lt;pp&gt; is NULL memory will be allocated for a buffer and the encoded data written to it. In this case *&lt;pp&gt; is not incremented and it points to the start of the data just written." Name="i2d_RSAPrivateKey.pp"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns the number of bytes successfully encoded or a negative value if an error occurs." Name="i2d_RSAPrivateKey.RetVal"/>
		END_VAR;
				//! <Function Comment="d2i_RSAPrivateKey() converts a private key form DER format into a PKCS#1 RSA structure in internal format.&#13;&#10;The usage of this function is similar to the d2i_X509() described in the d2i_X509 manual page.&#13;&#10;&#13;&#10;NOTES&#13;&#10;The RSA structure passed to the private key encoding functions should have all the PKCS#1 private key components present.&#13;&#10;&#13;&#10;The data encoded by the private key functions is unencrypted and therefore offers no private key security.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/d2i_RSAPrivateKey.html&#13;&#10;and       www.openssl.org/docs/man1.1.0/crypto/d2i_X509.html" Name="d2i_RSAPrivateKey"/>
	FUNCTION __CDECL VIRTUAL GLOBAL d2i_RSAPrivateKey
		VAR_INPUT
			a 	: ^pVoid;			//! <Variable Comment="Pointer to pointer to RSA output structure (i.e. **RSA) for the private key in internal format.&#13;&#10;&#13;&#10;If successful a pointer to the RSA structure is returned.&#13;&#10;If an error occurred then NULL is returned.&#13;&#10;&#13;&#10;If d2i_RSAPrivateKey() is successful and &lt;a&gt; is not NULL then a pointer to the returned structure is also written to *&lt;a&gt;. &#13;&#10;On a successful return, if *&lt;a&gt; is not NULL then it is assumed that *&lt;a&gt; contains a valid RSA structure and an attempt is made to reuse it. &#13;&#10;This &quot;reuse&quot; capability is present for historical compatibility but its use is strongly discouraged." Name="d2i_RSAPrivateKey.a"/>
			pp 	: ^pChar;			//! <Variable Comment="Pointer to pointer to input buffer (i.e. **char).&#13;&#10;d2i_RSAPrivateKey() attempts to decode &lt;length&gt; bytes at *&lt;pp&gt;. &#13;&#10;If successful *&lt;pp&gt; is incremented to the byte following the parsed data. &#13;&#10; " Name="d2i_RSAPrivateKey.pp"/>
			length 	: DINT;			//! <Variable Comment="Number of bytes in the input buffer *&lt;pp&gt;." Name="d2i_RSAPrivateKey.length"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^UDINT;			//! <Variable Comment="If successful a pointer to the RSA structure is returned.&#13;&#10;If an error occurred then NULL is returned." Name="d2i_RSAPrivateKey.RetAddr"/>
		END_VAR;
				//! <Function Comment="d2i_PublicKey() converts a public key using algorithm &lt;type_val&gt; from DER format into internal format. &#13;&#10;It attempts to use any key specific format or PKCS#8 unencrypted PublicKeyInfo format.&#13;&#10;The &lt;type_val&gt; parameter should be a public key algorithm constant such as EVP_PKEY_RSA. An error occurs if the decoded key does not match &lt;type_val&gt;.&#13;&#10;This function is similar to the d2i_X509() functions; see d2i_X509.&#13;&#10;&#13;&#10;NOTES&#13;&#10;This function uses DER format and unencrypted keys.&#13;&#10;Applications wishing to encrypt or decrypt private keys should use other functions such as d2i_PKC8PrivateKey() instead.&#13;&#10;&#13;&#10;If the *&lt;a&gt; is not NULL when calling d2i_PublicKey() (i.e. an existing structure is being reused) and the key format is PKCS#8 then *&lt;a&gt; will be freed and replaced on a successful call.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/d2i_PublicKey.html&#13;&#10;and       www.openssl.org/docs/man1.1.0/crypto/d2i_X509.html" Name="d2i_PublicKey"/>
	FUNCTION __CDECL VIRTUAL GLOBAL d2i_PublicKey
		VAR_INPUT
			type_val 	: DINT;			//! <Variable Comment="Public key algorithm constant (e.g. EVP_PKEY_RSA)." Name="d2i_PublicKey.type_val"/>
			a 	: ^pVoid;			//! <Variable Comment="Pointer to pointer to EVP_PKEY output structure (i.e. **EVP_PKEY) for the public key in internal format.&#13;&#10;&#13;&#10;If successful a pointer to the EVP_PKEY structure is returned.&#13;&#10;If an error occurred then NULL is returned.&#13;&#10;&#13;&#10;If d2i_PublicKey() is successful and &lt;a&gt; is not NULL then a pointer to the returned structure is also written to *&lt;a&gt;. &#13;&#10;On a successful return, if *&lt;a&gt; is not NULL then it is assumed that *&lt;a&gt; contains a valid EVP_PKEY structure and an attempt is made to reuse it. &#13;&#10;This &quot;reuse&quot; capability is present for historical compatibility but its use is strongly discouraged." Name="d2i_PublicKey.a"/>
			pp 	: ^pChar;			//! <Variable Comment="Pointer to pointer to input buffer (i.e. **char).&#13;&#10;d2i_PublicKey() attempts to decode &lt;length&gt; bytes at *&lt;pp&gt;. &#13;&#10;If successful *&lt;pp&gt; is incremented to the byte following the parsed data. &#13;&#10; " Name="d2i_PublicKey.pp"/>
			length 	: DINT;			//! <Variable Comment="Number of bytes in the input buffer *&lt;pp&gt;." Name="d2i_PublicKey.length"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="d2i_PublicKey() returns a pointer to a valid EVP_KEY structure or NULL if an error occurs.&#13;&#10;The error code can be obtained by calling ERR_get_error()." Name="d2i_PublicKey.RetAddr"/>
		END_VAR;
				//! <Function Comment="d2i_PrivateKey() converts a private key using algorithm &lt;type_val&gt; from DER format into internal format. &#13;&#10;It attempts to use any key specific format or PKCS#8 unencrypted PrivateKeyInfo format.&#13;&#10;The &lt;type_val&gt; parameter should be a public key algorithm constant such as EVP_PKEY_RSA. An error occurs if the decoded key does not match &lt;type_val&gt;.&#13;&#10;&#13;&#10;NOTES&#13;&#10;This function uses DER format and unencrypted keys.&#13;&#10;Applications wishing to encrypt or decrypt private keys should use other functions such as d2i_PKC8PrivateKey() instead.&#13;&#10;&#13;&#10;If the *&lt;a&gt; is not NULL when calling d2i_PrivateKey() (i.e. an existing structure is being reused) and the key format is PKCS#8 then *&lt;a&gt; will be freed and replaced on a successful call.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/d2i_PublicKey.html&#13;&#10;and       www.openssl.org/docs/man1.1.0/crypto/d2i_X509.html" Name="d2i_PrivateKey"/>
	FUNCTION __CDECL VIRTUAL GLOBAL d2i_PrivateKey
		VAR_INPUT
			type_val 	: DINT;			//! <Variable Comment="Public key algorithm constant (e.g. EVP_PKEY_RSA).&#13;&#10;" Name="d2i_PrivateKey.type_val"/>
			a 	: ^pVoid;			//! <Variable Comment="Pointer to pointer to EVP_PKEY output structure (i.e. **EVP_PKEY) for the private key in internal format.&#13;&#10;&#13;&#10;If successful a pointer to the EVP_PKEY structure is returned.&#13;&#10;If an error occurred then NULL is returned.&#13;&#10;&#13;&#10;If d2i_PrivateKey() is successful and &lt;a&gt; is not NULL then a pointer to the returned structure is also written to *&lt;a&gt;. &#13;&#10;On a successful return, if *&lt;a&gt; is not NULL then it is assumed that *&lt;a&gt; contains a valid EVP_PKEY structure and an attempt is made to reuse it. &#13;&#10;This &quot;reuse&quot; capability is present for historical compatibility but its use is strongly discouraged." Name="d2i_PrivateKey.a"/>
			pp 	: ^pChar;			//! <Variable Comment="Pointer to pointer to input buffer (i.e. **char).&#13;&#10;d2i_PrivateKey() attempts to decode &lt;length&gt; bytes at *&lt;pp&gt;. &#13;&#10;If successful *&lt;pp&gt; is incremented to the byte following the parsed data. &#13;&#10;" Name="d2i_PrivateKey.pp"/>
			length 	: DINT;			//! <Variable Comment="Number of bytes in the input buffer *&lt;pp&gt;." Name="d2i_PrivateKey.length"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="d2i_PrivateKey() returns a pointer to a valid EVP_KEY structure or NULL if an error occurs.&#13;&#10;The error code can be obtained by calling ERR_get_error." Name="d2i_PrivateKey.RetAddr"/>
		END_VAR;
				//! <Function Comment="RSA_free() frees the RSA structure and its components. The key is erased before the memory is returned to the system.&#13;&#10;&#13;&#10;See www.openssl.org/docs/man1.0.2/crypto/RSA_free.html" Name="RSA_free"/>
	FUNCTION __CDECL VIRTUAL GLOBAL RSA_free
		VAR_INPUT
			Param 	: ^void;			//! <Variable Comment="Pointer to an RSA structure." Name="RSA_free.Param"/>
		END_VAR;
				//! <Function Comment="BIO_new_file() creates a new file BIO with mode &lt;mode&gt;. The meaning of &lt;mode&gt; is the same as the stdio function fopen().&#13;&#10;E.g. “w+” creates an empty file for both reading and writing. If a file with the same name already exists, its content is erased, and &#13;&#10;the file is considered as a new empty file.&#13;&#10;The BIO_CLOSE flag is set on the returned BIO.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/BIO_new_file.html" Name="BIO_new_file"/>
	FUNCTION __CDECL VIRTUAL GLOBAL BIO_new_file
		VAR_INPUT
			filename 	: ^SINT;			//! <Variable Comment="Pointer to the filename." Name="BIO_new_file.filename"/>
			mode 	: ^SINT;			//! <Variable Comment="The meaning of &lt;mode&gt; is the same as the stdio function fopen()." Name="BIO_new_file.mode"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Returns a file BIO (i.e. *BIO) or NULL if an error occurred." Name="BIO_new_file.RetAddr"/>
		END_VAR;
				//! <Function Comment="The PEM functions read or write structures in PEM format. In this sense PEM format is simply base64 encoded data surrounded by header lines.&#13;&#10;&#13;&#10;The PrivateKey functions read or write a private key in PEM format using an EVP_PKEY structure.&#13;&#10;The read functions transparently handle traditional and PKCS#8 format encrypted and unencrypted keys.&#13;&#10;&#13;&#10;The PrivateKey read routines can be used in all applications because they handle all formats transparently.&#13;&#10;&#13;&#10;PEM FUNCTION ARGUMENTS&#13;&#10;The PEM read functions all take an argument TYPE **x and return a TYPE * pointer. Where TYPE is whatever structure the function uses. &#13;&#10;If x is NULL, then the parameter is ignored. If x is not NULL but *x is NULL, then the structure returned will be written to *x.&#13;&#10;If neither x nor *x is NULL, then an attempt is made to reuse the structure at *x (but see BUGS and EXAMPLES sections).&#13;&#10;Irrespective of the value of x a pointer to the structure is always returned (or NULL if an error occurred).&#13;&#10;&#13;&#10;If the cb parameters is set to NULL and the u parameter is not NULL, then the u parameter is interpreted as a null terminated string to use as the passphrase.&#13;&#10;For callback details see under cb.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/PEM_read_bio_PrivateKey.html" Name="PEM_read_bio_PrivateKey"/>
	FUNCTION __CDECL VIRTUAL GLOBAL PEM_read_bio_PrivateKey
		VAR_INPUT
			bp_addr 	: ^void;			//! <Variable Comment="The &lt;bp_addr&gt; BIO pointer specifies the BIO to read from." Name="PEM_read_bio_PrivateKey.bp_addr"/>
			x 	: ^pVoid;			//! <Variable Comment="A void pointer to a pointer to whatever structure the function uses." Name="PEM_read_bio_PrivateKey.x"/>
			cb 	: ^void;			//! <Variable Comment="NULL or a function pointer to the callback function.&#13;&#10;This is the callback to use when querying for the pass phrase used for encrypted PEM structures (normally only private keys).&#13;&#10;&#13;&#10;The callback routine has the following form:&#13;&#10;&#13;&#10; int cb(char *buf, int size, int rwflag, void *u);&#13;&#10;   buf is the buffer to write the passphrase to.&#13;&#10;   size is the maximum length of the passphrase (i.e. the size of buf).&#13;&#10;   rwflag is a flag which is set to 0 when reading and 1 when writing. A typical routine will ask the user to verify the passphrase (for example by prompting for it twice) if rwflag is 1.&#13;&#10;   The u parameter has the same value as the u parameter passed to the PEM routine. It allows arbitrary data to be passed to the callback by the application (for example a window handle in a GUI application). &#13;&#10;&#13;&#10;The callback must return the number of characters in the passphrase or 0 if an error occurred." Name="PEM_read_bio_PrivateKey.cb"/>
			u 	: ^void;			//! <Variable Comment="If &lt;cb&gt; is set to NULL and &lt;u&gt; is not NULL, then &lt;u&gt; is interpreted as a null terminated string to use as the passphrase.&#13;&#10;If &lt;cb&gt; is not NULL, then &lt;u&gt; is passed to the callback function. See &lt;cb&gt;." Name="PEM_read_bio_PrivateKey.u"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Returns either a pointer to the structure read or NULL if an error occurred." Name="PEM_read_bio_PrivateKey.RetAddr"/>
		END_VAR;
				//! <Function Comment="This function converts an OpenSSL object from its ASN.1/DER encoding.&#13;&#10;Unlike the C structures which can have pointers to sub-objects within, the DER is a serialized encoding, suitable for sending over the network, writing to a file, and so on.&#13;&#10;&#13;&#10;d2i_PKCS12_bio() attempts to parse data from BIO &lt;bp_addr&gt;.&#13;&#10;If successful a pointer to the PKCS12 structure is returned.&#13;&#10;If &lt;p12&gt; is not NULL then a pointer to the returned structure is also written to *&lt;p12&gt;. If an error occurred then NULL is returned.&#13;&#10;&#13;&#10;On a successful return, if *&lt;p12&gt; is not NULL then it is assumed that *&lt;p12&gt; contains a valid PKCS12 structure and an attempt is made to reuse it.&#13;&#10;This &quot;reuse&quot; capability is present for historical compatibility but its use is strongly discouraged.&#13;&#10;&#13;&#10;NOTES&#13;&#10;The letters i and d in i2d_TYPE stand for &quot;internal&quot; (that is, an internal C structure) and &quot;DER&quot; respectively. So i2d_TYPE converts from internal to DER.&#13;&#10;The functions can also understand BER forms.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/d2i_PKCS12_bio.html" Name="d2i_PKCS12_bio"/>
	FUNCTION __CDECL VIRTUAL GLOBAL d2i_PKCS12_bio
		VAR_INPUT
			bp_addr 	: ^void;			//! <Variable Comment="Pointer to a BIO structure (input in DER format)." Name="d2i_PKCS12_bio.bp_addr"/>
			p12 	: ^pVoid;			//! <Variable Comment="NULL or pointer to pointer to PKCS12 structure (i.e. **PKCS12).&#13;&#10;Output in internal format." Name="d2i_PKCS12_bio.p12"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="If successful a pointer to the PKCS12 structure is returned.&#13;&#10;If an error occurred then NULL is returned." Name="d2i_PKCS12_bio.RetAddr"/>
		END_VAR;
				//! <Function Comment="PKCS12_parse() parses a PKCS12 structure.&#13;&#10;  &lt;p12&gt; is the PKCS12 structure to parse.&#13;&#10;  &lt;pass&gt; is the passphrase to use.&#13;&#10;&#13;&#10;If successful the private key will be written to *&lt;pkey&gt;, the corresponding certificate to *&lt;cert&gt; and any additional certificates to *&lt;ca&gt;.&#13;&#10;&#13;&#10;NOTES&#13;&#10;The parameters &lt;pkey&gt; and &lt;cert&gt; cannot be NULL.&#13;&#10;&lt;ca&gt; can be &lt;NULL&gt; in which case additional certificates will be discarded.&#13;&#10;*&lt;ca&gt; can also be a valid STACK in which case additional certificates are appended to *&lt;ca&gt;. If *&lt;ca&gt; is NULL a new STACK will be allocated.&#13;&#10;&#13;&#10;The friendlyName and localKeyID attributes (if present) on each certificate will be stored in the alias and keyid attributes of the X509 structure.&#13;&#10;&#13;&#10;The parameter &lt;pass&gt; is interpreted as a string in the UTF-8 encoding. If it is not valid UTF-8, then it is assumed to be ISO8859-1 instead.&#13;&#10;&#13;&#10;In particular, this means that passwords in the locale character set (or code page on Windows) must potentially be converted to UTF-8 before use.&#13;&#10;This may include passwords from local text files, or input from the terminal or command line. Refer to the documentation of UI_OpenSSL(3), for example.&#13;&#10;&#13;&#10;BUGS&#13;&#10;Only a single private key and corresponding certificate is returned by this function. More complex PKCS#12 files with multiple private keys will only return the first match.&#13;&#10;&#13;&#10;Only friendlyName and localKeyID attributes are currently stored in certificates. Other attributes are discarded.&#13;&#10;&#13;&#10;Attributes currently cannot be stored in the private key EVP_PKEY structure.&#13;&#10;&#13;&#10;&#13;&#10;See also www.openssl.org/docs/manmaster/man3/PKCS12_parse.html" Name="PKCS12_parse"/>
	FUNCTION __CDECL VIRTUAL GLOBAL PKCS12_parse
		VAR_INPUT
			p12 	: ^void;			//! <Variable Comment="Pointer to the PKCS12 structure to parse." Name="PKCS12_parse.p12"/>
			pass 	: ^SINT;			//! <Variable Comment="Pointer to the passphrase to use." Name="PKCS12_parse.pass"/>
			pkey 	: ^pVoid;			//! <Variable Comment="Pointer to pointer to an EVP_PKEY structure holding the private key (i.e. **EVP_PKEY)." Name="PKCS12_parse.pkey"/>
			cert 	: ^pVoid;			//! <Variable Comment="Pointer to pointer to a X509 structure holding the corresponding certificate (i.e. **X509)." Name="PKCS12_parse.cert"/>
			ca 	: ^pVoid;			//! <Variable Comment="Pointer to pointer to STACK_OF(X509) holding any additional certificates (i.e. **STACK_OF(X509))." Name="PKCS12_parse.ca"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="PKCS12_parse() returns 1 for success and zero if an error occurred.&#13;&#10;The error can be obtained from ERR_get_error()." Name="PKCS12_parse.RetVal"/>
		END_VAR;
				//! <Function Comment="PKCS12_free() releases the object and all pointers and sub-objects within it.&#13;&#10;&#13;&#10;See also /www.openssl.org/docs/man1.1.0/crypto/PKCS12_free.html" Name="PKCS12_free"/>
	FUNCTION __CDECL VIRTUAL GLOBAL PKCS12_free
		VAR_INPUT
			a 	: ^void;			//! <Variable Comment="Pointer to PKCS12 structure." Name="PKCS12_free.a"/>
		END_VAR;
				//! <Function Comment="EVP_PKEY_get1_RSA() returns the referenced key in &lt;pkey&gt; or NULL if the key is not of the correct type.&#13;&#10;&#13;&#10;NOTES&#13;&#10;In accordance with the OpenSSL naming convention the key obtained from or assigned to the &lt;pkey&gt; must be freed as well as &lt;pkey&gt;.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/EVP_PKEY_get1_RSA.html" Name="EVP_PKEY_get1_RSA"/>
	FUNCTION __CDECL VIRTUAL GLOBAL EVP_PKEY_get1_RSA
		VAR_INPUT
			pkey 	: ^void;			//! <Variable Comment="Pointer to an EVP_PKEY structure." Name="EVP_PKEY_get1_RSA.pkey"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Returns a pointer to an RSA structure holding the referenced key or NULL if an error occurred." Name="EVP_PKEY_get1_RSA.RetAddr"/>
		END_VAR;
				//! <Function Comment="EVP_PKEY_free() frees up the private key &lt;key&gt;.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/EVP_PKEY_free.html" Name="EVP_PKEY_free"/>
	FUNCTION __CDECL VIRTUAL GLOBAL EVP_PKEY_free
		VAR_INPUT
			key 	: ^void;			//! <Variable Comment="Pointer to an EVP_PKEY structure." Name="EVP_PKEY_free.key"/>
		END_VAR;
				//! <Function Comment="BIO_free() frees up a single BIO.&#13;&#10;Calling BIO_free() may also have some effect on the underlying I/O structure, for example it may close the file being referred to under certain circumstances.&#13;&#10;For more details see the individual BIO_METHOD descriptions.&#13;&#10;&#13;&#10;NOTES&#13;&#10;If BIO_free() is called on a BIO chain it will only free one BIO resulting in a memory leak.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/BIO_free.html" Name="BIO_free"/>
	FUNCTION __CDECL VIRTUAL GLOBAL BIO_free
		VAR_INPUT
			a 	: ^void;			//! <Variable Comment="Pointer to a BIO structure." Name="BIO_free.a"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="BIO_free() returns 1 for success and 0 for failure." Name="BIO_free.RetVal"/>
		END_VAR;
				//! <Function Comment="The PEM functions read or write structures in PEM format. In this sense PEM format is simply base64 encoded data surrounded by header lines.&#13;&#10;&#13;&#10;The PEM_write_bio_RSAPrivateKey() function processes an RSA private key using an RSA structure. The write routine uses traditional format.&#13;&#10;&#13;&#10;NOTES&#13;&#10;The old PrivateKey write routines are retained for compatibility. New applications should write private keys using the PEM_write_bio_PKCS8PrivateKey() &#13;&#10;or PEM_write_PKCS8PrivateKey() routines because they are more secure (they use an iteration count of 2048 whereas the traditional routines use a count of 1) &#13;&#10;unless compatibility with older versions of OpenSSL is important.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/PEM_write_bio_RSAPrivateKey.html" Name="PEM_write_bio_RSAPrivateKey"/>
	FUNCTION __CDECL VIRTUAL GLOBAL PEM_write_bio_RSAPrivateKey
		VAR_INPUT
			bp_addr 	: ^void;			//! <Variable Comment="Pointer to the BIO structure to write to." Name="PEM_write_bio_RSAPrivateKey.bp_addr"/>
			x 	: ^void;			//! <Variable Comment="Pointer to RSA structure holding the private key." Name="PEM_write_bio_RSAPrivateKey.x"/>
			enc 	: ^void;			//! <Variable Comment="Pointer to EVP_CIPHER specifies the encryption algorithm to use. Encryption is done at the PEM level.&#13;&#10;If this parameter is set to NULL then the private key is written in unencrypted form." Name="PEM_write_bio_RSAPrivateKey.enc"/>
			kstr 	: ^USINT;			//! <Variable Comment="If &lt;kstr&gt; is not NULL then &lt;klen&gt; bytes at &lt;kstr&gt; are used as the passphrase and &lt;cb&gt; is ignored." Name="PEM_write_bio_RSAPrivateKey.kstr"/>
			klen 	: DINT;			//! <Variable Comment="If &lt;kstr&gt; is not NULL then &lt;klen&gt; bytes at &lt;kstr&gt; are used as the passphrase and &lt;cb&gt; is ignored." Name="PEM_write_bio_RSAPrivateKey.klen"/>
			cb 	: ^void;			//! <Variable Comment="NULL or a function pointer to the callback function.&#13;&#10;This is the callback to use when querying for the pass phrase used for encrypted PEM structures (normally only private keys).&#13;&#10;&#13;&#10;The callback routine has the following form:&#13;&#10;&#13;&#10; int cb(char *buf, int size, int rwflag, void *u);&#13;&#10;   buf is the buffer to write the passphrase to.&#13;&#10;   size is the maximum length of the passphrase (i.e. the size of buf).&#13;&#10;   rwflag is a flag which is set to 0 when reading and 1 when writing. A typical routine will ask the user to verify the passphrase (for example by prompting for it twice) if rwflag is 1.&#13;&#10;   The u parameter has the same value as the u parameter passed to the PEM routine. It allows arbitrary data to be passed to the callback by the application (for example a window handle in a GUI application). &#13;&#10;&#13;&#10;The callback must return the number of characters in the passphrase or 0 if an error occurred." Name="PEM_write_bio_RSAPrivateKey.cb"/>
			u 	: ^void;			//! <Variable Comment="If &lt;cb&gt; is set to NULL and &lt;u&gt; is not NULL then &lt;u&gt; is interpreted as a null terminated string to use as the passphrase.&#13;&#10;If &lt;cb&gt; is not NULL then &lt;u&gt; is passed to the callback function. See &lt;cb&gt;." Name="PEM_write_bio_RSAPrivateKey.u"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns 1 for success or 0 for failure." Name="PEM_write_bio_RSAPrivateKey.RetVal"/>
		END_VAR;
				//! <Function Comment="This function returns the RSA modulus size in bytes. It can be used to determine how much memory must be allocated for an RSA encrypted value.&#13;&#10;&#13;&#10;rsa-&gt;n must not be NULL.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/RSA_size.html" Name="RSA_size"/>
	FUNCTION __CDECL VIRTUAL GLOBAL RSA_size
		VAR_INPUT
			rsa 	: ^void;			//! <Variable Comment="Pointer to RSA structure." Name="RSA_size.rsa"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="The size in bytes." Name="RSA_size.RetVal"/>
		END_VAR;
				//! <Function Comment="The RSA functions implement RSA public key encryption and signatures as defined in PKCS #1 v2.0 [RFC 2437].&#13;&#10;&#13;&#10;RSA_public_encrypt() encrypts the &lt;flen&gt; bytes at &lt;from_addr&gt; (usually a session key) using the public key &lt;rsa&gt; and stores the ciphertext in &lt;to_addr&gt;. &#13;&#10;&lt;to_addr&gt; must point to RSA_size(&lt;rsa&gt;) bytes of memory.&#13;&#10;The random number generator must be seeded prior to calling RSA_public_encrypt().&#13;&#10;&#13;&#10;WARNING&#13;&#10;Decryption failures in the RSA_PKCS1_PADDING mode leak information which can potentially be used to mount a Bleichenbacher padding oracle attack.&#13;&#10;This is an inherent weakness in the PKCS #1 v1.5 padding design. Prefer RSA_PKCS1_OAEP_PADDING.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/RSA_public_encrypt.html&#13;&#10;and       www.openssl.org/docs/man1.0.2/crypto/rsa.html" Name="RSA_public_encrypt"/>
	FUNCTION __CDECL VIRTUAL GLOBAL RSA_public_encrypt
		VAR_INPUT
			flen 	: DINT;			//! <Variable Comment="Number of bytes to encrypt.&#13;&#10;&#13;&#10;&lt;flen&gt; must be less than RSA_size(rsa) - 11 for the PKCS #1 v1.5 based padding modes,&#13;&#10;less than RSA_size(rsa) - 41 for RSA_PKCS1_OAEP_PADDING and exactly RSA_size(rsa) for RSA_NO_PADDING." Name="RSA_public_encrypt.flen"/>
			from_addr 	: ^USINT;			//! <Variable Comment="Pointer to the plaintext (data to be encrypted)." Name="RSA_public_encrypt.from_addr"/>
			to_addr 	: ^USINT;			//! <Variable Comment="Pointer to the ciphertext." Name="RSA_public_encrypt.to_addr"/>
			rsa 	: ^void;			//! <Variable Comment="Pointer to an RSA structure holding the public key." Name="RSA_public_encrypt.rsa"/>
			padding 	: DINT;			//! <Variable Comment="&lt;padding&gt; denotes one of the following modes:&#13;&#10;&#13;&#10;RSA_PKCS1_PADDING&#13;&#10;&#13;&#10;    PKCS #1 v1.5 padding. This currently is the most widely used mode.&#13;&#10;RSA_PKCS1_OAEP_PADDING&#13;&#10;&#13;&#10;    EME-OAEP as defined in PKCS #1 v2.0 with SHA-1, MGF1 and an empty encoding parameter. This mode is recommended for all new applications.&#13;&#10;RSA_SSLV23_PADDING&#13;&#10;&#13;&#10;    PKCS #1 v1.5 padding with an SSL-specific modification that denotes that the server is SSL3 capable.&#13;&#10;RSA_NO_PADDING&#13;&#10;&#13;&#10;    Raw RSA encryption. This mode should only be used to implement cryptographically sound padding modes in the application code. Encrypting user data directly with RSA is insecure.&#13;&#10;" Name="RSA_public_encrypt.padding"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns the size of the encrypted data (i.e., RSA_size(rsa)).&#13;&#10;On error, -1 is returned; the error codes can be obtained by ERR_get_error()." Name="RSA_public_encrypt.RetVal"/>
		END_VAR;
				//! <Function Comment="The RSA functions implement RSA public key encryption and signatures as defined in PKCS #1 v2.0 [RFC 2437].&#13;&#10;&#13;&#10;RSA_private_decrypt() decrypts the &lt;flen&gt; bytes at &lt;from_Addr&gt; using the private key &lt;rsa&gt; and stores the plaintext in &lt;to_addr&gt;.&#13;&#10;&lt;to_addr&gt; must point to a memory section large enough to hold the decrypted data (which is smaller than RSA_size(&lt;rsa&gt;)).&#13;&#10;&lt;padding&gt; is the padding mode that was used to encrypt the data.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/RSA_public_encrypt.html&#13;&#10;and       www.openssl.org/docs/man1.0.2/crypto/rsa.html" Name="RSA_private_decrypt"/>
	FUNCTION __CDECL VIRTUAL GLOBAL RSA_private_decrypt
		VAR_INPUT
			flen 	: DINT;			//! <Variable Comment="&lt;flen&gt; is RSA_size(&lt;rsa&gt;)." Name="RSA_private_decrypt.flen"/>
			from_Addr 	: ^USINT;			//! <Variable Comment="Pointer to the encrypted ciphertext." Name="RSA_private_decrypt.from_Addr"/>
			to_addr 	: ^USINT;			//! <Variable Comment="Pointer to the decrypted plaintext." Name="RSA_private_decrypt.to_addr"/>
			rsa 	: ^void;			//! <Variable Comment="Pointer to an RSA structure holding the private key." Name="RSA_private_decrypt.rsa"/>
			padding 	: DINT;			//! <Variable Comment="The padding mode that was used to encrypt the data." Name="RSA_private_decrypt.padding"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="RSA_private_decrypt() returns the size of the recovered plaintext.&#13;&#10;On error, -1 is returned; the error codes can be obtained by ERR_get_error()." Name="RSA_private_decrypt.RetVal"/>
		END_VAR;
				//! <Function Comment="RSA_sign() signs the message digest &lt;m_addr&gt; of size &lt;m_len&gt; using the private key &lt;rsa&gt; as specified in PKCS #1 v2.0.&#13;&#10;It stores the signature in &lt;sigret&gt; and the signature size in &lt;siglen&gt;. &lt;sigret&gt; must point to RSA_size(&lt;rsa&gt;) bytes of memory.&#13;&#10;Note that PKCS #1 adds meta-data, placing limits on the size of the key that can be used.&#13;&#10;&#13;&#10;BUGS&#13;&#10;Certain signatures with an improper algorithm identifier are accepted for compatibility with SSLeay 0.4.5 :-)&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/RSA_sign.html" Name="RSA_sign"/>
	FUNCTION __CDECL VIRTUAL GLOBAL RSA_sign
		VAR_INPUT
			type_val 	: DINT;			//! <Variable Comment="&lt;type_val&gt; denotes the message digest algorithm that was used to generate &lt;m_addr&gt;. It usually is one of NID_sha1, NID_ripemd160 and NID_md5.&#13;&#10;If &lt;type_val&gt; is NID_md5_sha1, an SSL signature (MD5 and SHA1 message digests with PKCS #1 padding and no algorithm identifier) is created." Name="RSA_sign.type_val"/>
			m_addr 	: ^USINT;			//! <Variable Comment="Pointer to the message digest." Name="RSA_sign.m_addr"/>
			m_len 	: DINT;			//! <Variable Comment="Length of the message digest." Name="RSA_sign.m_len"/>
			sigret 	: ^USINT;			//! <Variable Comment="Pointer to the signature." Name="RSA_sign.sigret"/>
			siglen 	: ^UDINT;			//! <Variable Comment="Pointer to the signature size." Name="RSA_sign.siglen"/>
			rsa 	: ^void;			//! <Variable Comment="Pointer to an RSA structure holding the private key as specified in PKCS #1 v2.0." Name="RSA_sign.rsa"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="RSA_sign() returns 1 on success, 0 otherwise." Name="RSA_sign.RetVal"/>
		END_VAR;
				//! <Function Comment="ERR_get_error() returns the earliest error code from the thread&apos;s error queue and removes the entry.&#13;&#10;This function can be called repeatedly until there are no more error codes to return.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/ERR_get_error.html" Name="ERR_get_error"/>
	FUNCTION __CDECL VIRTUAL GLOBAL ERR_get_error
		VAR_OUTPUT
			RetVal (EAX) 	: UDINT;			//! <Variable Comment="The error code, or 0 if there is no error in the queue." Name="ERR_get_error.RetVal"/>
		END_VAR;
				//! <Function Comment="ERR_error_string() generates a human-readable string representing the error code &lt;e&gt;, and places it at &lt;buf&gt;.&#13;&#10;&lt;buf&gt; must be at least 120 bytes long. If &lt;buf&gt; is NULL, the error string is placed in a static buffer.&#13;&#10;&#13;&#10;The string will have the following format:&#13;&#10; error:[error code]:[library name]:[function name]:[reason string]&#13;&#10;&#13;&#10;error code is an 8 digit hexadecimal number, library name, function name and reason string are ASCII text.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/ERR_error_string.html" Name="ERR_error_string"/>
	FUNCTION __CDECL VIRTUAL GLOBAL ERR_error_string
		VAR_INPUT
			e 	: UDINT;			//! <Variable Comment="Error code." Name="ERR_error_string.e"/>
			buf 	: ^CHAR;			//! <Variable Comment="Pointer to a buffer for the error string.&#13;&#10;The buffer must be at least 120 bytes long.&#13;&#10;If &lt;buf&gt; is NULL, the error string is placed in a static buffer (see RetAddr)." Name="ERR_error_string.buf"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^CHAR;			//! <Variable Comment="ERR_error_string() returns a pointer to a static buffer containing the string if &lt;buf&gt; == NULL, &lt;buf&gt; otherwise." Name="ERR_error_string.RetAddr"/>
		END_VAR;
				//! <Function Comment="RSA_verify() verifies that the signature &lt;sigbuf&gt; of size &lt;siglen&gt; matches a given message digest &lt;m_addr&gt; of size &lt;m_len&gt;.&#13;&#10;&#13;&#10;&lt;rsa&gt; is the signer&apos;s public key.&#13;&#10;&#13;&#10;BUGS&#13;&#10;Certain signatures with an improper algorithm identifier are accepted for compatibility with SSLeay 0.4.5 :-)&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/RSA_verify.html" Name="RSA_verify"/>
	FUNCTION __CDECL VIRTUAL GLOBAL RSA_verify
		VAR_INPUT
			type_val 	: DINT;			//! <Variable Comment="&lt;type_val&gt; denotes the message digest algorithm that was used to generate the signature." Name="RSA_verify.type_val"/>
			m_addr 	: ^USINT;			//! <Variable Comment="Pointer to the message digest." Name="RSA_verify.m_addr"/>
			m_len 	: UDINT;			//! <Variable Comment="Length of the message digest." Name="RSA_verify.m_len"/>
			sigbuf 	: ^USINT;			//! <Variable Comment="Pointer to the signature." Name="RSA_verify.sigbuf"/>
			siglen 	: UDINT;			//! <Variable Comment="Signature size." Name="RSA_verify.siglen"/>
			rsa 	: ^void;			//! <Variable Comment="Pointer to an RSA structure holding the signer&apos;s public key." Name="RSA_verify.rsa"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="SA_verify() returns 1 on successful verification, 0 otherwise." Name="RSA_verify.RetVal"/>
		END_VAR;
				//! <Function Comment="The ASN1 object utility functions process ASN1_OBJECT structures which are a representation of the ASN1 OBJECT IDENTIFIER (OID) type.&#13;&#10;For convenience, OIDs are usually represented in source code as numeric identifiers, or NIDs.&#13;&#10;OpenSSL has an internal table of OIDs that are generated when the library is built, and their corresponding NIDs are available as defined constants.&#13;&#10;Application code should treat all returned values -- OIDs, NIDs, or names -- as constants.&#13;&#10;&#13;&#10;OBJ_txt2nid() returns NID corresponding to text string &lt;s_addr&gt;. &lt;s_addr&gt; can be a long name, a short name or the numerical representation of an object.&#13;&#10;&#13;&#10;NOTES&#13;&#10;Objects in OpenSSL can have a short name, a long name and a numerical identifier (NID) associated with them.&#13;&#10;A standard set of objects is represented in an internal table. The appropriate values are defined in the header file objects.h.&#13;&#10;&#13;&#10;For example the OID for commonName has the following definitions:&#13;&#10;&#13;&#10; #define SN_commonName                   &quot;CN&quot;&#13;&#10; #define LN_commonName                   &quot;commonName&quot;&#13;&#10; #define NID_commonName                  13&#13;&#10;&#13;&#10;Table objects have certain advantages over other objects: for example their NIDs can be used in a C language switch statement.&#13;&#10;They are also static constant structures which are shared: that is there is only a single constant structure for each table object.&#13;&#10;&#13;&#10;Objects which are not in the table have the NID value NID_undef.&#13;&#10;&#13;&#10;Some objects are used to represent algorithms which do not have a corresponding ASN.1 OBJECT IDENTIFIER encoding (for example no OID currently exists for a particular algorithm).&#13;&#10;As a result they cannot be encoded or decoded as part of ASN.1 structures.&#13;&#10;&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/OBJ_nid2obj.html" Name="OBJ_txt2nid"/>
	FUNCTION __CDECL VIRTUAL GLOBAL OBJ_txt2nid
		VAR_INPUT
			s_addr 	: ^CHAR;			//! <Variable Comment="Pointer to a text string. The text string can be a long name, a short name or the numerical representation of an object.&#13;&#10;" Name="OBJ_txt2nid.s_addr"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns a NID or NID_undef on error." Name="OBJ_txt2nid.RetVal"/>
		END_VAR;
				//! <Function Comment="X509_NAME_ENTRY_create_by_NID() creates and returns an X509_NAME_ENTRY structure.&#13;&#10;The field name is defined by a NID &lt;nid&gt;.&#13;&#10;The field value to be added is in &lt;bytes&gt; of length &lt;len&gt;. &#13;&#10;If &lt;len&gt; is -1 then the field length is calculated internally using strlen(bytes).&#13;&#10;&#13;&#10;NOTES&#13;&#10;X509_NAME_ENTRY_create_by_NID() is seldom used in practice because X509_NAME_ENTRY structures are &#13;&#10;almost always part of X509_NAME structures and the corresponding X509_NAME functions are typically used &#13;&#10;to create and add new entries in a single operation.&#13;&#10;&#13;&#10;The arguments of this function support similar options to the similarly named one of the corresponding X509_NAME functions such as X509_NAME_add_entry_by_NID(). &#13;&#10;So for example &lt;type_val&gt; can be set to MBSTRING_ASC.&#13;&#10;The use of string types such as MBSTRING_ASC or MBSTRING_UTF8 is strongly recommended for the &lt;type_val&gt; parameter. &#13;&#10;This allows the internal code to correctly determine the type of the field and to apply length checks according to the relevant standards.&#13;&#10;&#13;&#10;BUGS&#13;&#10;&lt;type_val&gt; can still be set to V_ASN1_APP_CHOOSE to use a different algorithm to determine field types. &#13;&#10;Since this form does not understand multicharacter types, performs no length checks and can result in invalid field types its use is strongly discouraged.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_NAME_ENTRY_create_by_NID.html&#13;&#10;and       www.openssl.org/docs/man1.0.2/crypto/X509_NAME_add_entry_by_NID.html" Name="X509_NAME_ENTRY_create_by_NID"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_NAME_ENTRY_create_by_NID
		VAR_INPUT
			ne_addr 	: ^pVoid;			//! <Variable Comment="Pointer to pointer to X509_NAME_ENTRY structure (i.e. **X509_NAME_ENTRY)." Name="X509_NAME_ENTRY_create_by_NID.ne_addr"/>
			nid 	: DINT;			//! <Variable Comment="NID defining the field name." Name="X509_NAME_ENTRY_create_by_NID.nid"/>
			type_val 	: DINT;			//! <Variable Comment="Type of field.&#13;&#10;Can either be a definition of the type of bytes (such as MBSTRING_ASC) or a standard ASN1 type (such as V_ASN1_IA5STRING).&#13;&#10;&#13;&#10;The use of string types such as MBSTRING_ASC or MBSTRING_UTF8 is strongly recommended for the type parameter. &#13;&#10;This allows the internal code to correctly determine the type of the field and to apply length checks according to the relevant standards. &#13;&#10;This is done using ASN1_STRING_set_by_NID().&#13;&#10;&#13;&#10;If instead an ASN1 type is used no checks are performed and the supplied data in bytes is used directly." Name="X509_NAME_ENTRY_create_by_NID.type_val"/>
			bytes 	: ^USINT;			//! <Variable Comment="Pointer to the field value to be added." Name="X509_NAME_ENTRY_create_by_NID.bytes"/>
			len 	: DINT;			//! <Variable Comment="Length of the field value to be added.&#13;&#10;If &lt;len&gt; is -1 then the field length is calculated internally using strlen(&lt;bytes&gt;)." Name="X509_NAME_ENTRY_create_by_NID.len"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Pointer to the new X509_NAME_ENTRY structure." Name="X509_NAME_ENTRY_create_by_NID.RetAddr"/>
		END_VAR;
				//! <Function Comment="X509_NAME_add_entry() adds a copy of X509_NAME_ENTRY structure &lt;ne_addr&gt; to &lt;name&gt;. &#13;&#10;The new entry is added to a position determined by &lt;loc&gt; and &lt;set&gt;. &#13;&#10;Since a copy of &lt;ne_addr&gt; is added &lt;ne_addr&gt; must be freed up after the call.&#13;&#10;&#13;&#10;NOTES&#13;&#10;The &lt;loc&gt; and &lt;set&gt; parameters determine where a new entry should be added. For almost all applications &lt;loc&gt; can be set to -1 and &lt;set&gt; to 0. &#13;&#10;This adds a new entry to the end of name as a single valued RelativeDistinguishedName (RDN).&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/X509_NAME_add_entry_by_NID.html" Name="X509_NAME_add_entry"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_NAME_add_entry
		VAR_INPUT
			name 	: ^void;			//! <Variable Comment="Pointer to X509_NAME structure." Name="X509_NAME_add_entry.name"/>
			ne_addr 	: ^void;			//! <Variable Comment="Pointer to X509_NAME_ENTRY structure holding the data to be copied to &lt;name&gt;." Name="X509_NAME_add_entry.ne_addr"/>
			loc 	: DINT;			//! <Variable Comment="&lt;loc&gt; actually determines the index where the new entry is inserted: if it is -1 it is appended." Name="X509_NAME_add_entry.loc"/>
			set 	: DINT;			//! <Variable Comment="&lt;set&gt; determines how the new type is added. &#13;&#10;If it is zero a new RDN is created.&#13;&#10;&#13;&#10;If &lt;set&gt; is -1 or 1 it is added to the previous or next RDN structure respectively. &#13;&#10;This will then be a multivalued RDN: since multivalue RDNs are very seldom used &lt;set&gt; is almost always set to zero." Name="X509_NAME_add_entry.set"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns 1 for success or 0 if an error occurred." Name="X509_NAME_add_entry.RetVal"/>
		END_VAR;
				//! <Function Comment="This function returns an extension based on a &lt;name&gt; and &lt;value&gt; pair. &#13;&#10;If the&#10; pair will not need to access other sections in a config file (or there is no &#10;config file) then the &lt;conf&gt; parameter can be set to NULL." Name="X509V3_EXT_conf"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509V3_EXT_conf
		VAR_INPUT
			conf 	: ^void;			//! <Variable Comment="&lt;conf&gt; is the LHASH pointer of the configuration file to use. Can be set to NULL." Name="X509V3_EXT_conf.conf"/>
			ctx 	: ^void;			//! <Variable Comment="Pointer to X509V3_CTX extension context structure. &#13;&#10;&#10;" Name="X509V3_EXT_conf.ctx"/>
			name 	: ^CHAR;			//! <Variable Comment="&lt;name&gt; and &lt;value&gt; pair identifies the extension to be returned." Name="X509V3_EXT_conf.name"/>
			value 	: ^CHAR;			//! <Variable Comment="&lt;name&gt; and &lt;value&gt; pair identifies the extension to be returned." Name="X509V3_EXT_conf.value"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Pointer to a X509_EXTENSION structure identified by the &lt;name&gt; and &lt;value&gt; pair." Name="X509V3_EXT_conf.RetAddr"/>
		END_VAR;
				//! <Function Comment="Adds extension &lt;ex&gt; to certificate &lt;x&gt; at position &lt;loc&gt;. If &lt;loc&gt; is -1 the new extension is added to the end. &#13;&#10;The passed extension &lt;ex&gt; is duplicated internally so it must be freed after use.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_add_ext.html" Name="X509_add_ext"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_add_ext
		VAR_INPUT
			x 	: ^void;			//! <Variable Comment="Pointer to a X509 structure holding a certificate." Name="X509_add_ext.x"/>
			ex 	: ^void;			//! <Variable Comment="Pointer to a X509_EXTENSION structure holding the certificate extension." Name="X509_add_ext.ex"/>
			loc 	: DINT;			//! <Variable Comment="Position within certificate." Name="X509_add_ext.loc"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns &#13;&#10;1 if the operation is successful and &#13;&#10;0 if it fails due to a non-fatal error (extension not found, already exists, cannot be encoded) or &#13;&#10;-1 due to a fatal error such as a memory allocation failure." Name="X509_add_ext.RetVal"/>
		END_VAR;
				//! <Function Comment="X509_EXTENSION_free() releases the object and all pointers and sub-objects within it.&#13;&#10;&#13;&#10;See also /www.openssl.org/docs/man1.1.0/crypto/X509_EXTENSION_free.html" Name="X509_EXTENSION_free"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_EXTENSION_free
		VAR_INPUT
			a 	: ^void;			//! <Variable Comment="Pointer to a X509_EXTENSION object." Name="X509_EXTENSION_free.a"/>
		END_VAR;
				//! <Function Comment="X509_new() allocates and initializes a X509 structure.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/X509_new.html" Name="X509_new"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_new
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="If the allocation fails, X509_new() returns NULL and sets an error code that can be obtained by ERR_get_error(). &#13;&#10;Otherwise it returns a X509 pointer to the newly allocated structure." Name="X509_new.RetAddr"/>
		END_VAR;
				//! <Function Comment="X509_set_version() sets the numerical value of the version field of certificate &lt;x&gt; to &lt;version&gt;.&#13;&#10;&#13;&#10;NOTES&#13;&#10;The version field of certificates, certificate requests and CRLs has a DEFAULT value of v1(0) meaning the field should be omitted for version 1. &#13;&#10;This is handled transparently by these functions.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_set_version.html" Name="X509_set_version"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_set_version
		VAR_INPUT
			x 	: ^void;			//! <Variable Comment="Pointer to a X509 structure holding the certificate." Name="X509_set_version.x"/>
			version 	: DINT;			//! <Variable Comment="Version number." Name="X509_set_version.version"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns 1 for success and 0 for failure." Name="X509_set_version.RetVal"/>
		END_VAR;
				//! <Function Comment="X509_get_serialNumber() returns the serial number of certificate &lt;x&gt; as an ASN1_INTEGER structure which can be examined or initialised. &#13;&#10;The value returned is an internal pointer which MUST NOT be freed up after the call.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_get_serialNumber.html" Name="X509_get_serialNumber"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_get_serialNumber
		VAR_INPUT
			x 	: ^void;			//! <Variable Comment="Pointer to a X509 structure holding the certificate." Name="X509_get_serialNumber.x"/>
			RetAddr 	: ^void;			//! <Variable Comment="Returns a pointer to an ASN1_INTEGER structure." Name="X509_get_serialNumber.RetAddr"/>
		END_VAR;
				//! <Function Comment="OpenSSL memory allocation is handled by the OPENSSL_xxx API. &#13;&#10;These are generally macro&apos;s that add the standard C __FILE__ and __LINE__ parameters and call a lower-level CRYPTO_xxx API. &#13;&#10;Some functions do not add those parameters but exist for consistency.&#13;&#10;OPENSSL_malloc(), OPENSSL_realloc(), and OPENSSL_free() are like the C malloc(), realloc(), and free() functions. &#13;&#10;OPENSSL_zalloc() calls memset() to zero the memory before returning.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/OPENSSL_realloc.html" Name="OPENSSL_Realloc"/>
	FUNCTION __CDECL VIRTUAL GLOBAL OPENSSL_Realloc
		VAR_INPUT
			addr 	: ^void;			//! <Variable Comment="Pointer to a memory block previously allocated." Name="OPENSSL_Realloc.addr"/>
			num 	: DINT;			//! <Variable Comment="New size for the memory block, in bytes." Name="OPENSSL_Realloc.num"/>
			file 	: ^CHAR;			//! <Variable Comment="The Structured Text __FILE__ parameter." Name="OPENSSL_Realloc.file"/>
			line 	: DINT;			//! <Variable Comment="The Structured Text __LINE__ parameter." Name="OPENSSL_Realloc.line"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Returns a void pointer to allocated memory or NULL on error." Name="OPENSSL_Realloc.RetAddr"/>
		END_VAR;
				//! <Function Comment="ASN1_INTEGER_set() sets the value of ASN1_INTEGER &lt;a&gt; to the long value &lt;v&gt;.&#13;&#10;&#13;&#10;NOTES&#13;&#10;In general an ASN1_INTEGER or ASN1_ENUMERATED type can contain an integer of almost arbitrary size and so cannot always be represented by a C int64_t type. &#13;&#10;However in many cases (for example version numbers) they represent small integers which can be more easily manipulated if converted to an appropriate C integer type.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/ASN1_INTEGER_set.html" Name="ASN1_INTEGER_set"/>
	FUNCTION __CDECL VIRTUAL GLOBAL ASN1_INTEGER_set
		VAR_INPUT
			a 	: ^void;			//! <Variable Comment="Pointer to a ASN1_INTEGER structure." Name="ASN1_INTEGER_set.a"/>
			v 	: DINT;			//! <Variable Comment="New value for the ASN1_INTEGER &lt;a&gt;." Name="ASN1_INTEGER_set.v"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns 1 for success and 0 for failure. It will only fail if a memory allocation error occurs." Name="ASN1_INTEGER_set.RetVal"/>
		END_VAR;
				//! <Function Comment="X509_set_pubkey() attempts to set the public key for certificate &lt;x&gt; to &lt;pkey&gt;. &#13;&#10;The key &lt;pkey&gt; should be freed up after use.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_get_pubkey.html" Name="X509_set_pubkey"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_set_pubkey
		VAR_INPUT
			x 	: ^void;			//! <Variable Comment="Pointer to a X509 structure holding the certificate." Name="X509_set_pubkey.x"/>
			pkey 	: ^void;			//! <Variable Comment="Pointer to an EVP_PKEY structure holding the public key for certificate &lt;x&gt;." Name="X509_set_pubkey.pkey"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns 1 for success and 0 for failure." Name="X509_set_pubkey.RetVal"/>
		END_VAR;
				//! <Function Comment="X509_NAME_new() allocates an empty object of type X509_NAME. &#13;&#10;The object returned must be released by calling X509_NAME_free().&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_NAME_new.html&#13;&#10;and       www.openssl.org/docs/man1.0.2/crypto/x509.html" Name="X509_NAME_new"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_NAME_new
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Returns a X509_NAME pointer to the object or NULL on failure." Name="X509_NAME_new.RetAddr"/>
		END_VAR;
				//! <Function Comment="X509_set_subject_name() sets the subject name of certificate &lt;x&gt; to &lt;name&gt;. &#13;&#10;The name parameter is copied internally and should be freed up when it is no longer needed.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_set_subject_name.html" Name="X509_set_subject_name"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_set_subject_name
		VAR_INPUT
			x 	: ^void;			//! <Variable Comment="Pointer to a X509 structure holding the certificate." Name="X509_set_subject_name.x"/>
			name 	: ^void;			//! <Variable Comment="Pointer to a X509_NAME structure holding the subject name." Name="X509_set_subject_name.name"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns 1 for success and 0 for failure." Name="X509_set_subject_name.RetVal"/>
		END_VAR;
				//! <Function Comment="X509_set_issuer_name() sets the issuer name of certificate &lt;x&gt; to &lt;name&gt;. &#13;&#10;The name parameter is copied internally and should be freed up when it is no longer needed.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_set_subject_name.html" Name="X509_set_issuer_name"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_set_issuer_name
		VAR_INPUT
			x 	: ^void;			//! <Variable Comment="Pointer to a X509 structure holding the certificate." Name="X509_set_issuer_name.x"/>
			name 	: ^void;			//! <Variable Comment="Pointer to a X509_NAME structure holding the issuer name." Name="X509_set_issuer_name.name"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns 1 for success and 0 for failure." Name="X509_set_issuer_name.RetVal"/>
		END_VAR;
				//! <Function Comment="Set or get time.&#13;&#10;X509_gmtime_adj() sets the ASN1_UTCTIME structure &lt;s_addr&gt; to the time represented&#10; by &lt;adj&gt;. &#13;&#10;The &lt;adj&gt; value can exceed the number of &#10;seconds in a day. " Name="X509_gmtime_adj"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_gmtime_adj
		VAR_INPUT
			s_addr 	: ^void;			//! <Variable Comment="Pointer to ASN1_UTCTIME structure or NULL.&#13;&#10;If &lt;s_addr&gt; is NULL a new ASN1_UTCTIME structure is allocated &#10;and returned." Name="X509_gmtime_adj.s_addr"/>
			adj 	: DINT;			//! <Variable Comment="&lt;adj&gt; contains the time in number of seconds.&#13;&#10;If &lt;adj&gt; is zero the actual time is returned in &lt;RetAddr&gt;." Name="X509_gmtime_adj.adj"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Returns a pointer to a ASN1_UTCTIME structure or NULL if an error occurred." Name="X509_gmtime_adj.RetAddr"/>
		END_VAR;
				//! <Function Comment="This function sets up an X509V3_CTX extension context structure with details of the certificate&#10; environment: specifically &#13;&#10;the issuers certificate, &#13;&#10;the subject certificate, &#13;&#10;&#10;the certificate request and the CRL. &#13;&#10;If these are not relevant or not &#10;available then they can be set to NULL. &#13;&#10;The &lt;flags&gt; parameter should be set &#10;to zero.&#13;&#10;&#13;&#10;The purpose of the extension context is to allow the extension code to &#10;access various structures relating to the &quot;environment&quot; of the certificate: &#13;&#10;&#10;for example the issuers certificate or the certificate request.&#13;&#10;" Name="X509V3_set_ctx"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509V3_set_ctx
		VAR_INPUT
			ctx 	: ^void;			//! <Variable Comment="Pointer to X509V3_CTX extension context structure. &#13;&#10;&#10;&#13;&#10;" Name="X509V3_set_ctx.ctx"/>
			issuer 	: ^void;			//! <Variable Comment="X509 pointer to the issuers certificate. Can be NULL." Name="X509V3_set_ctx.issuer"/>
			subj 	: ^void;			//! <Variable Comment="X509 pointer to the subject certificate. Can be NULL." Name="X509V3_set_ctx.subj"/>
			req 	: ^void;			//! <Variable Comment="X509_REQ pointer to the certificate request. Can be NULL." Name="X509V3_set_ctx.req"/>
			crl 	: ^void;			//! <Variable Comment="X509_CRL pointer to the CRL (Certificate Revocation List). Can be NULL." Name="X509V3_set_ctx.crl"/>
			flags 	: DINT;			//! <Variable Comment="Should be set to zero." Name="X509V3_set_ctx.flags"/>
		END_VAR;
				//! <Function Comment="X509_sign() signs certificate &lt;x&gt; using private key &lt;pkey&gt; and message digest &lt;md&gt; and sets the signature in &lt;x&gt;.&#13;&#10;&#13;&#10;NOTES&#13;&#10;For efficiency reasons and to work around ASN.1 encoding issues the encoding of the signed portion of a certificate, certificate request and CRL is cached internally. &#13;&#10;If the signed portion of the structure is modified the encoding is not always updated meaning a stale version is sometimes used. &#13;&#10;This is not normally a problem because modifying the signed portion will invalidate the signature and signing will always update the encoding.&#13;&#10;&#13;&#10;See also /www.openssl.org/docs/man1.1.0/crypto/X509_sign.html" Name="X509_sign"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_sign
		VAR_INPUT
			x 	: ^void;			//! <Variable Comment="Pointer to a X509 structure holding the certificate." Name="X509_sign.x"/>
			pkey 	: ^void;			//! <Variable Comment="Pointer to an EVP_PKEY structure holding the private key for certificate &lt;x&gt;." Name="X509_sign.pkey"/>
			md 	: ^void;			//! <Variable Comment="Pointer to a EVP_MD structure holding the message digest." Name="X509_sign.md"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns the size of the signature in bytes for success and zero for failure." Name="X509_sign.RetVal"/>
		END_VAR;
				//! <Function Comment="X509_NAME_free() releases the object and all pointers and sub-objects within it.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_NAME_free.html&#13;&#10;and       www.openssl.org/docs/man1.0.2/crypto/x509.html" Name="X509_NAME_free"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_NAME_free
		VAR_INPUT
			a 	: ^void;			//! <Variable Comment="Pointer to the X509_NAME object to be freed." Name="X509_NAME_free.a"/>
		END_VAR;
				//! <Function Comment="i2d_X509_bio() encodes the structure pointed to by &lt;x&gt; into DER format and writes the encoding of the structure &lt;x&gt; to BIO &lt;bp_addr&gt;.&#13;&#10;&#13;&#10;NOTES&#13;&#10;The letters i and d in for example i2d_X509_bio() stand for &quot;internal&quot; (that is an internal C structure) and &quot;DER&quot;. &#13;&#10;So i2d_X509 converts from internal to DER. &#13;&#10;&#13;&#10;The functions can also understand BER forms.&#13;&#10;&#13;&#10;The actual X509 structure passed to i2d_X509_bio() must be a valid populated X509 structure. &#13;&#10;It can not simply be fed with an empty structure such as that returned by X509_new().&#13;&#10;&#13;&#10;The encoded data is in binary form and may contain embedded zeroes. Therefore any FILE pointers or BIOs should be opened in binary mode. &#13;&#10;Functions such as strlen() will not return the correct length of the encoded structure.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/d2i_X509_fp.html" Name="i2d_X509_bio"/>
	FUNCTION __CDECL VIRTUAL GLOBAL i2d_X509_bio
		VAR_INPUT
			bp_addr 	: ^void;			//! <Variable Comment="Pointer to a BIO structure (output in DER format)." Name="i2d_X509_bio.bp_addr"/>
			x 	: ^void;			//! <Variable Comment="Pointer to a X509 structure holding the certificate.&#13;&#10;Input in internal format." Name="i2d_X509_bio.x"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns 1 for success and 0 for failure." Name="i2d_X509_bio.RetVal"/>
		END_VAR;
				//! <Function Comment="d2i_X509_bio() attempts to parse data from BIO &lt;bp_addr&gt;. &#13;&#10;If successful a pointer to the X509 structure is returned. If an error occurred then NULL is returned. &#13;&#10;If &lt;x&gt; is not NULL then the returned structure is written to *&lt;x&gt;. &#13;&#10;If *&lt;x&gt; is not NULL then it is assumed that *&lt;x&gt; contains a valid X509 structure and an attempt is made to reuse it. &#13;&#10;&#13;&#10;See also /www.openssl.org/docs/man1.0.2/crypto/d2i_X509_fp.html" Name="d2i_X509_bio"/>
	FUNCTION __CDECL VIRTUAL GLOBAL d2i_X509_bio
		VAR_INPUT
			bp_addr 	: ^void;			//! <Variable Comment="Pointer to a BIO structure (input in DER format)." Name="d2i_X509_bio.bp_addr"/>
			x 	: ^pVoid;			//! <Variable Comment="NULL or pointer to a pointer to a X509 structure holding the certificate.&#13;&#10;Output in internal format." Name="d2i_X509_bio.x"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="If successful a pointer to the X509 structure is returned.&#13;&#10;If an error occurred then NULL is returned." Name="d2i_X509_bio.RetAddr"/>
		END_VAR;
				//! <Function Comment="The PEM functions read or write structures in PEM format. In this sense PEM format is simply base64 encoded data surrounded by header lines.&#13;&#10;&#13;&#10;PEM_read_bio_X509() reads a certificate in PEM format from the BIO &lt;bp_addr&gt; and returns a pointer to the certificate in internal format.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/PEM_read_bio_X509.html" Name="PEM_read_bio_X509"/>
	FUNCTION __CDECL VIRTUAL GLOBAL PEM_read_bio_X509
		VAR_INPUT
			bp_addr 	: ^void;			//! <Variable Comment="Pointer to a BIO structure specifying the BIO to read from." Name="PEM_read_bio_X509.bp_addr"/>
			x 	: ^pVoid;			//! <Variable Comment="Pointer to pointer to a X509 structure.&#13;&#10;&#13;&#10;If &lt;x&gt; is NULL, then the parameter is ignored. If &lt;x&gt; is not NULL but *&lt;x&gt; is NULL, then the structure returned will be written to *&lt;x&gt;. &#13;&#10;If neither &lt;x&gt; nor *&lt;x&gt; is NULL, then an attempt is made to reuse the structure at *&lt;x&gt; (but see BUGS and EXAMPLES sections). &#13;&#10;&#13;&#10;Irrespective of the value of &lt;x&gt; a pointer to the structure is always returned (or NULL if an error occurred)." Name="PEM_read_bio_X509.x"/>
			cb 	: ^void;			//! <Variable Comment="NULL or a function pointer to the callback function.&#13;&#10;This is the callback to use when querying for the pass phrase used for encrypted PEM structures (normally only private keys).&#13;&#10;&#13;&#10;The callback routine has the following form:&#13;&#10;&#13;&#10; int cb(char *buf, int size, int rwflag, void *u);&#13;&#10;   buf is the buffer to write the passphrase to.&#13;&#10;   size is the maximum length of the passphrase (i.e. the size of buf).&#13;&#10;   rwflag is a flag which is set to 0 when reading and 1 when writing. A typical routine will ask the user to verify the passphrase (for example by prompting for it twice) if rwflag is 1.&#13;&#10;   The u parameter has the same value as the u parameter passed to the PEM routine. It allows arbitrary data to be passed to the callback by the application (for example a window handle in a GUI application). &#13;&#10;&#13;&#10;The callback must return the number of characters in the passphrase or 0 if an error occurred." Name="PEM_read_bio_X509.cb"/>
			u 	: ^void;			//! <Variable Comment="If &lt;cb&gt; is set to NULL and &lt;u&gt; is not NULL, then &lt;u&gt; is interpreted as a null terminated string to use as the passphrase.&#13;&#10;If &lt;cb&gt; is not NULL, then &lt;u&gt; is passed to the callback function. See &lt;cb&gt;." Name="PEM_read_bio_X509.u"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Pointer to a X509 structure or NULL if an error occurred." Name="PEM_read_bio_X509.RetAddr"/>
		END_VAR;
				//! <Function Comment="X509_get_pubkey() attempts to decode the public key for certificate &lt;x&gt;. &#13;&#10;If successful it returns the public key as an EVP_PKEY pointer with its reference count incremented: this means the returned key must be freed up after use.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_REQ_set_pubkey.html" Name="X509_get_pubkey"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_get_pubkey
		VAR_INPUT
			x 	: ^void;			//! <Variable Comment="Pointer to a X509 structure holding a certificate." Name="X509_get_pubkey.x"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Returns the public key as an EVP_PKEY pointer or NULL if an error occurred." Name="X509_get_pubkey.RetAddr"/>
		END_VAR;
				//! <Function Comment="OBJ_obj2nid() returns the corresponding NID for the object &lt;o&gt; or NID_undef if an error occurred.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/OBJ_obj2nid.html" Name="OBJ_obj2nid"/>
	FUNCTION __CDECL VIRTUAL GLOBAL OBJ_obj2nid
		VAR_INPUT
			o 	: ^void;			//! <Variable Comment="Pointer to an object of type ASN1_OBJECT." Name="OBJ_obj2nid.o"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="NID or NID_undef if an error occurred." Name="OBJ_obj2nid.RetVal"/>
		END_VAR;
				//! <Function Comment="The BIO_new() function returns a new BIO using method &lt;t&gt;.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/BIO_new.html" Name="BIO_new"/>
	FUNCTION __CDECL VIRTUAL GLOBAL BIO_new
		VAR_INPUT
			t 	: ^void;			//! <Variable Comment="Pointer to BIO_METHOD structure." Name="BIO_new.t"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Returns a pointer to the newly created BIO or NULL if the call fails." Name="BIO_new.RetAddr"/>
		END_VAR;
				//! <Function Comment="Encodes the structure pointed to by &lt;x&gt; into DER format. &#13;&#10;If &lt;out&gt; is not NULL it writes the DER encoded data to the buffer at *&lt;out&gt;, and increments &lt;out&gt; to point after the data just written.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/i2d_X509.html" Name="i2d_X509"/>
	FUNCTION __CDECL VIRTUAL GLOBAL i2d_X509
		VAR_INPUT
			x 	: ^void;			//! <Variable Comment="Pointer to a X509 structure holding a certificate." Name="i2d_X509.x"/>
			out 	: ^pVoid;			//! <Variable Comment="Pointer to pointer to output buffer (i.e. **unsigned char)." Name="i2d_X509.out"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns the length of the encoded data or a negative value if an error occurred." Name="i2d_X509.RetVal"/>
		END_VAR;
				//! <Function Comment="Verifies the signature of certificate &lt;a&gt; using public key &lt;rx&gt;. Only the signature is checked: no other checks (such as certificate chain validity) are performed.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_verify.html" Name="X509_verify"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_verify
		VAR_INPUT
			a 	: ^void;			//! <Variable Comment="Pointer to a X509 structure holding a certificate." Name="X509_verify.a"/>
			rx 	: ^void;			//! <Variable Comment="Pointer to EVP_PKEY structure holding the public key." Name="X509_verify.rx"/>
		END_VAR
		VAR_OUTPUT
			Retval (EAX) 	: DINT;			//! <Variable Comment="Returns 1 if the signature is valid and 0 if the signature check fails. &#13;&#10;If the signature could not be checked at all because it was invalid or some other error occurred then -1 is returned." Name="X509_verify.Retval"/>
		END_VAR;
				//! <Function Comment="X509_STORE_new() returns a newly created X509_STORE or NULL if the call fails.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_STORE_new.html" Name="X509_STORE_new"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_STORE_new
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Pointer to X509_STORE or NULL if the call fails." Name="X509_STORE_new.RetAddr"/>
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL CRYPTO_add_lock
		VAR_INPUT
			pointer 	: ^DINT;
			amount 	: DINT;
			t 	: DINT;
			file 	: ^void;
			line 	: DINT;
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL TAB RetVal;
				//! <Function Comment="X509_LOOKUP_file is a certificate lookup method to use with X509_STORE, provided by OpenSSL library.&#13;&#10;&#13;&#10;The X509_LOOKUP_file method loads all the certificates or CRLs present in a file into memory at the time the file is added as a lookup source.&#13;&#10;&#13;&#10;File format is ASCII text which contains concatenated PEM certificates and CRLs.&#13;&#10;&#13;&#10;This method should be used by applications which work with a small set of CAs.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_LOOKUP_file.html&#13;&#10;and       www.umich.edu/~x509/ssleay/x509_lookup.html&#13;&#10;and       www.umich.edu/~x509/ssleay/x509_store.html" Name="X509_LOOKUP_file"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_LOOKUP_file
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="X509_LOOKUP_file() returns a X509_LOOKUP_METHOD pointer to the static method x509_file_lookup(). &#13;&#10;This function is useful to call when you want to add a method to a stack of methods you are using. &#13;&#10;See X509_STORE documentation for more on this." Name="X509_LOOKUP_file.RetAddr"/>
		END_VAR;
				//! <Function Comment="Issues arbitrary control commands.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/manmaster/man3/X509_LOOKUP_meth_set_get_by_fingerprint.html" Name="X509_LOOKUP_ctrl"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_LOOKUP_ctrl
		VAR_INPUT
			ctx 	: ^void;			//! <Variable Comment="Pointer to X509_LOOKUP structure." Name="X509_LOOKUP_ctrl.ctx"/>
			cmd 	: DINT;			//! <Variable Comment="An arbitrary integer that defines some operation." Name="X509_LOOKUP_ctrl.cmd"/>
			argc 	: ^void;			//! <Variable Comment="Pointer to an array of characters.&#13;&#10;How argc and argl are used depends entirely on the control function." Name="X509_LOOKUP_ctrl.argc"/>
			argl 	: DINT;			//! <Variable Comment="Arbitrary integer.&#13;&#10;How argc and argl are used depends entirely on the control function." Name="X509_LOOKUP_ctrl.argl"/>
			retv 	: ^pVoid;			//! <Variable Comment="NULL or pointer to pointer to a location where any return data should be written to." Name="X509_LOOKUP_ctrl.retv"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns -1 if no method table was found.&#13;&#10;              1 if no lookup method was found.&#13;&#10;" Name="X509_LOOKUP_ctrl.RetVal"/>
		END_VAR;
				//! <Function Comment="The X509_verify_cert() function attempts to discover and validate a certificate chain based on parameters in &lt;ctx&gt;. &#13;&#10;A complete description of the process is contained in the verify manual page. &#13;&#10;&#13;&#10;See also www.openssl.org/docs/manmaster/man3/X509_verify_cert.html" Name="X509_verify_cert"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_verify_cert
		VAR_INPUT
			ctx 	: ^void;			//! <Variable Comment="Pointer to a context (X509_STORE_CTX structure)." Name="X509_verify_cert.ctx"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="If a complete chain can be built and validated this function returns 1, otherwise it return zero, in exceptional circumstances it can also return a negative code." Name="X509_verify_cert.RetVal"/>
		END_VAR;
				//! <Function Comment="X509_NAME_oneline() prints an ASCII version of &lt;a&gt; to &lt;buf&gt;. If &lt;buf&gt; is NULL then a buffer is dynamically allocated and returned, and &lt;size&gt; is ignored. &#13;&#10;Otherwise, at most &lt;size&gt; bytes will be written, including the ending &apos;\0&apos;, and &lt;buf&gt; is returned.&#13;&#10;&#13;&#10;NOTES&#13;&#10;X509_NAME_oneline() is a legacy function which produces a nonstandard output form, it doesn&apos;t handle multi character fields and has various quirks and inconsistencies. &#13;&#10;Its use is strongly discouraged in new applications.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/X509_NAME_oneline.html" Name="X509_NAME_oneline"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_NAME_oneline
		VAR_INPUT
			a 	: ^void;			//! <Variable Comment="Pointer to a X509_NAME structure." Name="X509_NAME_oneline.a"/>
			buf 	: ^void;			//! <Variable Comment="Pointer to an output buffer or NULL (*char)." Name="X509_NAME_oneline.buf"/>
			size 	: DINT;			//! <Variable Comment="Output buffer size." Name="X509_NAME_oneline.size"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Pointer to the output buffer (*char)." Name="X509_NAME_oneline.RetAddr"/>
		END_VAR;
				//! <Function Comment="Internally loading of CRLs is implemented via function X509_load_crl_file. &#13;&#10;The function supports parameter &lt;typ&gt;, which can be one of constants FILETYPE_PEM, FILETYPE_ASN1 and FILETYPE_DEFAULT. &#13;&#10;It loads CRLs from specified &lt;file&gt; into memory cache of X509_STORE objects which given &lt;ctx&gt; parameter is associated with.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_load_crl_file.html" Name="X509_load_crl_file"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_load_crl_file
		VAR_INPUT
			ctx 	: ^void;			//! <Variable Comment="Pointer to X509_LOOKUP structure." Name="X509_load_crl_file.ctx"/>
			file 	: ^void;			//! <Variable Comment="Specifies the file to read from." Name="X509_load_crl_file.file"/>
			typ 	: DINT;			//! <Variable Comment="Can be one of constants FILETYPE_PEM, FILETYPE_ASN1 and FILETYPE_DEFAULT." Name="X509_load_crl_file.typ"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns number of objects loaded from &lt;file&gt; or 0 in case of error." Name="X509_load_crl_file.RetVal"/>
		END_VAR;
				//! <Function Comment="X509_STORE_CTX_new() returns a newly initialised X509_STORE_CTX structure.&#13;&#10;&#13;&#10;NOTES&#13;&#10;The certificates and CRLs in a store are used internally and should not be freed up until after the associated X509_STORE_CTX is freed.&#13;&#10;&#13;&#10;BUGS&#13;&#10;The certificates and CRLs in a context are used internally and should not be freed up until after the associated X509_STORE_CTX is freed. &#13;&#10;Copies should be made, or reference counts increased instead.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_STORE_CTX_new.html" Name="X509_STORE_CTX_new"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_STORE_CTX_new
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Returns an newly allocated context (Pointer to X509_STORE_CTX structure) or &#13;&#10;NULL if an error occurred." Name="X509_STORE_CTX_new.RetAddr"/>
		END_VAR;
				//! <Function Comment="X509_STORE_CTX_free() completely frees up &lt;ctx&gt;. After this call &lt;ctx&gt; is no longer valid. &#13;&#10;If &lt;ctx&gt; is NULL nothing is done.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_STORE_CTX_new.html" Name="X509_STORE_CTX_free"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_STORE_CTX_free
		VAR_INPUT
			ctx 	: ^void;			//! <Variable Comment="Pointer to X509_STORE_CTX structure holding a context." Name="X509_STORE_CTX_free.ctx"/>
		END_VAR;
				//! <Function Comment="X509_STORE_CTX_init() sets up &lt;ctx&gt; for a subsequent verification operation. &#13;&#10;It must be called before each call to X509_verify_cert(), i.e. a &lt;ctx&gt; is only good for one call to X509_verify_cert(). &#13;&#10;If you want to verify a second certificate with the same &lt;ctx&gt; then you must call X509_STORE_CTX_cleanup() and then X509_STORE_CTX_init() again before the second call to X509_verify_cert(). &#13;&#10;The trusted certificate store is set to &lt;store&gt;, the end entity certificate to be verified is set to &lt;x509&gt; and a set of additional certificates (which will be untrusted but may be used to build the chain) in &lt;chain&gt;. &#13;&#10;Any or all of the &lt;store&gt;, &lt;x509&gt; and &lt;chain&gt; parameters can be NULL.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_STORE_CTX_new.html" Name="X509_STORE_CTX_init"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_STORE_CTX_init
		VAR_INPUT
			ctx 	: ^void;			//! <Variable Comment="Pointer to X509_STORE_CTX structure." Name="X509_STORE_CTX_init.ctx"/>
			store 	: ^void;			//! <Variable Comment="Pointer to X509_STORE structure or NULL" Name="X509_STORE_CTX_init.store"/>
			x509 	: ^void;			//! <Variable Comment="Pointer to X509 structure or NULL." Name="X509_STORE_CTX_init.x509"/>
			chain 	: ^void;			//! <Variable Comment="Pointer to STACK_OF(X509) or NULL." Name="X509_STORE_CTX_init.chain"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns 1 for success or 0 if an error occurred." Name="X509_STORE_CTX_init.RetVal"/>
		END_VAR;
				//! <Function Comment="Returns the issuer name of certificate &lt;a&gt;. The returned value is an internal pointer which MUST NOT be freed.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_get_subject_name.html" Name="X509_get_issuer_name"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_get_issuer_name
		VAR_INPUT
			a 	: ^void;			//! <Variable Comment="Pointer to X509 structure holding a certificate." Name="X509_get_issuer_name.a"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Returns an X509_NAME pointer." Name="X509_get_issuer_name.RetAddr"/>
		END_VAR;
				//! <Function Comment="X509_LOOKUP_hash_dir is a certificate lookup method to use with X509_STORE, provided by OpenSSL library. &#13;&#10;X509_LOOKUP_hash_dir is a more advanced method, which loads certificates and CRLs on demand, and caches them in memory once they are loaded.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_LOOKUP_hash_dir.html&#13;&#10;and       http://www.umich.edu/~x509/ssleay/x509_store.html" Name="X509_LOOKUP_hash_dir"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_LOOKUP_hash_dir
		VAR_OUTPUT
			RetVal (EAX) 	: ^void;			//! <Variable Comment="Returns 1 on success or 0 on error. " Name="X509_LOOKUP_hash_dir.RetVal"/>
		END_VAR;
				//! <Function Comment="Sets the default values for the corresponding values used in certificate chain validation. &#13;&#10;Their behavior is documented in the corresponding X509_VERIFY_PARAM manual pages, e.g., X509_VERIFY_PARAM_set_depth(3).&#13;&#10;&#13;&#10;See also www.openssl.org/docs/manmaster/man3/X509_STORE_set_flags.html" Name="X509_STORE_set_flags"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_STORE_set_flags
		VAR_INPUT
			ctx 	: ^void;			//! <Variable Comment="Pointer to X509_STORE structure.&#13;&#10;&#13;&#10;The X509_STORE structure is intended to be a consolidated mechanism for holding information about X.509 certificates and CRLs, and constructing and validating chains of certificates terminating in trusted roots. &#13;&#10;It admits multiple lookup mechanisms and efficient scaling performance with large numbers of certificates, and a great deal of flexibility in how validation and policy checks are performed." Name="X509_STORE_set_flags.ctx"/>
			flags 	: UDINT;			//! <Variable Comment="Flag values to set." Name="X509_STORE_set_flags.flags"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Always returns 1, indicating success." Name="X509_STORE_set_flags.RetVal"/>
		END_VAR;
				//! <Function Comment="Adds the X509_LOOKUP_METHOD &lt;a&gt; to the stack &lt;v&gt;-&gt;get_cert_methods after creating an X509_LOOKUP that contains it as a subfield. &#13;&#10;It returns a pointer to the new X509_LOOKUP structure or NULL on error.&#13;&#10;&#13;&#10;X509_STORE_new() creates an empty X509_STORE structure, which contains no information about trusted certificates or where such certificates are located on disk, and is generally not usable. &#13;&#10;Normally, trusted certificates will be added to the X509_STORE to prepare it for use, via mechanisms such as X509_STORE_add_lookup() and X509_LOOKUP_file(), or PEM_read_bio_X509_AUX() &#13;&#10;and X509_STORE_add_cert(). &#13;&#10;CRLs can also be added, and many behaviors configured as desired.&#13;&#10;&#13;&#10;See also http://www.umich.edu/~x509/ssleay/x509_store.html&#13;&#10;" Name="X509_STORE_add_lookup"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_STORE_add_lookup
		VAR_INPUT
			v 	: ^void;			//! <Variable Comment="Pointer to X509_STORE structure." Name="X509_STORE_add_lookup.v"/>
			a 	: ^void;			//! <Variable Comment="Pointer to X509_LOOKUP_METHOD structure holding a lookup method." Name="X509_STORE_add_lookup.a"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Returns a pointer to the new X509_LOOKUP structure or NULL on error." Name="X509_STORE_add_lookup.RetAddr"/>
		END_VAR;
				//! <Function Comment="X509_STORE_set_default_paths() is somewhat misnamed, in that it does not set what default paths should be used for loading certificates. &#13;&#10;Instead, it loads certificates into the X509_STORE from the hardcoded default paths.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.1/man3/X509_STORE_set_default_paths.html&#13;&#10;and       http://www.umich.edu/~x509/ssleay/x509_store.html" Name="X509_STORE_set_default_paths"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_STORE_set_default_paths
		VAR_INPUT
			ctx 	: ^void;			//! <Variable Comment="Pointer to X509_STORE structure." Name="X509_STORE_set_default_paths.ctx"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns 1 on success or 0 on failure." Name="X509_STORE_set_default_paths.RetVal"/>
		END_VAR;
				//! <Function Comment="Is used to retrieve application specific data. Returns the application data or 0 on failure. &#13;&#10;0 may also be valid application data but currently it can only fail if given an invalid &lt;idx&gt; parameter.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/X509_STORE_CTX_get_ex_data.html&#13;&#10;and       www.openssl.org/docs/man1.0.2/crypto/RSA_get_ex_new_index.html" Name="X509_STORE_CTX_get_ex_data"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_STORE_CTX_get_ex_data
		VAR_INPUT
			ctx 	: ^void;			//! <Variable Comment="Pointer to X509_STORE_CTX structure." Name="X509_STORE_CTX_get_ex_data.ctx"/>
			idx 	: DINT;			//! <Variable Comment="Index retrieved by RSA_get_ex_new_index()." Name="X509_STORE_CTX_get_ex_data.idx"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Pointer to the retrieved application data or NULL on failure.&#13;&#10;Since the application data can be anything at all it is passed and retrieved as a void * type." Name="X509_STORE_CTX_get_ex_data.RetAddr"/>
		END_VAR;
				//! <Function Comment="Is used to set application specific data, the data is supplied in the &lt;data&gt; parameter and its precise meaning is up to the application.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/X509_STORE_CTX_get_ex_data.html&#13;&#10;and       www.openssl.org/docs/man1.0.2/crypto/RSA_get_ex_new_index.html" Name="X509_STORE_CTX_set_ex_data"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_STORE_CTX_set_ex_data
		VAR_INPUT
			ctx 	: ^void;			//! <Variable Comment="Pointer to X509_STORE_CTX structure." Name="X509_STORE_CTX_set_ex_data.ctx"/>
			idx 	: DINT;			//! <Variable Comment="Index retrieved by RSA_get_ex_new_index()." Name="X509_STORE_CTX_set_ex_data.idx"/>
			data 	: ^void;			//! <Variable Comment="Pointer to the application data.&#13;&#10;Since the application data can be anything at all it is passed as a void * type." Name="X509_STORE_CTX_set_ex_data.data"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns 1 on success or 0 on failure." Name="X509_STORE_CTX_set_ex_data.RetVal"/>
		END_VAR;
				//! <Function Comment="X509_STORE_CTX_get_error() returns the error code of &lt;ctx&gt;, see the ERROR CODES section for a full description of all error codes. &#13;&#10;&#13;&#10;This function is typically called after X509_verify_cert() has indicated an error or in a verification callback to determine the nature of an error.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/X509_STORE_CTX_get_error.html" Name="X509_STORE_CTX_get_error"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_STORE_CTX_get_error
		VAR_INPUT
			ctx 	: ^void;			//! <Variable Comment="Pointer to X509_STORE_CTX structure." Name="X509_STORE_CTX_get_error.ctx"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns X509_V_OK or an error code.&#13;&#10;&#13;&#10;See the class documentation for a list of error codes and messages." Name="X509_STORE_CTX_get_error.RetVal"/>
		END_VAR;
				//! <Function Comment="X509_STORE_CTX_get_current_cert() returns the certificate in &lt;ctx&gt; which caused the error or NULL if no certificate is relevant.&#13;&#10;&#13;&#10;This function is typically called after X509_verify_cert() has indicated an error or in a verification callback to determine the nature of an error.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/X509_STORE_CTX_get_error.html" Name="X509_STORE_CTX_get_current_cert"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_STORE_CTX_get_current_cert
		VAR_INPUT
			ctx 	: ^void;			//! <Variable Comment="Pointer to X509_STORE_CTX structure." Name="X509_STORE_CTX_get_current_cert.ctx"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Returns a X509 pointer to the certificate which caused the error or NULL if no certificate is relevant to the error." Name="X509_STORE_CTX_get_current_cert.RetAddr"/>
		END_VAR;
				//! <Function Comment="X509_STORE_CTX_get_error_depth() returns the depth of the error. This is a non-negative integer representing where in the certificate chain the error occurred. &#13;&#10;If it is zero it occurred in the end entity certificate, one if it is the certificate which signed the end entity certificate and so on.&#13;&#10;&#13;&#10;This function is typically called after X509_verify_cert() has indicated an error or in a verification callback to determine the nature of an error.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/X509_STORE_CTX_get_error.html" Name="X509_STORE_CTX_get_error_depth"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_STORE_CTX_get_error_depth
		VAR_INPUT
			ctx 	: ^void;			//! <Variable Comment="Pointer to X509_STORE_CTX structure." Name="X509_STORE_CTX_get_error_depth.ctx"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns a non-negative error depth." Name="X509_STORE_CTX_get_error_depth.RetVal"/>
		END_VAR;
				//! <Function Comment="X509_verify_cert_error_string() returns a human readable error string for verification of error &lt;a&gt;." Name="X509_verify_cert_error_string"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_verify_cert_error_string
		VAR_INPUT
			a 	: DINT;			//! <Variable Comment="Error number." Name="X509_verify_cert_error_string.a"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Returns a human readable error string for verification of error &lt;a&gt;." Name="X509_verify_cert_error_string.RetAddr"/>
		END_VAR;
				//! <Function Comment="i2d_PublicKey() encodes key &lt;a&gt; into DER format. It uses a key specific format or, if none is defined for that key type, PKCS#8 unencrypted PublicKeyInfo format.&#13;&#10;&#13;&#10;NOTES&#13;&#10;The EVP_PKEY structure passed to the function should have all the public key components present.&#13;&#10;&#13;&#10;The encoded data is in binary form and may contain embedded zeroes. Functions such as strlen() will not return the correct length of the encoded structure.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/i2d_PublicKey.html&#13;&#10;and       www.openssl.org/docs/man1.0.2/crypto/i2d_RSAPublicKey.html&#13;&#10;and       www.openssl.org/docs/manmaster/man3/i2d_RSA_PUBKEY.html" Name="i2d_PublicKey"/>
	FUNCTION __CDECL VIRTUAL GLOBAL i2d_PublicKey
		VAR_INPUT
			a 	: ^void;			//! <Variable Comment="Pointer to a EVP_PKEY structure holding the public key." Name="i2d_PublicKey.a"/>
			pp 	: ^pVoid;			//! <Variable Comment="Pointer to pointer to output buffer (i.e. **char).&#13;&#10;If &lt;pp&gt; is not NULL, the DER encoded data is written to the buffer at *&lt;pp&gt;, and *&lt;pp&gt; is incremented to point after the data just written.&#13;&#10;If *&lt;pp&gt; is NULL memory will be allocated for a buffer and the encoded data written to it. In this case *&lt;pp&gt; is not incremented and it points to the start of the data just written." Name="i2d_PublicKey.pp"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns the number of bytes successfully encoded or a negative value if an error occurs. &#13;&#10;The error code can be obtained by calling ERR_get_error()." Name="i2d_PublicKey.RetVal"/>
		END_VAR;
				//! <Function Comment="EVP_PKEY_type() returns the type of key corresponding to the value &lt;typ&gt;. &#13;&#10;The type of a key can be obtained with EVP_PKEY_type(pkey-&gt;type). &#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/EVP_PKEY_type.html" Name="EVP_PKEY_type"/>
	FUNCTION __CDECL VIRTUAL GLOBAL EVP_PKEY_type
		VAR_INPUT
			typ 	: DINT;			//! <Variable Comment="Value retrieved with pkey-&gt;type." Name="EVP_PKEY_type.typ"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="The return value will be EVP_PKEY_RSA, EVP_PKEY_DSA, EVP_PKEY_DH or EVP_PKEY_EC for the corresponding key types or NID_undef if the key type is unassigned." Name="EVP_PKEY_type.RetVal"/>
		END_VAR;
				//! <Function Comment="Do not use this function in new code. It is provided purely for compatibility with legacy application code.&#13;&#10;This function is a wrapper around the corresponding standard realloc() function.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/CRYPTO_realloc.html&#13;&#10;and       http://man.openbsd.org/OpenBSD-6.1/OPENSSL_realloc.3" Name="CRYPTO_realloc"/>
	FUNCTION __CDECL VIRTUAL GLOBAL CRYPTO_realloc
		VAR_INPUT
			addr 	: ^void;			//! <Variable Comment="Pointer to a memory block previously allocated." Name="CRYPTO_realloc.addr"/>
			num 	: DINT;			//! <Variable Comment="New size for the memory block, in bytes." Name="CRYPTO_realloc.num"/>
			file 	: ^void;			//! <Variable Comment="The Structured Text __FILE__ parameter." Name="CRYPTO_realloc.file"/>
			line 	: DINT;			//! <Variable Comment="The Structured Text __LINE__ parameter." Name="CRYPTO_realloc.line"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Returns a void pointer to allocated memory or NULL on error." Name="CRYPTO_realloc.RetAddr"/>
		END_VAR;
				//! <Function Comment="BIO_ctrl() is a BIO &quot;control&quot; operation taking arguments of various types. &#13;&#10;This function is not normally called directly, various macros are used instead. &#13;&#10;The standard macros are described below, macros specific to a particular type of BIO are described in the specific BIOs manual page as well as any special features of the standard calls.&#13;&#10;&#13;&#10;A BIO is an I/O abstraction, it hides many of the underlying I/O details from an application. &#13;&#10;If an application uses a BIO for its I/O it can transparently handle SSL connections, unencrypted network connections and file I/O.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/BIO_ctrl.html&#13;&#10;and       www.openssl.org/docs/man1.0.2/crypto/BIO_get_read_request.html&#13;&#10;and       www.openssl.org/docs/man1.0.2/crypto/BIO_new_buffer_ssl_connect.html&#13;&#10;and       www.openssl.org/docs/man1.0.2/crypto/BIO_ctrl_reset_read_request.html&#13;&#10;and       www.openssl.org/docs/man1.0.2/crypto/BIO_f_buffer.html&#13;&#10;and       www.openssl.org/docs/man1.0.2/crypto/BIO_set_fd.html&#13;&#10;and       www.openssl.org/docs/man1.1.1/man7/bio.html" Name="BIO_ctrl"/>
	FUNCTION __CDECL VIRTUAL GLOBAL BIO_ctrl
		VAR_INPUT
			b 	: ^void;			//! <Variable Comment="Pointer to BIO structure." Name="BIO_ctrl.b"/>
			cmd 	: DINT;			//! <Variable Comment="Command code.&#13;&#10;E.g. BIO_C_MAKE_BIO_PAIR, BIO_C_DESTROY_BIO_PAIR, &#13;&#10;BIO_C_SHUTDOWN_WR, BIO_C_SET_WRITE_BUF_SIZE, BIO_C_GET_WRITE_BUF_SIZE, &#13;&#10;BIO_C_GET_WRITE_GUARANTEE, BIO_C_GET_READ_REQUEST,&#13;&#10;BIO_C_SET_SSL, BIO_C_GET_SSL,&#13;&#10;BIO_C_SSL_MODE,&#13;&#10;BIO_C_SET_SSL_RENEGOTIATE_BYTES,&#13;&#10;BIO_C_SET_SSL_RENEGOTIATE_TIMEOUT,&#13;&#10;BIO_C_SET_SSL_NUM_RENEGOTIATES,&#13;&#10;BIO_C_DO_STATE_MACHINE ........" Name="BIO_ctrl.cmd"/>
			larg 	: DINT;			//! <Variable Comment="The meaning of &lt;larg&gt; depends on parameter &lt;cmd&gt;." Name="BIO_ctrl.larg"/>
			parg 	: ^void;			//! <Variable Comment="The meaning of &lt;parg&gt; depends on parameter &lt;cmd&gt;." Name="BIO_ctrl.parg"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="The meaning of &lt;RetVal&gt; depends on parameter &lt;cmd&gt;." Name="BIO_ctrl.RetVal"/>
		END_VAR;
				//! <Function Comment="BIO_s_mem() returns the memory BIO method function.&#13;&#10;A memory BIO is a source/sink BIO which uses memory for its I/O." Name="BIO_s_mem"/>
	FUNCTION __CDECL VIRTUAL GLOBAL BIO_s_mem
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Returns a BIO_METHOD pointer to the memory BIO method function." Name="BIO_s_mem.RetAddr"/>
		END_VAR;
				//! <Function Comment="BIO_s_file() returns the BIO file method. As its name implies it is a wrapper round the stdio FILE structure and it is a source/sink BIO.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/BIO_s_file.html" Name="BIO_s_file"/>
	FUNCTION __CDECL VIRTUAL GLOBAL BIO_s_file
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Returns a BIO_METHOD pointer to the BIO file method." Name="BIO_s_file.RetAddr"/>
		END_VAR;
				//! <Function Comment="X509_get_ext() operates on the extensions of certificate &lt;x&gt;. It is otherwise identical to X509v3_get_ext().&#13;&#10;&#13;&#10;X509v3_get_ext() retrieves extension &lt;loc&gt; from &lt;x&gt;. The index &lt;loc&gt; can take any value from 0 to X509_get_ext_count(&lt;x&gt;) - 1. &#13;&#10;The returned extension is an internal pointer which must not be freed up by the application.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_get_ext.html" Name="X509_get_ext"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_get_ext
		VAR_INPUT
			x 	: ^void;			//! <Variable Comment="Pointer to X509 structure holding a certificate." Name="X509_get_ext.x"/>
			loc 	: DINT;			//! <Variable Comment="Any value from 0 to X509_get_ext_count(&lt;x&gt;) - 1. " Name="X509_get_ext.loc"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Returns an X509_EXTENSION pointer or NULL if an error occurs." Name="X509_get_ext.RetAddr"/>
		END_VAR;
				//! <Function Comment="The function EVP_PKEY_cmp() compares the public key components and parameters (if present) of keys &lt;a&gt; and &lt;b&gt;.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/EVP_PKEY_cmp.html" Name="EVP_PKEY_cmp"/>
	FUNCTION __CDECL VIRTUAL GLOBAL EVP_PKEY_cmp
		VAR_INPUT
			a 	: ^void;			//! <Variable Comment="EVP_PKEY pointer to first key." Name="EVP_PKEY_cmp.a"/>
			b 	: ^void;			//! <Variable Comment="EVP_PKEY pointer to second key." Name="EVP_PKEY_cmp.b"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns &#13;&#10;1 if the keys match, &#13;&#10;0 if they don&apos;t match, &#13;&#10;-1 if the key types are different and &#13;&#10;-2 if the operation is not supported." Name="EVP_PKEY_cmp.RetVal"/>
		END_VAR;
				//! <Function Comment="The EVP_PKEY_new() function allocates an empty EVP_PKEY structure which is used by OpenSSL to store private keys.&#13;&#10;EVP_PKEY_free() frees up the private key key.&#13;&#10;&#13;&#10;NOTES&#13;&#10;The EVP_PKEY structure is used by various OpenSSL functions which require a general private key without reference to any particular algorithm.&#13;&#10;&#13;&#10;The structure returned by EVP_PKEY_new() is empty. To add a private key to this empty structure the functions described in EVP_PKEY_set1_RSA should be used.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/EVP_PKEY_new.html" Name="EVP_PKEY_new"/>
	FUNCTION __CDECL VIRTUAL GLOBAL EVP_PKEY_new
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Returns either a pointer to the newly allocated EVP_PKEY structure of NULL if an error occurred." Name="EVP_PKEY_new.RetAddr"/>
		END_VAR;
				//! <Function Comment="The function ASN1_TIME_set() sets the ASN1_TIME structure &lt;sx&gt; to the time represented by the time_t value &lt;tx&gt;. &#13;&#10;If &lt;sx&gt; is NULL a new ASN1_TIME structure is allocated and returned.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/ASN1_TIME_set.html" Name="ASN1_TIME_set"/>
	FUNCTION __CDECL VIRTUAL GLOBAL ASN1_TIME_set
		VAR_INPUT
			sx 	: ^void;			//! <Variable Comment="Pointer to ASN1_TIME structure.&#13;&#10;&lt;sx&gt; must satisfy the ASN1_TIME format mandated by RFC 5280, i.e., its format must be either YYMMDDHHMMSSZ or YYYYMMDDHHMMSSZ (it&apos;s a literal Z at the end, meaning &quot;Zulu&quot;).&#13;&#10;" Name="ASN1_TIME_set.sx"/>
			tx 	: DINT;			//! <Variable Comment="Number of seconds since the start of the Unix epoch: midnight UTC of January 1, 1970 (not counting leap seconds)." Name="ASN1_TIME_set.tx"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Returns a pointer to an ASN1_TIME structure or NULL if an error occurred." Name="ASN1_TIME_set.RetAddr"/>
		END_VAR;
				//! <Function Comment="X509_CRL_sign() signs CRLs (Certificate Revocation Lists).&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_CRL_sign.html" Name="X509_CRL_sign"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_CRL_sign
		VAR_INPUT
			x 	: ^void;			//! <Variable Comment="Pointer to X509_CRL structure holding a certificate revocation list (CRL)." Name="X509_CRL_sign.x"/>
			pkey 	: ^void;			//! <Variable Comment="Pointer to a EVP_PKEY structure holding the private key." Name="X509_CRL_sign.pkey"/>
			md 	: ^void;			//! <Variable Comment="Pointer to a EVP_MD structure holding the message digest." Name="X509_CRL_sign.md"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns the size of the signature in bytes for success and zero for failure." Name="X509_CRL_sign.RetVal"/>
		END_VAR;
				//! <Function Comment="X509_PUBKEY_get() returns the public key contained in &lt;key&gt;.&#13;&#10;The reference count on the returned key is incremented so it MUST be freed using EVP_PKEY_free() after use.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/i2d_PUBKEY.html" Name="X509_PUBKEY_get"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_PUBKEY_get
		VAR_INPUT
			key 	: ^void;			//! <Variable Comment="Pointer to a X509_PUBKEY structure." Name="X509_PUBKEY_get.key"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Returns a pointer to an EVP_PKEY structure or NULL if an error occurs." Name="X509_PUBKEY_get.RetAddr"/>
		END_VAR;
				//! <Function Comment="Sets the referenced &lt;pkey&gt; to &lt;key&gt; however it uses the supplied &lt;key&gt; internally and so &lt;key&gt; will be freed when the parent &lt;pkey&gt; is freed.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/manmaster/man3/EVP_PKEY_set1_RSA.html" Name="EVP_PKEY_assign"/>
	FUNCTION __CDECL VIRTUAL GLOBAL EVP_PKEY_assign
		VAR_INPUT
			pKey 	: ^void;			//! <Variable Comment="Pointer to a EVP_PKEY structure." Name="EVP_PKEY_assign.pKey"/>
			typ 	: DINT;			//! <Variable Comment="Type of &lt;pkey&gt;.&#13;&#10;EVP_PKEY_RSA, EVP_PKEY_DSA, EVP_PKEY_DH or EVP_PKEY_EC." Name="EVP_PKEY_assign.typ"/>
			key 	: ^void;			//! <Variable Comment="Void pointer to the key data." Name="EVP_PKEY_assign.key"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns 1 for success and 0 for failure." Name="EVP_PKEY_assign.RetVal"/>
		END_VAR;
				//! <Function Comment="This function prints out an individual extension to a BIO pointer." Name="X509V3_EXT_print"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509V3_EXT_print
		VAR_INPUT
			out 	: ^void;			//! <Variable Comment="BIO pointer to which the extension is printed." Name="X509V3_EXT_print.out"/>
			ext 	: ^void;			//! <Variable Comment="Pointer to the X509_EXTENSION that will be printed to &lt;out&gt;." Name="X509V3_EXT_print.ext"/>
			flag 	: UDINT;			//! <Variable Comment="Currently the &lt;flag&gt; argument is unused and should be set to 0." Name="X509V3_EXT_print.flag"/>
			indent 	: DINT;			//! <Variable Comment="&lt;indent&gt; is the number of spaces to indent each line.&#13;&#10;" Name="X509V3_EXT_print.indent"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns 1 for success and 0 for failure." Name="X509V3_EXT_print.RetVal"/>
		END_VAR;
				//! <Function Comment="X509_get_ext_by_NID() looks for an extension with &lt;nid&gt; from certificate &lt;x&gt;. &#13;&#10;The search starts from the extension after &lt;lastpos&gt; or from the beginning if &lt;lastpos&gt; is -1. If the extension is found its index is returned otherwise -1 is returned.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_REVOKED_get_ext.html" Name="X509_get_ext_by_NID"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_get_ext_by_NID
		VAR_INPUT
			x 	: ^void;			//! <Variable Comment="Pointer to a X509 structure holding a certificate." Name="X509_get_ext_by_NID.x"/>
			nid 	: DINT;			//! <Variable Comment="NID value." Name="X509_get_ext_by_NID.nid"/>
			lastpos 	: DINT;			//! <Variable Comment="Should initially be set to -1, if it is set to zero the initial extension will not be checked." Name="X509_get_ext_by_NID.lastpos"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns the extension index or -1 if an error occurs.&#13;&#10;Extension indices start from zero, so a zero index return value is not an error." Name="X509_get_ext_by_NID.RetVal"/>
		END_VAR;
				//! <Function Comment="Sets the version number of a CRL (Certificate Revocation List).&#13;&#10;&#13;&#10;NOTES&#13;&#10;The version field of certificates, certificate requests and CRLs has a DEFAULT value of v1(0) meaning the field should be omitted for version 1. &#13;&#10;This is handled transparently by this function.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_CRL_set_version.html" Name="X509_CRL_set_version"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_CRL_set_version
		VAR_INPUT
			x 	: ^void;			//! <Variable Comment="Pointer to X509_CRL structure holding a certificate revocation list (CRL)." Name="X509_CRL_set_version.x"/>
			version 	: DINT;			//! <Variable Comment="Version number." Name="X509_CRL_set_version.version"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns 1 for success and 0 for failure." Name="X509_CRL_set_version.RetVal"/>
		END_VAR;
				//! <Function Comment="X509_CRL_add0_revoked() appends revoked entry &lt;rev&gt; to CRL &lt;crl&gt;. &#13;&#10;The pointer &lt;rev&gt; is used internally so it must not be freed up after the call: it is freed when the parent CRL is freed.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_CRL_add0_revoked.html&#13;&#10;and        www.openssl.org/docs/man1.0.2/crypto/crypto.html" Name="X509_CRL_add0_revoked"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_CRL_add0_revoked
		VAR_INPUT
			crl 	: ^void;			//! <Variable Comment="Pointer to X509_CRL structure holding a certificate revocation list (CRL)." Name="X509_CRL_add0_revoked.crl"/>
			rev 	: ^void;			//! <Variable Comment="Pointer to a X509_REVOKED structure holding the revoked entry." Name="X509_CRL_add0_revoked.rev"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns 1 for success and 0 for failure." Name="X509_CRL_add0_revoked.RetVal"/>
		END_VAR;
				//! <Function Comment="X509_CRL_add1_ext_i2d() adds extension &lt;value&gt; to CRL &lt;x&gt; using OID &lt;nid&gt; and criticality &lt;crit&gt; according to &lt;flags&gt;.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_CRL_add1_ext_i2d.html" Name="X509_CRL_add1_ext_i2d"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_CRL_add1_ext_i2d
		VAR_INPUT
			x 	: ^void;			//! <Variable Comment="Pointer to X509_CRL structure holding a certificate revocation list (CRL)." Name="X509_CRL_add1_ext_i2d.x"/>
			nid 	: DINT;			//! <Variable Comment="NID (Numeric Identifier) value." Name="X509_CRL_add1_ext_i2d.nid"/>
			value 	: ^void;			//! <Variable Comment="Void pointer to the extension data to be added." Name="X509_CRL_add1_ext_i2d.value"/>
			crit 	: DINT;			//! <Variable Comment="Determines the value of X509_EXTENSION.critical.&#13;&#10;0 if the extension is not critical.&#13;&#10;1 if the extension is critical." Name="X509_CRL_add1_ext_i2d.crit"/>
			flags 	: UDINT;			//! <Variable Comment="The &lt;flags&gt; parameter may be one of the following values.&#13;&#10;&#13;&#10;X509V3_ADD_DEFAULT appends a new extension only if the extension does not already exist. An error is returned if the extension does already exist.&#13;&#10;&#13;&#10;X509V3_ADD_APPEND appends a new extension, ignoring whether the extension already exists.&#13;&#10;&#13;&#10;X509V3_ADD_REPLACE replaces an extension if it exists otherwise appends a new extension.&#13;&#10;&#13;&#10;X509V3_ADD_REPLACE_EXISTING replaces an existing extension if it exists otherwise returns an error.&#13;&#10;&#13;&#10;X509V3_ADD_KEEP_EXISTING appends a new extension only if the extension does not already exist. An error is not returned if the extension does already exist.&#13;&#10;&#13;&#10;X509V3_ADD_DELETE extension nid is deleted: no new extension is added.&#13;&#10;&#13;&#10;If X509V3_ADD_SILENT is ored with flags: any error returned will not be added to the error queue." Name="X509_CRL_add1_ext_i2d.flags"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns &#13;&#10;1 if the operation is successful and &#13;&#10;0 if it fails due to a non-fatal error (extension not found, already exists, cannot be encoded) or &#13;&#10;-1 due to a fatal error such as a memory allocation failure." Name="X509_CRL_add1_ext_i2d.RetVal"/>
		END_VAR;
				//! <Function Comment="Together with X509_CRL_set_nextUpdate() it sets the validity period of the CRL &lt;x&gt;.&#13;&#10;&#13;&#10;See also https://metacpan.org/pod/Crypt::OpenSSL::CA#set_lastUpdate-($enddate)" Name="X509_CRL_set_lastUpdate"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_CRL_set_lastUpdate
		VAR_INPUT
			x 	: ^void;			//! <Variable Comment="Pointer to X509_CRL structure holding a certificate revocation list (CRL)." Name="X509_CRL_set_lastUpdate.x"/>
			tm 	: ^void;			//! <Variable Comment="Pointer to ASN1_TIME structure holding the enddate.&#13;&#10;The date must be in the GMT timezone, with the format yyyymmddhhmmssZ (it&apos;s a literal Z at the end, meaning &quot;Zulu&quot;)." Name="X509_CRL_set_lastUpdate.tm"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns 1 for success of 0 if an error occurred." Name="X509_CRL_set_lastUpdate.RetVal"/>
		END_VAR;
				//! <Function Comment="Together with X509_CRL_set_lastUpdate() it sets the validity period of the CRL &lt;x&gt;.&#13;&#10;&#13;&#10;See also https://metacpan.org/pod/Crypt::OpenSSL::CA#set_lastUpdate-($enddate)" Name="X509_CRL_set_nextUpdate"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_CRL_set_nextUpdate
		VAR_INPUT
			x 	: ^void;			//! <Variable Comment="Pointer to X509_CRL structure holding a certificate revocation list (CRL)." Name="X509_CRL_set_nextUpdate.x"/>
			tm 	: ^void;			//! <Variable Comment="Pointer to ASN1_TIME structure holding the startdate.&#13;&#10;The date must be in the GMT timezone, with the format yyyymmddhhmmssZ (it&apos;s a literal Z at the end, meaning &quot;Zulu&quot;)." Name="X509_CRL_set_nextUpdate.tm"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns 1 for success of 0 if an error occurred." Name="X509_CRL_set_nextUpdate.RetVal"/>
		END_VAR;
				//! <Function Comment="Add a field whose name is defined by the string &lt;field&gt; to &lt;name&gt;. The field value to be added is in &lt;bytes&gt; of length &lt;len&gt;. &#13;&#10;If &lt;len&gt; is -1 then the field length is calculated internally using strlen(&lt;bytes&gt;).&#13;&#10;&#13;&#10;The type of field is determined by &lt;typ&gt; which can either be a definition of the type of bytes (such as MBSTRING_ASC) or a standard ASN1 type (such as V_ASN1_IA5STRING). &#13;&#10;&#13;&#10;The &lt;loc&gt; and &lt;set&gt; parameters determine where a new entry should be added. For almost all applications &lt;loc&gt; can be set to -1 and &lt;set&gt; to 0. &#13;&#10;This adds a new entry to the end of &lt;name&gt; as a single valued RelativeDistinguishedName (RDN).&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_NAME_add_entry_by_txt.html" Name="X509_NAME_add_entry_by_txt"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_NAME_add_entry_by_txt
		VAR_INPUT
			name 	: ^void;			//! <Variable Comment="Pointer to X509_NAME structure." Name="X509_NAME_add_entry_by_txt.name"/>
			field 	: ^void;			//! <Variable Comment="The field string represents the field name using OBJ_txt2obj(&lt;field&gt;, 0)." Name="X509_NAME_add_entry_by_txt.field"/>
			typ 	: DINT;			//! <Variable Comment="Field type.&#13;&#10;The use of string types such as MBSTRING_ASC or MBSTRING_UTF8 is strongly recommended for the type parameter. &#13;&#10;This allows the internal code to correctly determine the type of the field and to apply length checks according to the relevant standards. &#13;&#10;This is done using ASN1_STRING_set_by_NID().&#13;&#10;&#13;&#10;If instead an ASN1 type is used no checks are performed and the supplied data in bytes is used directly." Name="X509_NAME_add_entry_by_txt.typ"/>
			bytes 	: ^void;			//! <Variable Comment="Pointer to the field value to be added." Name="X509_NAME_add_entry_by_txt.bytes"/>
			len 	: DINT;			//! <Variable Comment="Length of the field value to be added.&#13;&#10;If &lt;len&gt; is -1 then the field length is calculated internally using strlen(&lt;bytes&gt;)." Name="X509_NAME_add_entry_by_txt.len"/>
			loc 	: DINT;			//! <Variable Comment="&lt;loc&gt; actually determines the index where the new entry is inserted: if it is -1 it is appended." Name="X509_NAME_add_entry_by_txt.loc"/>
			set 	: DINT;			//! <Variable Comment="&lt;set&gt; determines how the new type is added. If it is zero a new RDN is created.&#13;&#10;&#13;&#10;If &lt;set&gt; is -1 or 1 it is added to the previous or next RDN structure respectively. &#13;&#10;This will then be a multivalued RDN: since multivalues RDNs are very seldom used &lt;set&gt; is almost always set to zero." Name="X509_NAME_add_entry_by_txt.set"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns 1 for success of 0 if an error occurred." Name="X509_NAME_add_entry_by_txt.RetVal"/>
		END_VAR;
				//! <Function Comment="X509_REVOKED_set_revocationDate() sets the revocation date of &lt;rx&gt; to &lt;tm&gt;. &#13;&#10;The supplied &lt;tm&gt; pointer is not used internally so it should be freed up after use.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_REVOKED_set_revocationDate.html" Name="X509_REVOKED_set_revocationDate"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_REVOKED_set_revocationDate
		VAR_INPUT
			rx 	: ^void;			//! <Variable Comment="Pointer to a X509_REVOKED structure." Name="X509_REVOKED_set_revocationDate.rx"/>
			tm 	: ^void;			//! <Variable Comment="Pointer to a ASN1_TIME structure holding the revocation date of &lt;rx&gt;.&#13;&#10;The supplied &lt;tm&gt; pointer is not used internally so it should be freed up after use." Name="X509_REVOKED_set_revocationDate.tm"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns 1 for success and 0 for failure." Name="X509_REVOKED_set_revocationDate.RetVal"/>
		END_VAR;
				//! <Function Comment="Sets the issuer name of the CRL &lt;x&gt; to &lt;name&gt;.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_CRL_set_issuer_name.html" Name="X509_CRL_set_issuer_name"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_CRL_set_issuer_name
		VAR_INPUT
			x 	: ^void;			//! <Variable Comment="Pointer to X509_CRL structure holding a certificate revocation list (CRL)." Name="X509_CRL_set_issuer_name.x"/>
			name 	: ^void;			//! <Variable Comment="Pointer to X509_NAME structure holding the name to be set." Name="X509_CRL_set_issuer_name.name"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns 1 for success and 0 for failure." Name="X509_CRL_set_issuer_name.RetVal"/>
		END_VAR;
				//! <Function Comment="X509_REVOKED_set_serialNumber() sets the serial number of &lt;x&gt; to &lt;serial&gt;. &#13;&#10;The supplied &lt;serial&gt; pointer is not used internally so it should be freed up after use.&#13;&#10;&#13;&#10;www.openssl.org/docs/man1.1.0/crypto/X509_REVOKED_set_serialNumber.html" Name="X509_REVOKED_set_serialNumber"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_REVOKED_set_serialNumber
		VAR_INPUT
			x 	: ^void;			//! <Variable Comment="Pointer to a X509_REVOKED structure." Name="X509_REVOKED_set_serialNumber.x"/>
			serial 	: ^void;			//! <Variable Comment="Pointer to a ASN1_INTEGER structure holding the serial number to be set." Name="X509_REVOKED_set_serialNumber.serial"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns 1 for success and 0 for failure." Name="X509_REVOKED_set_serialNumber.RetVal"/>
		END_VAR;
				//! <Function Comment="Releases the object and all pointers and sub-objects within it.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_NAME_ENTRY_free.html" Name="X509_NAME_ENTRY_free"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_NAME_ENTRY_free
		VAR_INPUT
			nex 	: ^void;			//! <Variable Comment="Pointer to a X509_NAME_ENTRY structure." Name="X509_NAME_ENTRY_free.nex"/>
		END_VAR;
				//! <Function Comment="Allocates an empty Certificate Revocation List (CRL). The CRL returned must be released by calling X509_CRL_free().&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_CRL_new.html" Name="X509_CRL_new"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_CRL_new
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Returns a X509_CRL pointer to the newly created CRL or NULL on failure." Name="X509_CRL_new.RetAddr"/>
		END_VAR;
				//! <Function Comment="Releases the object and all pointers and sub-objects within it.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_CRL_new.html" Name="X509_CRL_free"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_CRL_free
		VAR_INPUT
			crl 	: ^void;			//! <Variable Comment="Pointer to X509_CRL structure holding a certificate revocation list (CRL)." Name="X509_CRL_free.crl"/>
		END_VAR;
				//! <Function Comment="Releases the object and all pointers and sub-objects within it.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_CRL_new.html" Name="ASN1_TIME_free"/>
	FUNCTION __CDECL VIRTUAL GLOBAL ASN1_TIME_free
		VAR_INPUT
			mut 	: ^void;			//! <Variable Comment="Pointer to a ASN1_TIME structure." Name="ASN1_TIME_free.mut"/>
		END_VAR;
				//! <Function Comment="The ASN1_STRING object can represent a variety of ASN.1 built-in types. It can store a type and a value.&#13;&#10;&#13;&#10;The ASN1_INTEGER_new() function allocates and initializes an empty ASN1_STRING object.&#13;&#10;The object returned must be released by calling ASN1_INTEGER_free().&#13;&#10;&#13;&#10;See also https://users-cs.au.dk/sortie/sortix/release/nightly/man/man3/ASN1_INTEGER_new.3.html" Name="ASN1_INTEGER_new"/>
	FUNCTION __CDECL VIRTUAL GLOBAL ASN1_INTEGER_new
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Returns a ASN1_INTEGER pointer to the newly created object or NULL on failure." Name="ASN1_INTEGER_new.RetAddr"/>
		END_VAR;
				//! <Function Comment="Releases the object and all pointers and sub-objects within it.&#13;&#10;&#13;&#10;See also https://users-cs.au.dk/sortie/sortix/release/nightly/man/man3/ASN1_INTEGER_new.3.html" Name="ASN1_INTEGER_free"/>
	FUNCTION __CDECL VIRTUAL GLOBAL ASN1_INTEGER_free
		VAR_INPUT
			a 	: ^void;			//! <Variable Comment="Pointer to a ASN1_INTEGER object." Name="ASN1_INTEGER_free.a"/>
		END_VAR;
				//! <Function Comment="Allocates an empty object of the type X509_REVOKED. The object returned must be released by calling X509_REVOKED_free().&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_REVOKED_new.html" Name="X509_REVOKED_new"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_REVOKED_new
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Returns a X509_REVOKED pointer to the newly created object or NULL on failure." Name="X509_REVOKED_new.RetAddr"/>
		END_VAR;
				//! <Function Comment="Releases the object and all pointers and sub-objects within it.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_REVOKED_new.html" Name="X509_REVOKED_free"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_REVOKED_free
		VAR_INPUT
			rx 	: ^void;			//! <Variable Comment="Pointer to a X509_REVOKED object." Name="X509_REVOKED_free.rx"/>
		END_VAR;
				//! <Function Comment="Writes the CRL &lt;x&gt; into the BIO &lt;bpx&gt; in PEM format.&#13;&#10;&#13;&#10;The PEM functions read or write structures in PEM format. In this sense PEM format is simply base64 encoded data surrounded by header lines.&#13;&#10;The X509_CRL functions process an X509 CRL using an X509_CRL structure.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/PEM_write_bio_X509_CRL.html" Name="PEM_write_bio_X509_CRL"/>
	FUNCTION __CDECL VIRTUAL GLOBAL PEM_write_bio_X509_CRL
		VAR_INPUT
			bpx 	: ^void;			//! <Variable Comment="Pointer to a BIO structure specifying the BIO to write to." Name="PEM_write_bio_X509_CRL.bpx"/>
			x 	: ^void;			//! <Variable Comment="Pointer to X509_CRL structure holding a certificate revocation list (CRL)." Name="PEM_write_bio_X509_CRL.x"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns 1 for success or 0 for failure." Name="PEM_write_bio_X509_CRL.RetVal"/>
		END_VAR;
				//! <Function Comment="X509_cmp_time() compares the ASN1_TIME in &lt;sx&gt; with the time in &lt;tx&gt;. &#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.1/man3/X509_cmp_time.html" Name="X509_cmp_time"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_cmp_time
		VAR_INPUT
			sx 	: ^void;			//! <Variable Comment="Pointer to a ASN1_TIME structure.&#13;&#10;&lt;sx&gt; must satisfy the ASN1_TIME format mandated by RFC 5280, i.e., its format must be either YYMMDDHHMMSSZ or YYYYMMDDHHMMSSZ (it&apos;s a literal Z at the end, meaning &quot;Zulu&quot;).&#13;&#10;" Name="X509_cmp_time.sx"/>
			tx 	: ^void;			//! <Variable Comment="Pointer to a time_t structure holding the number of seconds since the start of the Unix epoch: midnight UTC of January 1, 1970 (not counting leap seconds)." Name="X509_cmp_time.tx"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns -1 if &lt;sx&gt; is earlier than, or equal to, &lt;tx&gt; and 1 otherwise. &#13;&#10;The method returns 0 on error." Name="X509_cmp_time.RetVal"/>
		END_VAR;
				//! <Function Comment="Returns the notBefore field of certificate &lt;x&gt;. The value returned is an internal pointer which must not be freed up after the call.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_CRL_set1_lastUpdate.html" Name="X509_get_notBefore"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_get_notBefore
		VAR_INPUT
			x 	: ^void;			//! <Variable Comment="Pointer to a X509 structure holding a certificate." Name="X509_get_notBefore.x"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Returns a pointer to an ASN1_TIME structure.&#13;&#10;Either YYMMDDHHMMSSZ or YYYYMMDDHHMMSSZ (it&apos;s a literal Z at the end, meaning &quot;Zulu&quot;)." Name="X509_get_notBefore.RetAddr"/>
		END_VAR;
				//! <Function Comment="Returns the notAfter field of certificate &lt;x&gt;. The value returned is an internal pointer which must not be freed up after the call.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.1.0/crypto/X509_CRL_set1_lastUpdate.html" Name="X509_get_notAfter"/>
	FUNCTION __CDECL VIRTUAL GLOBAL X509_get_notAfter
		VAR_INPUT
			x 	: ^void;			//! <Variable Comment="Pointer to a X509 structure holding a certificate." Name="X509_get_notAfter.x"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Returns a pointer to an ASN1_TIME structure.&#13;&#10;Either YYMMDDHHMMSSZ or YYYYMMDDHHMMSSZ (it&apos;s a literal Z at the end, meaning &quot;Zulu&quot;)." Name="X509_get_notAfter.RetAddr"/>
		END_VAR;
				//! <Function Comment="EVP_sha256(): the SHA-256 algorithm which produces a 160-bit output from a given input.&#13;&#10;SHA-256 (Secure Hash Algorithm 256) is a cryptographic hash function standardized in NIST FIPS 180-4.&#13;&#10;&#13;&#10;EVP_sha256() returns an EVP_MD structure for the SHA256 digest algorithm.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/EVP_sha256.html&#13;&#10;and       www.openssl.org/docs/man1.1.1/man3/EVP_sha256.html" Name="EVP_sha256"/>
	FUNCTION __CDECL VIRTUAL GLOBAL EVP_sha256
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Pointer to an EVP_MD structure that contains the implementation of the symmetric cipher." Name="EVP_sha256.RetAddr"/>
		END_VAR;
				//! <Function Comment="SHA-256 (Secure Hash Algorithm) is a cryptographic hash function with a 160 bit output.&#13;&#10;&#13;&#10;SHA256() computes the SHA-256 message digest of the &lt;n_val&gt; bytes at &lt;d_addr&gt; and places it in &lt;md&gt; (which must have space for SHA256_DIGEST_LENGTH).&#13;&#10;If &lt;md&gt; is NULL, the digest is placed in a static array. Note: setting &lt;md&gt; to NULL is not thread safe.&#13;&#10;&#13;&#10;See also www.openssl.org/docs/man1.0.2/crypto/SHA256.html" Name="SHA256"/>
	FUNCTION __CDECL VIRTUAL GLOBAL SHA256
		VAR_INPUT
			d_addr 	: ^USINT;			//! <Variable Comment="Pointer to input buffer." Name="SHA256.d_addr"/>
			n_val 	: DINT;			//! <Variable Comment="Length of the input buffer in bytes." Name="SHA256.n_val"/>
			md 	: ^USINT;			//! <Variable Comment="Pointer to the SHA-256 message digest buffer (&lt;md&gt; must have space for SHA256_DIGEST_LENGTH). &#13;&#10;If &lt;md&gt; is NULL, the digest is placed in a static array (WARNING: not thread-safe)." Name="SHA256.md"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^USINT;			//! <Variable Comment="Returns a pointer to the hash value." Name="SHA256.RetAddr"/>
		END_VAR;
				//! <Function Comment="Writes data from buffer to BIO b." Name="BIO_write"/>
	FUNCTION __CDECL VIRTUAL GLOBAL BIO_write
		VAR_INPUT
			b 	: ^void;			//! <Variable Comment="Pointer to BIO structure." Name="BIO_write.b"/>
			data 	: ^void;			//! <Variable Comment="Pointer to the data buffer." Name="BIO_write.data"/>
			len 	: DINT;			//! <Variable Comment="Number of bytes to write from data to BIO b." Name="BIO_write.len"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Returns -2 if the &quot;write&quot; operation is not implemented by the BIO or -1 on other errors. Otherwise it returns the number of bytes written. This may be 0 if the BIO b is NULL or dlen &lt;= 0." Name="BIO_write.RetVal"/>
		END_VAR;
				//! <Function Comment="Reads an RSA public key using an RSA structure." Name="PEM_read_bio_RSA_PUBKEY"/>
	FUNCTION __CDECL VIRTUAL GLOBAL PEM_read_bio_RSA_PUBKEY
		VAR_INPUT
			b 	: ^void;			//! <Variable Comment="Specifies the BIO to read from." Name="PEM_read_bio_RSA_PUBKEY.b"/>
			x 	: ^pVoid;			//! <Variable Comment="If x is NULL then the parameter is ignored. &#13;&#10;If x is not NULL but *x is NULL then the structure returned will be written to *x. &#13;&#10;If neither x nor *x is NULL then an attempt is made to reuse the structure at *x. &#13;&#10;Irrespective of the value of x a pointer to the structure is always returned (or NULL if an error occurred)." Name="PEM_read_bio_RSA_PUBKEY.x"/>
			cb 	: ^void;			//! <Variable Comment="The cb argument is the callback to use when querying for the pass phrase used for encrypted PEM structures." Name="PEM_read_bio_RSA_PUBKEY.cb"/>
			u 	: ^void;			//! <Variable Comment="If the cb parameters is set to NULL and the u parameter is not NULL then the u parameter is interpreted as a null terminated string to use as the passphrase. &#13;&#10;If both cb and u are NULL then the default callback routine is used." Name="PEM_read_bio_RSA_PUBKEY.u"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^void;			//! <Variable Comment="Returns a pointer to an RSA structure." Name="PEM_read_bio_RSA_PUBKEY.RetAddr"/>
		END_VAR;
				//! <Function Comment="Initializes a SHA512_CTX structure." Name="SHA512_Init"/>
	FUNCTION __CDECL VIRTUAL GLOBAL SHA512_Init
		VAR_INPUT
			c 	: ^void;			//! <Variable Comment="Pointer to the SHA512_CTX structure." Name="SHA512_Init.c"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Return 1 for success, 0 otherwise." Name="SHA512_Init.RetVal"/>
		END_VAR;
				//! <Function Comment="Can be called repeatedly with chunks of the message to be hashed (len bytes at data)." Name="SHA512_Update"/>
	FUNCTION __CDECL VIRTUAL GLOBAL SHA512_Update
		VAR_INPUT
			c 	: ^void;			//! <Variable Comment="Pointer to the SHA512_CTX structure." Name="SHA512_Update.c"/>
			data 	: ^void;			//! <Variable Comment="Pointer to the data buffer." Name="SHA512_Update.data"/>
			len 	: DINT;			//! <Variable Comment="Data buffer length." Name="SHA512_Update.len"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Return 1 for success, 0 otherwise." Name="SHA512_Update.RetVal"/>
		END_VAR;
				//! <Function Comment="Places the message digest in md, which must have space for SHA512_DIGEST_LENGTH == 64 bytes of output, and erases the SHA512_CTX." Name="SHA512_Final"/>
	FUNCTION __CDECL VIRTUAL GLOBAL SHA512_Final
		VAR_INPUT
			md 	: ^USINT;			//! <Variable Comment="Pointer to the SHA-512 message digest buffer (&lt;md&gt; must have space for SHA512_DIGEST_LENGTH). &#13;&#10;If &lt;md&gt; is NULL, the digest is placed in a static array (WARNING: not thread-safe)." Name="SHA512_Final.md"/>
			c 	: ^void;			//! <Variable Comment="Pointer to the SHA512_CTX structure." Name="SHA512_Final.c"/>
		END_VAR
		VAR_OUTPUT
			RetVal (EAX) 	: DINT;			//! <Variable Comment="Return 1 for success, 0 otherwise." Name="SHA512_Final.RetVal"/>
		END_VAR;
				//! <Function Comment="SHA-512 (Secure Hash Algorithm) is a cryptographic hash function.&#13;&#10;&#13;&#10;SHA512() computes the SHA-512 message digest of the &lt;n_val&gt; bytes at &lt;d_addr&gt; and places it in &lt;md&gt; (which must have space for SHA512_DIGEST_LENGTH).&#13;&#10;If &lt;md&gt; is NULL, the digest is placed in a static array. Note: setting &lt;md&gt; to NULL is not thread safe." Name="SHA512"/>
	FUNCTION __CDECL VIRTUAL GLOBAL SHA512
		VAR_INPUT
			d_addr 	: ^USINT;			//! <Variable Comment="Pointer to input buffer." Name="SHA512.d_addr"/>
			n_val 	: DINT;			//! <Variable Comment="Length of the input buffer in bytes." Name="SHA512.n_val"/>
			md 	: ^USINT;			//! <Variable Comment="Pointer to the SHA-512 message digest buffer (&lt;md&gt; must have space for SHA512_DIGEST_LENGTH). &#13;&#10;If &lt;md&gt; is NULL, the digest is placed in a static array (WARNING: not thread-safe)." Name="SHA512.md"/>
		END_VAR
		VAR_OUTPUT
			RetAddr (EAX) 	: ^USINT;			//! <Variable Comment="Returns a pointer to the hash value." Name="SHA512.RetAddr"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _OpenSSL::@CT_
0$UINT,
2#0100000000001000$UINT, //TY__OPENSSL
1$UINT, 9$UINT, (SIZEOF(::_OpenSSL))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(1010260118), "_OpenSSL", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_OpenSSL.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
//Clients:
END_FUNCTION


#define USER_CNT__OpenSSL 141

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__OpenSSL] OF ^Void;
	END_STRUCT;
END_TYPE



//{{LSL_IMPLEMENTATION
#include <Rtos_interfaces.h> // we need this for the SysCIL functions
#include "..\..\Source\code\OsiBaseNew.h"

// This variable has to be global to allow for calls to OpenSSL CIL API
// functions from C code without the C programmer needing to call OS_CILGet
// explicitly. In such a case the CIL API functions are called via C macros
// defined in lsl_c_openssl.h.
VAR_GLOBAL
  lsl_openssl   : ^_OpenSSL::LSL_OPENSSL; //Used for compatibility of previous versions
  _lsl_openssl  : ^_OpenSSL::LSL_OPENSSL; //Used for function calls in c
END_VAR

VAR_PRIVATE
   API_Version:UDINT;
END_VAR

FUNCTION VIRTUAL GLOBAL _OpenSSL::GetVersion
	VAR_OUTPUT
		ret0 	: UDINT;
	END_VAR
   ret0 := API_Version;
END_FUNCTION

// Disable 'Parameter '...' is never used' warnings
#pragma warning (disable:73)
// Dummy functions

FUNCTION __CDECL _OpenSSL_DummyInt
VAR_OUTPUT
  dRC      : DINT;
END_VAR
  dRC := OpenSSL_ERR_NO_INTERFACE;
END_FUNCTION

FUNCTION __CDECL _OpenSSL_DummyPtr
VAR_OUTPUT
  pOutput  : pVoid;
END_VAR
  pOutput := nil;
END_FUNCTION

FUNCTION __CDECL _OpenSSL_DummyVoid

END_FUNCTION

#pragma warning (default:73)
// End of Dummy functions

FUNCTION _OpenSSL::_OpenSSL
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

VAR
	aMeths			: ARRAY[0..USER_CNT__OpenSSL] OF ^void; 
	retv    		: SYS_ERROR;
END_VAR

	retv := OS_CILGet(INTERFACE_OPENSSL, #lsl_openssl); 
	_lsl_openssl := lsl_openssl;

	if retv <> SYS_ERR_NONE then

	  TRACE("ERROR: OPENSSL interface not available with this version/platform");

    API_Version := 0;

    aMeths[0]  := #GetVersion();
    aMeths[1]  := #_OpenSSL_DummyPtr();
		aMeths[2]  := #_OpenSSL_DummyPtr();
		aMeths[3]  := #_OpenSSL_DummyInt();
		aMeths[4]  := #_OpenSSL_DummyPtr();
		aMeths[5]  := #_OpenSSL_DummyPtr();
		aMeths[6]  := #_OpenSSL_DummyInt();
		aMeths[7]  := #_OpenSSL_DummyVoid();
		aMeths[8]  := #_OpenSSL_DummyVoid();
 	  aMeths[9]  := #_OpenSSL_DummyPtr();
    aMeths[10] := #_OpenSSL_DummyVoid();
    aMeths[11] := #_OpenSSL_DummyVoid();
    aMeths[12] := #_OpenSSL_DummyInt();
		aMeths[13] := #_OpenSSL_DummyVoid();
		aMeths[14] := #_OpenSSL_DummyVoid();
		aMeths[15] := #_OpenSSL_DummyVoid();
		aMeths[16] := #_OpenSSL_DummyVoid();
    aMeths[17] := #_OpenSSL_DummyInt();
		aMeths[18] := #_OpenSSL_DummyInt();
		aMeths[19] := #_OpenSSL_DummyVoid();
    aMeths[20] := #_OpenSSL_DummyPtr();
	  aMeths[21] := #_OpenSSL_DummyPtr();
		aMeths[22] := #_OpenSSL_DummyVoid();
		aMeths[23] := #_OpenSSL_DummyInt();
		aMeths[24] := #_OpenSSL_DummyPtr();
		aMeths[25] := #_OpenSSL_DummyInt();
		aMeths[26] := #_OpenSSL_DummyPtr();
		aMeths[27] := #_OpenSSL_DummyInt();
		aMeths[28] := #_OpenSSL_DummyInt();
		aMeths[29] := #_OpenSSL_DummyPtr();
		aMeths[30] := #_OpenSSL_DummyPtr();
		aMeths[31] := #_OpenSSL_DummyPtr();
		aMeths[32] := #_OpenSSL_DummyVoid();
		aMeths[33] := #_OpenSSL_DummyPtr();
		aMeths[34] := #_OpenSSL_DummyPtr();
		aMeths[35] := #_OpenSSL_DummyPtr();
		aMeths[36] := #_OpenSSL_DummyInt();
		aMeths[37] := #_OpenSSL_DummyVoid();
		aMeths[38] := #_OpenSSL_DummyPtr();
		aMeths[39] := #_OpenSSL_DummyVoid();
		aMeths[40] := #_OpenSSL_DummyInt();
		aMeths[41] := #_OpenSSL_DummyInt();
		aMeths[42] := #_OpenSSL_DummyInt();
		aMeths[43] := #_OpenSSL_DummyInt();
		aMeths[44] := #_OpenSSL_DummyInt();
		aMeths[45] := #_OpenSSL_DummyInt();
		aMeths[46] := #_OpenSSL_DummyInt();
		aMeths[47] := #_OpenSSL_DummyPtr();
		aMeths[48] := #_OpenSSL_DummyInt();
		aMeths[49] := #_OpenSSL_DummyInt();
		aMeths[50] := #_OpenSSL_DummyPtr();
		aMeths[51] := #_OpenSSL_DummyInt();
		aMeths[52] := #_OpenSSL_DummyPtr();
		aMeths[53] := #_OpenSSL_DummyInt();
		aMeths[54] := #_OpenSSL_DummyVoid();
		aMeths[55] := #_OpenSSL_DummyPtr();
		aMeths[56] := #_OpenSSL_DummyInt();
		aMeths[57] := #_OpenSSL_DummyPtr();
		aMeths[58] := #_OpenSSL_DummyPtr();
		aMeths[59] := #_OpenSSL_DummyInt();
		aMeths[60] := #_OpenSSL_DummyInt();
		aMeths[61] := #_OpenSSL_DummyPtr();
		aMeths[62] := #_OpenSSL_DummyInt();
		aMeths[63] := #_OpenSSL_DummyInt();
		aMeths[64] := #_OpenSSL_DummyPtr();
		aMeths[65] := #_OpenSSL_DummyVoid();
		aMeths[66] := #_OpenSSL_DummyInt();
		aMeths[67] := #_OpenSSL_DummyVoid();
		aMeths[68] := #_OpenSSL_DummyInt();
		aMeths[69] := #_OpenSSL_DummyPtr();
		aMeths[70] := #_OpenSSL_DummyPtr();
		aMeths[71] := #_OpenSSL_DummyPtr();
		aMeths[72] := #_OpenSSL_DummyInt();
    aMeths[73] := #_OpenSSL_DummyPtr();
    aMeths[74] := #_OpenSSL_DummyInt();
    aMeths[75] := #_OpenSSL_DummyInt();
    aMeths[76] := #_OpenSSL_DummyPtr();
    aMeths[77] := #_OpenSSL_DummyInt();
    aMeths[78] := #_OpenSSL_DummyPtr();
    aMeths[79] := #_OpenSSL_DummyInt();
    aMeths[80] := #_OpenSSL_DummyInt();
    aMeths[81] := #_OpenSSL_DummyPtr();
    aMeths[82] := #_OpenSSL_DummyInt();
    aMeths[83] := #_OpenSSL_DummyPtr();
    aMeths[84] := #_OpenSSL_DummyVoid();
    aMeths[85] := #_OpenSSL_DummyInt();
    aMeths[86] := #_OpenSSL_DummyPtr();
    aMeths[87] := #_OpenSSL_DummyInt();
    aMeths[88] := #_OpenSSL_DummyInt();
    aMeths[89] := #_OpenSSL_DummyPtr();
    aMeths[90] := #_OpenSSL_DummyInt();
    aMeths[91] := #_OpenSSL_DummyPtr();
    aMeths[92] := #_OpenSSL_DummyInt();
    aMeths[93] := #_OpenSSL_DummyInt();
    aMeths[94] := #_OpenSSL_DummyPtr();
    aMeths[95] := #_OpenSSL_DummyInt();
    aMeths[96] := #_OpenSSL_DummyPtr();
    aMeths[97] := #_OpenSSL_DummyInt();
    aMeths[98] := #_OpenSSL_DummyInt();
    aMeths[99] := #_OpenSSL_DummyPtr();
    aMeths[100] := #_OpenSSL_DummyInt();
    aMeths[101] := #_OpenSSL_DummyPtr();
    aMeths[102] := #_OpenSSL_DummyPtr();
    aMeths[103] := #_OpenSSL_DummyInt();
    aMeths[104] := #_OpenSSL_DummyInt();
    aMeths[105] := #_OpenSSL_DummyPtr();
    aMeths[106] := #_OpenSSL_DummyPtr();
    aMeths[107] := #_OpenSSL_DummyInt();
    aMeths[108] := #_OpenSSL_DummyPtr();
    aMeths[109] := #_OpenSSL_DummyInt();
    aMeths[110] := #_OpenSSL_DummyInt();
    aMeths[111] := #_OpenSSL_DummyInt();
    aMeths[112] := #_OpenSSL_DummyInt();
    aMeths[113] := #_OpenSSL_DummyInt();
    aMeths[114] := #_OpenSSL_DummyInt();
    aMeths[115] := #_OpenSSL_DummyInt();
    aMeths[116] := #_OpenSSL_DummyInt();
    aMeths[117] := #_OpenSSL_DummyInt();
    aMeths[118] := #_OpenSSL_DummyInt();
    aMeths[119] := #_OpenSSL_DummyInt();
    aMeths[120] := #_OpenSSL_DummyInt();
    aMeths[121] := #_OpenSSL_DummyVoid();
    aMeths[122] := #_OpenSSL_DummyPtr();
    aMeths[123] := #_OpenSSL_DummyVoid();
    aMeths[124] := #_OpenSSL_DummyVoid();
    aMeths[125] := #_OpenSSL_DummyPtr();
    aMeths[126] := #_OpenSSL_DummyVoid();
    aMeths[127] := #_OpenSSL_DummyPtr();
    aMeths[128] := #_OpenSSL_DummyVoid();
    aMeths[129] := #_OpenSSL_DummyInt();
    aMeths[130] := #_OpenSSL_DummyInt();
    aMeths[131] := #_OpenSSL_DummyPtr();
    aMeths[132] := #_OpenSSL_DummyPtr();
    aMeths[133] := #_OpenSSL_DummyPtr();
    aMeths[134] := #_OpenSSL_DummyPtr();

  else
    API_Version := lsl_openssl^.udVersion;

    aMeths[0]  := #GetVersion();
    aMeths[1]  := lsl_openssl^.d2i_X509;
		aMeths[2]  := lsl_openssl^.X509_get_subject_name;
		aMeths[3]  := lsl_openssl^.X509_NAME_get_index_by_NID;
		aMeths[4]  := lsl_openssl^.X509_NAME_get_entry;
		aMeths[5]  := lsl_openssl^.X509_NAME_ENTRY_get_data;
		aMeths[6]  := lsl_openssl^.ASN1_STRING_to_UTF8;
		aMeths[7]  := lsl_openssl^.OPENSSL_free;
		aMeths[8]  := lsl_openssl^.X509_free;
		aMeths[9]  := lsl_openssl^.SSLeay_version;    
		aMeths[10] := lsl_openssl^.OpenSSL_add_all_algorithms;
		aMeths[11] := lsl_openssl^.ERR_load_crypto_strings;
		aMeths[12] := lsl_openssl^.X509_STORE_CTX_get_ex_new_index;
		aMeths[13] := lsl_openssl^.EVP_cleanup;
		aMeths[14] := lsl_openssl^.CRYPTO_cleanup_all_ex_data;
		aMeths[15] := lsl_openssl^.ERR_remove_state;
		aMeths[16] := lsl_openssl^.ERR_free_strings;
		aMeths[17] := lsl_openssl^.AES_set_encrypt_key;
		aMeths[18] := lsl_openssl^.AES_set_decrypt_key;
		aMeths[19] := lsl_openssl^.AES_cbc_encrypt;
		
		aMeths[20] := lsl_openssl^.EVP_sha1;
		aMeths[21] := lsl_openssl^.HMAC;
		aMeths[22] := lsl_openssl^.X509_STORE_free;
		aMeths[23] := lsl_openssl^.X509_STORE_add_cert;
		aMeths[24] := lsl_openssl^.SHA1;
		
		aMeths[25] := lsl_openssl^.RAND_bytes;
		
		aMeths[26] := lsl_openssl^.RSA_generate_key;
		aMeths[27] := lsl_openssl^.i2d_RSAPublicKey;
		aMeths[28] := lsl_openssl^.i2d_RSAPrivateKey;
		aMeths[29] := lsl_openssl^.d2i_RSAPrivateKey;
		aMeths[30] := lsl_openssl^.d2i_PublicKey;
		aMeths[31] := lsl_openssl^.d2i_PrivateKey;
		aMeths[32] := lsl_openssl^.RSA_free;
		aMeths[33] := lsl_openssl^.BIO_new_file;
		aMeths[34] := lsl_openssl^.PEM_read_bio_PrivateKey;
		aMeths[35] := lsl_openssl^.d2i_PKCS12_bio;
		aMeths[36] := lsl_openssl^.PKCS12_parse;
		aMeths[37] := lsl_openssl^.PKCS12_free;
		aMeths[38] := lsl_openssl^.EVP_PKEY_get1_RSA;
		aMeths[39] := lsl_openssl^.EVP_PKEY_free;
		aMeths[40] := lsl_openssl^.BIO_free;
		aMeths[41] := lsl_openssl^.PEM_write_bio_RSAPrivateKey;
		aMeths[42] := lsl_openssl^.RSA_size;
		aMeths[43] := lsl_openssl^.RSA_public_encrypt;
		aMeths[44] := lsl_openssl^.RSA_private_decrypt;
		aMeths[45] := lsl_openssl^.RSA_sign;
		aMeths[46] := lsl_openssl^.ERR_get_error;
		aMeths[47] := lsl_openssl^.ERR_error_string;
		aMeths[48] := lsl_openssl^.RSA_verify;
		
		aMeths[49] := lsl_openssl^.OBJ_txt2nid;
		aMeths[50] := lsl_openssl^.X509_NAME_ENTRY_create_by_NID;
		aMeths[51] := lsl_openssl^.X509_NAME_add_entry;
		aMeths[52] := lsl_openssl^.X509V3_EXT_conf;
		aMeths[53] := lsl_openssl^.X509_add_ext;
		aMeths[54] := lsl_openssl^.X509_EXTENSION_free;
		aMeths[55] := lsl_openssl^.X509_new;
		aMeths[56] := lsl_openssl^.X509_set_version;
		aMeths[57] := lsl_openssl^.X509_get_serialNumber;
		aMeths[58] := lsl_openssl^.OPENSSL_Realloc;
		aMeths[59] := lsl_openssl^.ASN1_INTEGER_set;
		aMeths[60] := lsl_openssl^.X509_set_pubkey;
		aMeths[61] := lsl_openssl^.X509_NAME_new;
		aMeths[62] := lsl_openssl^.X509_set_subject_name;
		aMeths[63] := lsl_openssl^.X509_set_issuer_name;
		aMeths[64] := lsl_openssl^.X509_gmtime_adj;
		aMeths[65] := lsl_openssl^.X509V3_set_ctx;
		aMeths[66] := lsl_openssl^.X509_sign;
		aMeths[67] := lsl_openssl^.X509_NAME_free;
		aMeths[68] := lsl_openssl^.i2d_X509_bio;
		aMeths[69] := lsl_openssl^.d2i_X509_bio;
		aMeths[70] := lsl_openssl^.PEM_read_bio_X509;
		aMeths[71] := lsl_openssl^.X509_get_pubkey;
		aMeths[72] := lsl_openssl^.OBJ_obj2nid;

    if API_Version >= 2 then
    
      aMeths[73] := lsl_openssl^.BIO_new;
      aMeths[74] := lsl_openssl^.i2d_X509;
      aMeths[75] := lsl_openssl^.X509_verify;
      aMeths[76] := lsl_openssl^.X509_STORE_new;
      aMeths[77] := lsl_openssl^.CRYPTO_add_lock;
      aMeths[78] := lsl_openssl^.X509_LOOKUP_file;
      aMeths[79] := lsl_openssl^.X509_LOOKUP_ctrl;
      aMeths[80] := lsl_openssl^.X509_verify_cert;
      aMeths[81] := lsl_openssl^.X509_NAME_oneline;
      aMeths[82] := lsl_openssl^.X509_load_crl_file;
      aMeths[83] := lsl_openssl^.X509_STORE_CTX_new;
      aMeths[84] := lsl_openssl^.X509_STORE_CTX_free;
      aMeths[85] := lsl_openssl^.X509_STORE_CTX_init;
      aMeths[86] := lsl_openssl^.X509_get_issuer_name;
      aMeths[87] := lsl_openssl^.X509_LOOKUP_hash_dir;
      aMeths[88] := lsl_openssl^.X509_STORE_set_flags;
      aMeths[89] := lsl_openssl^.X509_STORE_add_lookup;
      aMeths[90]:= lsl_openssl^.X509_STORE_set_default_paths;
      aMeths[91] := lsl_openssl^.X509_STORE_CTX_get_ex_data;
      aMeths[92]:= lsl_openssl^.X509_STORE_CTX_set_ex_data;
      aMeths[93] := lsl_openssl^.X509_STORE_CTX_get_error;
      aMeths[94] := lsl_openssl^.X509_STORE_CTX_get_current_cert;
      aMeths[95] := lsl_openssl^.X509_STORE_CTX_get_error_depth;
      aMeths[96] := lsl_openssl^.X509_verify_cert_error_string;
      aMeths[97] := lsl_openssl^.i2d_PublicKey;
      aMeths[98] := lsl_openssl^.EVP_PKEY_type;
      aMeths[99] := lsl_openssl^.CRYPTO_realloc;
      aMeths[100] := lsl_openssl^.BIO_ctrl;
      aMeths[101] := lsl_openssl^.BIO_s_mem;
      aMeths[102] := lsl_openssl^.BIO_s_file;
      aMeths[103] := lsl_openssl^.X509_get_ext;
      aMeths[104] := lsl_openssl^.EVP_PKEY_cmp;
      aMeths[105] := lsl_openssl^.EVP_PKEY_new;
      aMeths[106] := lsl_openssl^.ASN1_TIME_set;
      aMeths[107] := lsl_openssl^.X509_CRL_sign;
      aMeths[108] := lsl_openssl^.X509_PUBKEY_get;
      aMeths[109] := lsl_openssl^.EVP_PKEY_assign;
      aMeths[110] := lsl_openssl^.X509V3_EXT_print;
      aMeths[111] := lsl_openssl^.X509_get_ext_by_NID;
      aMeths[112] := lsl_openssl^.X509_CRL_set_version;
      aMeths[113] := lsl_openssl^.X509_CRL_add0_revoked;
      aMeths[114] := lsl_openssl^.X509_CRL_add1_ext_i2d;
      aMeths[115] := lsl_openssl^.X509_CRL_set_lastUpdate;
      aMeths[116] := lsl_openssl^.X509_CRL_set_nextUpdate;
      aMeths[117] := lsl_openssl^.X509_NAME_add_entry_by_txt;
      aMeths[118] := lsl_openssl^.X509_REVOKED_set_revocationDate;
      aMeths[119] := lsl_openssl^.X509_CRL_set_issuer_name;
      aMeths[120] := lsl_openssl^.X509_REVOKED_set_serialNumber;
      aMeths[121] := lsl_openssl^.X509_NAME_ENTRY_free;
      aMeths[122] := lsl_openssl^.X509_CRL_new;
      aMeths[123] := lsl_openssl^.X509_CRL_free;
      aMeths[124] := lsl_openssl^.ASN1_TIME_free;
      aMeths[125] := lsl_openssl^.ASN1_INTEGER_new;
      aMeths[126] := lsl_openssl^.ASN1_INTEGER_free;
      aMeths[127] := lsl_openssl^.X509_REVOKED_new;
      aMeths[128] := lsl_openssl^.X509_REVOKED_free;
      aMeths[129] := lsl_openssl^.PEM_write_bio_X509_CRL;
      aMeths[130] := lsl_openssl^.X509_cmp_time;
    
    else
    
      aMeths[73] := #_OpenSSL_DummyPtr();
      aMeths[74] := #_OpenSSL_DummyInt();
      aMeths[75] := #_OpenSSL_DummyInt();
      aMeths[76] := #_OpenSSL_DummyPtr();
      aMeths[77] := #_OpenSSL_DummyInt();
      aMeths[78] := #_OpenSSL_DummyPtr();
      aMeths[79] := #_OpenSSL_DummyInt();
      aMeths[80] := #_OpenSSL_DummyInt();
      aMeths[81] := #_OpenSSL_DummyPtr();
      aMeths[82] := #_OpenSSL_DummyInt();
      aMeths[83] := #_OpenSSL_DummyPtr();
      aMeths[84] := #_OpenSSL_DummyVoid();
      aMeths[85] := #_OpenSSL_DummyInt();
      aMeths[86] := #_OpenSSL_DummyPtr();
      aMeths[87] := #_OpenSSL_DummyInt(); 
      aMeths[88] := #_OpenSSL_DummyInt();
      aMeths[89] := #_OpenSSL_DummyPtr();
      aMeths[90] := #_OpenSSL_DummyInt();
      aMeths[91] := #_OpenSSL_DummyPtr();
      aMeths[92] := #_OpenSSL_DummyInt();
      aMeths[93] := #_OpenSSL_DummyInt();
      aMeths[94] := #_OpenSSL_DummyPtr();
      aMeths[95] := #_OpenSSL_DummyInt();
      aMeths[96] := #_OpenSSL_DummyPtr();
      aMeths[97] := #_OpenSSL_DummyInt();
      aMeths[98] := #_OpenSSL_DummyInt();
      aMeths[99] := #_OpenSSL_DummyPtr();
      aMeths[100] := #_OpenSSL_DummyInt();
      aMeths[101] := #_OpenSSL_DummyPtr();
      aMeths[102] := #_OpenSSL_DummyPtr();
      aMeths[103] := #_OpenSSL_DummyInt();
      aMeths[104] := #_OpenSSL_DummyInt();
      aMeths[105] := #_OpenSSL_DummyPtr();
      aMeths[106] := #_OpenSSL_DummyPtr();
      aMeths[107] := #_OpenSSL_DummyInt();
      aMeths[108] := #_OpenSSL_DummyPtr();
      aMeths[109] := #_OpenSSL_DummyInt();
      aMeths[110] := #_OpenSSL_DummyInt();
      aMeths[111] := #_OpenSSL_DummyInt();
      aMeths[112] := #_OpenSSL_DummyInt();
      aMeths[113] := #_OpenSSL_DummyInt();
      aMeths[114] := #_OpenSSL_DummyInt();
      aMeths[115] := #_OpenSSL_DummyInt();
      aMeths[116] := #_OpenSSL_DummyInt();
      aMeths[117] := #_OpenSSL_DummyInt();
      aMeths[118] := #_OpenSSL_DummyInt();
      aMeths[119] := #_OpenSSL_DummyInt();
      aMeths[120] := #_OpenSSL_DummyInt();
      aMeths[121] := #_OpenSSL_DummyVoid();
      aMeths[122] := #_OpenSSL_DummyPtr();
      aMeths[123] := #_OpenSSL_DummyVoid();
      aMeths[124] := #_OpenSSL_DummyVoid();
      aMeths[125] := #_OpenSSL_DummyPtr();
      aMeths[126] := #_OpenSSL_DummyVoid();
      aMeths[127] := #_OpenSSL_DummyPtr();
      aMeths[128] := #_OpenSSL_DummyVoid();
      aMeths[129] := #_OpenSSL_DummyInt();
      aMeths[130] := #_OpenSSL_DummyInt();
        
    end_if;
    
    if API_Version >= 3 then
    
      aMeths[131] := lsl_openssl^.X509_get_notBefore;
      aMeths[132] := lsl_openssl^.X509_get_notAfter;
    
    else
    
      aMeths[131] := #_OpenSSL_DummyPtr();
      aMeths[132] := #_OpenSSL_DummyPtr();
    
    end_if;
    
    if API_Version >= 4 then
    
      aMeths[133] := lsl_openssl^.EVP_sha256;
      aMeths[134] := lsl_openssl^.SHA256;
    
    else
    
      aMeths[133] := #_OpenSSL_DummyPtr();
      aMeths[134] := #_OpenSSL_DummyPtr();
    
    end_if;
    
    if API_Version >= 5 then
    
      aMeths[135] := lsl_openssl^.BIO_write;
      aMeths[136] := lsl_openssl^.PEM_read_bio_RSA_PUBKEY;
      aMeths[137] := lsl_openssl^.SHA512_Init;
      aMeths[138] := lsl_openssl^.SHA512_Update;
      aMeths[139] := lsl_openssl^.SHA512_Final;
      aMeths[140] := lsl_openssl^.SHA512;
    
    else
    
      aMeths[135] := #_OpenSSL_DummyInt();
      aMeths[136] := #_OpenSSL_DummyPtr();
      aMeths[137] := #_OpenSSL_DummyInt();
      aMeths[138] := #_OpenSSL_DummyInt();
      aMeths[139] := #_OpenSSL_DummyInt();
      aMeths[140] := #_OpenSSL_DummyPtr();
    
    end_if;
    
     
	end_if;

  // Hier das Array mit weiteren Zeigern auf API-Funktionen initialisieren ...
  ret_code  := InitOsiM_new(#aMeths[0]$void, USER_CNT__OpenSSL);

END_FUNCTION
