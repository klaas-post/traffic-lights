//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include <.\lsl_st_mt.h>
#include "..\..\Class\_AlarmXBuffer\AlarmXBuffer.h"

(*!
<Class
	Name               = "_AlarmXBuffer"
	Revision           = "0.30"
	GUID               = "{526E2C4B-797D-4675-91FA-3685FAA594F8}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(402,120)"
	Comment            = "Communication buffer for Alarm system.">
	<Channels>
		<Server Name="ClassSvr" GUID="{A6F2702D-9666-4DA3-89F9-96C9F19A69F9}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Is incremented whenever an Alarm is triggered, acknowledged or dissapears."/>
		<Server Name="QuitAll" GUID="{798EE51A-0E95-40E5-A0BA-8595E1583710}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Write method acknowledges all alarms."/>
		<Server Name="QuitAllEx" GUID="{7C5D5FB4-508C-4B1C-A43C-9B80F222444D}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="write method acknowledges all &#13;&#10;active alarms"/>
		<Server Name="QuitGroup" GUID="{DC4D016C-4A0F-46C6-8C23-DD26DB6395C6}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Write method can be used to acknowledge every alarm of a specified group"/>
		<Server Name="QuitGroupEx" GUID="{420A6780-6908-404C-B628-10DB0F85B9A7}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Write method can be used to acknowledge every active alarm of a specified group"/>
		<Client Name="No" Required="true" Internal="false" DefValue="128" Comment="number of cells used in internal buffer. if initvalue is set to 0 number of used cells will be done automatically."/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\lsl_st_mt.h" Include="true"/>
			<File Path=".\Class\_AlarmXBuffer\AlarmXBuffer.h" Include="true"/>
			<File Path=".\Class\_AlarmXBuffer\_AlarmXBuffer.pdf"/>
			<File Path=".\Class\_AlarmXBuffer\_AlarmXBuffer_en.pdf"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="sigmatek" Author="kolott"/>
		<Dokumentation Revision="0.30" Date="2023-07-28" Author="kolott" Company="sigmatek" Description="Userdata of arbitrary length (P04323) implemented"/>
		<Dokumentation Revision="0.21" Date="2020-08-12" Author="kolott" Company="sigmatek" Description="Functionality to get multi AlarmConfiguration added (NewInstCmd 11)&#13;&#10;Functionality to scan for alarms with given state added (NewInstCmd 206)&#13;&#10;Functionality to skip oldest unused handle implemented"/>
		<Dokumentation Revision="0.20" Date="2018-11-06" Author="kolott" Company="sigmatek" Description="Functionality to get single Alarmconfiguration added"/>
		<Dokumentation Revision="0.19" Date="2018-02-01" Author="kolott" Company="sigmatek" Description="new virtual method ActionAlarmIntern() added"/>
		<Dokumentation Revision="0.18" Date="2016-03-30" Author="kolott" Company="sigmatek" Description="sa33814: correction of deeds done in version 0.15. (failure in calculation of internal buffersize)&#13;&#10;sa32974: simplify use of semaphore and new functionality of QuitEx."/>
		<Dokumentation Revision="0.17" Date="2016-02-15" Author="schmar2" Company="sigmatek" Description="-) added server QuitAllActive so its possible to quit only active alarms&#13;&#10;-) added server QuitGroupActive so its possible to quit only active alarms of a group"/>
		<Dokumentation Revision="0.15" Date="2016-02-10" Author="HubChr" Company="sigmatek" Description="Buffer is now automatically reallocated before overflow."/>
		<Dokumentation Revision="0.14" Date="2015-10-15" Author="HubChr" Company="sigmatek" Description="Changes in headerfile for better compatibility with new OpMode Alarm Classes."/>
		<Dokumentation Revision="0.13" Date="2015-02-02" Author="obechr" Company="sigmatek" Description="sa30232: initialisation will be done in first (instead of last) Init() run"/>
		<Dokumentation Revision="0.12" Date="2013-10-30" Author="kolott" Company="sigmatek" Description="sa26144: instances of class _AlarmX0Para will work without instance of class _AlarmXBuffer"/>
		<Dokumentation Revision="0.11" Date="2013-03-19" Author="kolott" Company="sigmatek" Description="innovation: global pointer to object of class is in use"/>
		<Dokumentation Revision="0.10" Date="2012-10-09" Author="kolott" Company="sigmatek" Description="ask for unregistered alarms (command 6 and 7) will work"/>
		<Dokumentation Revision="0.9" Date="2011-06-07" Author="kolott" Company="sigmatek" Description="improve communication to win-kernel to ensure overflowflag in ringbuffer"/>
	</RevDoku>
</Class>
*)
_AlarmXBuffer : CLASS
	TYPE
#pragma pack(push, 1)
	  _AB_2ID : STRUCT
	    userid : UDINT;
	    lasalid : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _AB_ALARM_USERDATA : STRUCT
	    ptr : ^void;
	    byteallocated : UDINT;
	    bytesize : UDINT;
	    userid : UDINT;
	  END_STRUCT;
#pragma pack(pop)
	  _AB_ALARM : STRUCT
	    alano : UDINT;
	    group : UDINT;
	    lasalid : UDINT;
	    dateTime : UDINT;
	    para : ARRAY [0..MAX_ALARMPARA-1] OF DINT;
	    state : USINT;
	    parano : USINT;
	    userdata : _AB_ALARM_USERDATA;
	  END_STRUCT;
	  _AB_CONFIG : STRUCT
	    pThis : UDINT;
	    config : UDINT;
	    group : UDINT;
	    nopara : USINT;
	    para : ARRAY [0..MAX_ALARMPARA-1] OF UDINT;
	    configDone : BOOL;
	    multiconfig : UDINT;
	  END_STRUCT;
	  _AB_MEM_ALARM : STRUCT
	    no : UDINT;
	    size : UDINT;
	    ptr : ^_AB_ALARM;
	  END_STRUCT;
	  _AB_MEM_CONFIG : STRUCT
	    no : UDINT;
	    size : UDINT;
	    ptr : ^_AB_CONFIG;
	    is_multiconfig : BOOL;
	  END_STRUCT;
	  _HMI_MAP : STRUCT
	    no : UDINT;
	    id : UDINT;
	    tix : UDINT;
	  END_STRUCT;
	  xxx : ^_AlarmX0Para;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_UDINT;
	QuitAll 	: SvrCh_DINT;
	QuitAllEx 	: SvrCh_DINT;
	QuitGroup 	: SvrCh_DINT;
	QuitGroupEx 	: SvrCh_DINT;
  //Clients:
	No 	: CltCh_DINT;
  //Variables:
		Mutex 	: MT_SEMAHANDLE;
		mt_api 	: ^LSL_MT_TYPE;
		MemConfig 	: _AB_MEM_CONFIG;
		MemAlarm 	: _AB_MEM_ALARM;
		HmiMap : ARRAY [0..15] OF _HMI_MAP;

		HmiNo 	: UDINT;
  //Functions:
	
	FUNCTION _AlarmXBuffer
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION MakeDateTime
		VAR_OUTPUT
			datetime 	: UDINT;
		END_VAR;
	
	FUNCTION DoMutex
		VAR_INPUT
			state 	: BOOL;
		END_VAR;
	
	FUNCTION SeekHmi
		VAR_INPUT
			id 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: USINT;
		END_VAR;
	
	FUNCTION CreateTXBuffer
		VAR_INPUT
			tx 	: ^USINT;
			txsize 	: UDINT;
			pno 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION GetConfig
		VAR_INPUT
			pDst 	: ^USINT;
			pThis 	: UDINT;
			xcmd 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION VIRTUAL Quit_AlarmSingle
		VAR_INPUT
			alano 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL Quit_AlarmAll
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL Quit_AlarmAllEx
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL Quit_AlarmGroup
		VAR_INPUT
			group 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL Quit_AlarmGroupEx
		VAR_INPUT
			group 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL RegisterAlarmXPara
		VAR_INPUT
			pThis 	: ^void;
			config 	: UDINT;
			group 	: UDINT;
			no 	: UDINT;
			paras 	: ^UDINT;
			multiconfig 	: UDINT := 0;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ActionAlarm
		VAR_INPUT
			pThis 	: UDINT;
			config 	: UDINT;
			group 	: UDINT;
			state 	: DINT;
			parano 	: UDINT;
			ppara 	: ^DINT;
			userdata 	: ^void := nil;
			userdata_size 	: UDINT := 0;
			userdata_id 	: UDINT := 0;
		END_VAR;
	
	FUNCTION CreateTXBuffer202
		VAR_INPUT
			tx 	: ^USINT;
			txsize 	: UDINT;
			index 	: UDINT;
			anz 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION CreateTXBuffer203
		VAR_INPUT
			precsize 	: ^UINT;
			tx 	: ^USINT;
			txsize 	: UDINT;
			index 	: UDINT;
			anz 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION CreateUnregTXBuffer
		VAR_INPUT
			pres 	: ^USINT;
			startidx 	: UDINT;
			size 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION VIRTUAL GetVersion
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION CreateBuffer
		VAR_INPUT
			anz 	: UDINT;
		END_VAR;
	
	FUNCTION CreateBufferDefault;
	
	FUNCTION VIRTUAL GLOBAL ActionAlarmIntern
		VAR_INPUT
			pThis 	: UDINT;
			config 	: UDINT;
			group 	: UDINT;
			state 	: DINT;
			parano 	: UDINT;
			ppara 	: ^DINT;
			userdata 	: ^void := nil;
			userdata_size 	: UDINT := 0;
			userdata_id 	: UDINT := 0;
		END_VAR;
	
	FUNCTION CopyConfig
		VAR_INPUT
			pdst 	: ^UDINT;
			idx 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION GetMemConfig
		VAR_INPUT
			pdst 	: ^USINT;
			nox 	: UDINT;
			psrc 	: ^_AB_2ID;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION ScanAlarmState206
		VAR_INPUT
			pd 	: ^USINT;
			max_pd_size 	: UDINT;
			startidx 	: UDINT;
			state 	: DINT;
			buffstate 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION ScanAlarmState208
		VAR_INPUT
			pd 	: ^USINT;
			max_pd_size 	: UDINT;
			startidx 	: UDINT;
			state 	: DINT;
			buffstate 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION LookupBuffer
		VAR_INPUT
			lid 	: UDINT;
			state 	: DINT;
			pnopara 	: ^UDINT;
			pdatim 	: ^UDINT;
			ppara 	: ^DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION UnregisterHmi
		VAR_INPUT
			index 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION SeekHmiUnused
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL AddUserData
		VAR_INPUT
			pala 	: ^_AB_ALARM;
			userdata 	: ^void;
			userdata_size 	: UDINT;
			userdata_id 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION AlarmMemory
		VAR_INPUT
			pptr 	: ^pVoid;
			bytesize 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL SeekMultiConfigBase
		VAR_INPUT
			alano 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^_AlarmX0Para;
		END_VAR;
	
	FUNCTION ComputeIndexAnz
		VAR_INPUT
			panz 	: ^UDINT;
			pidx 	: ^UDINT;
			clsvr 	: UDINT;
		END_VAR
		VAR_OUTPUT
			overflow 	: BOOL;
		END_VAR;
	
	FUNCTION AddAlarmVersion5
		VAR_INPUT
			tx 	: ^USINT;
			pala 	: ^_AB_ALARM;
			recsize 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^USINT;
		END_VAR;
	
	FUNCTION SizeAlarmVersion5
		VAR_INPUT
			pala 	: ^_AB_ALARM;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION LookupBuffer208
		VAR_INPUT
			lid 	: UDINT;
			alano 	: UDINT;
			state 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^_AB_ALARM;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ClassSvr::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL QuitAll::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL QuitAllEx::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL QuitGroup::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL QuitGroupEx::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _AlarmXBuffer::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__ALARMXBUFFER
0$UINT, 30$UINT, (SIZEOF(::_AlarmXBuffer))$UINT, 
5$UINT, 1$UINT, 0$UINT, 
TO_UDINT(2835625764), "_AlarmXBuffer", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_AlarmXBuffer.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::_AlarmXBuffer.QuitAll.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(134212785), "QuitAll", 
(::_AlarmXBuffer.QuitAllEx.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4244981292), "QuitAllEx", 
(::_AlarmXBuffer.QuitGroup.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2229057306), "QuitGroup", 
(::_AlarmXBuffer.QuitGroupEx.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1280256081), "QuitGroupEx", 
//Clients:
(::_AlarmXBuffer.No.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3376426101), "No", 
END_FUNCTION


#define USER_CNT__AlarmXBuffer 11

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__AlarmXBuffer] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _AlarmXBuffer::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__AlarmXBuffer, pCmd := #vmt.CmdTable);
	vmt.CmdTable.NewInstr		:= #NewInst();
	vmt.CmdTable.Write		:= #M_WR_DIRECT();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Quit_AlarmSingle();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #Quit_AlarmAll();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #Quit_AlarmAllEx();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #Quit_AlarmGroup();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #Quit_AlarmGroupEx();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #RegisterAlarmXPara();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #ActionAlarm();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #GetVersion();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #ActionAlarmIntern();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #AddUserData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #SeekMultiConfigBase();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	QuitAll.pMeth			:= StoreMethod( #M_RD_DIRECT(), #QuitAll::Write() );
	IF QuitAll.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	QuitAllEx.pMeth			:= StoreMethod( #M_RD_DIRECT(), #QuitAllEx::Write() );
	IF QuitAllEx.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	QuitGroup.pMeth			:= StoreMethod( #M_RD_DIRECT(), #QuitGroup::Write() );
	IF QuitGroup.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	QuitGroupEx.pMeth			:= StoreMethod( #M_RD_DIRECT(), #QuitGroupEx::Write() );
	IF QuitGroupEx.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= _AlarmXBuffer();

END_FUNCTION

#pragma usingLtd _AlarmX0Para

//{{LSL_IMPLEMENTATION
#pragma using _AlarmX0Para

#include <Lsl_st_ifssr.h>

VAR_GLOBAL
  PV_AlarmBuffer : ^_AlarmXBuffer;
END_VAR

FUNCTION _AlarmXBuffer::_AlarmXBuffer
  VAR_OUTPUT
    ret_code 	: ConfStates;
  END_VAR

  PV_AlarmBuffer := NIL; 
  Mutex          := NIL;
  mt_api         := NIL;
  if(OS_CILGet("LSL_MULTITASK", #mt_api$void)) then
    mt_api := NIL; 
  end_if; 
  if(mt_api <> NIL) then
    Mutex := OS_MT_CreateSemaphore(MTSEMATYPE_MUTEX, 1, 0, "HMI_ALABUF");
  end_if;

  // init configdata
  MemConfig.is_multiconfig := false;
  MemConfig.no   := 0;   // no of entries
  MemConfig.size := 0;   // buffersize
  MemConfig.ptr  := NIL; // --> to buffer

  // init databuffer
  MemAlarm.no    := 0;   // no of entries
  MemAlarm.size  := 0;   // buffersize
  MemAlarm.ptr   := NIL; // --> to buffer
  
  // init hmi
  _memset(#HmiMap[0], 0, sizeof(HmiMap));
  
  // init no of hmi's
  HmiNo          := 0;
  
	ret_code := C_OK;

END_FUNCTION

FUNCTION _AlarmXBuffer::CreateBuffer
  VAR_INPUT
    anz : udint;
  END_VAR
  VAR
  	bytes : udint;
  END_VAR

  if(anz > 0) then
    bytes := anz * sizeof(_AB_ALARM);
    if(AlarmMemory(#MemAlarm.ptr, bytes) = true) then
      _memset(MemAlarm.ptr, 0, bytes); // set memory to 0
      MemAlarm.size := anz; // max no of entries
      MemAlarm.no   := 0;   // act no of entries 
      No            := to_dint(anz);
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION _AlarmXBuffer::CreateBufferDefault

  CreateBuffer(MemConfig.no * 2);
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL _AlarmXBuffer::Init

  PV_AlarmBuffer := this; // set global this
  
  if(MemAlarm.ptr = NIL) then
    CreateBuffer(to_udint(No.Read())); // ifnec. create buffer
  end_if;

END_FUNCTION

FUNCTION _AlarmXBuffer::AlarmMemory
	VAR_INPUT
		pptr 	: ^pvoid;
		bytesize 	: UDINT;
	END_VAR
  var_output
    retcode : bool;
  end_var
  VAR
  	ptr, ph : ^void;
  END_VAR
  
  retcode := true;
  ptr := pptr^;
  
  if(bytesize = 0) then
    if(ptr <> nil) then
      OS_SSR_Free(ptr);
      ptr := nil; 
    end_if;
  elsif(ptr = nil) then
    ptr := OS_SSR_Malloc(bytesize);
    if(ptr = nil) then
      retcode := false;
    end_if;
  else
    retcode := false;
    ph := OS_SSR_Realloc(ptr, bytesize);
    if(ph <> nil) then
      retcode := true;
      ptr := ph;
    end_if;
  end_if;

  pptr^ := ptr;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _AlarmXBuffer::RegisterAlarmXPara
	VAR_INPUT
		pThis 	: ^void;
		config 	: UDINT;
		group 	: UDINT;
		no 	: UDINT;
		paras 	: ^UDINT;
		multiconfig 	: UDINT;(* := 0 *)
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
  VAR
    ptr : ^_AB_CONFIG;
  END_VAR

  retcode := 0;

  if(MemConfig.no >= MemConfig.size) then
    if(AlarmMemory(#MemConfig.ptr, (MemConfig.no + 32) * sizeof(_AB_CONFIG)) = true) then
      _memset(MemConfig.ptr + MemConfig.size*sizeof(_AB_CONFIG), 0, 32*sizeof(_AB_CONFIG)); // init new memory
      MemConfig.size += 32;
    end_if;
  end_if;
  
  if(MemConfig.no < MemConfig.size) then
    if(config = 0) then
      config := 16#FFFE - MemConfig.no;
    end_if;
    retcode          := config;
    ptr              := MemConfig.ptr + (MemConfig.no * sizeof(_AB_CONFIG));
    ptr^.pThis       := pThis$UDINT;
    ptr^.config      := config;
    ptr^.group       := group;
    ptr^.multiconfig := multiconfig;
    ptr^.configDone  := false;

    if(no > MAX_ALARMPARA) then
      no := MAX_ALARMPARA;
    end_if;

    ptr^.nopara := to_usint(no);
    _memcpy(#ptr^.para[0], paras, no * sizeof(udint));
    MemConfig.no += 1;
    
    if(multiconfig <> 0) then
      MemConfig.is_multiconfig := true; // alarm with multiconfig is present
    end_if;  
    
  end_if;
  
END_FUNCTION

FUNCTION _AlarmXBuffer::MakeDateTime
  VAR_OUTPUT
    datetime 	: UDINT;
  END_VAR
  VAR
    xdate : SYSDATE;
    xtime : SYSTIME;
  END_VAR

  OS_SSR_GetSysDate(#xdate);
  OS_SSR_GetSysTime(#xtime);

  datetime := xtime.wSecond;
  datetime := datetime or (xtime.wMinute shl 6);
  datetime := datetime or (xtime.wHour shl 12);
  datetime := datetime or (xdate.wDay shl 17);
  datetime := datetime or (xdate.wMonth shl 22);
  datetime := datetime or ((xdate.wYear-2000) shl 26);

END_FUNCTION

FUNCTION _AlarmXBuffer::DoMutex
  VAR_INPUT
    state 	: BOOL;
  END_VAR

  if(Mutex <> NIL) then
    if(state = TRUE) then
      OS_MT_Wait(Mutex);
    else
      OS_MT_Signal(Mutex);
    end_if;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL _AlarmXBuffer::AddUserData
	VAR_INPUT
		pala 	: ^_AB_ALARM;
		userdata 	: ^void;
		userdata_size 	: UDINT;
		userdata_id 	: UDINT;
	END_VAR
  var_output
    retcode : bool;
  end_var

  retcode := true;
  pala^.userdata.bytesize := 0;
  pala^.userdata.userid := userdata_id;
  
  if(userdata_size > 0) then
    retcode := false;
    if(userdata_size >= pala^.userdata.byteallocated) then
      // alloc/realloc memory
      if(AlarmMemory(#pala^.userdata.ptr, userdata_size) = true) then
        pala^.userdata.byteallocated := userdata_size;
      end_if;
    end_if;
  
    if(userdata_size <= pala^.userdata.byteallocated) then
      // copy userdata
      _memcpy(pala^.userdata.ptr, userdata, userdata_size);
      pala^.userdata.bytesize := userdata_size;
      retcode := true;
    end_if;
  elsif(pala^.userdata.ptr <> NIL) then
    // free memory
    AlarmMemory(#pala^.userdata.ptr, 0);
    pala^.userdata.byteallocated := 0;
    retcode := true;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _AlarmXBuffer::ActionAlarmIntern
	VAR_INPUT
		pThis 	: UDINT;
		config 	: UDINT;
		group 	: UDINT;
		state 	: DINT;
		parano 	: UDINT;
		ppara 	: ^DINT;
		userdata 	: ^void;(* := nil *)
		userdata_size 	: UDINT;(* := 0 *)
		userdata_id 	: UDINT;(* := 0 *)
	END_VAR
  VAR
    index : UDINT;
    ptr   : ^_AB_ALARM;
    datim : UDINT;
  END_VAR

  datim := MakeDateTime();

  if(MemAlarm.ptr = NIL) then
    CreateBufferDefault(); // ifnec create buffer with defaultsize
  end_if;

  if(MemAlarm.size > 0) then
    index := ClassSvr mod MemAlarm.size;                 // make wpos
    ptr   := MemAlarm.ptr + (index * sizeof(_AB_ALARM)); // --> to dst
    
    // _memset(ptr, 0, sizeof(_AB_ALARM));                  // init

    ptr^.alano    := config;
    ptr^.group    := group;
    ptr^.lasalid  := pThis;
    ptr^.dateTime := datim;
    ptr^.parano   := to_usint(parano);
    
    if(state = -1) then
      ptr^.state := 255; // acknowledge
    else
      ptr^.state := state$USINT and 1;
    end_if;
    
    if(parano <> 0) then
      _memcpy(#ptr^.para[0], ppara, parano * sizeof(udint));
    end_if;
    
    AddUserData(ptr, userdata, userdata_size, userdata_id);
    
    ClassSvr      += 1;
    if(MemAlarm.no < MemAlarm.size) then
      MemAlarm.no += 1;
    end_if;
    
    // inc cout of previously missed alarms
    HmiMap[ 0].no += 1; 
    HmiMap[ 1].no += 1;
    HmiMap[ 2].no += 1;
    HmiMap[ 3].no += 1;
    HmiMap[ 4].no += 1; 
    HmiMap[ 5].no += 1;
    HmiMap[ 6].no += 1;
    HmiMap[ 7].no += 1;
    HmiMap[ 8].no += 1; 
    HmiMap[ 9].no += 1;
    HmiMap[10].no += 1;
    HmiMap[11].no += 1;
    HmiMap[12].no += 1; 
    HmiMap[13].no += 1;
    HmiMap[14].no += 1;
    HmiMap[15].no += 1;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _AlarmXBuffer::ActionAlarm
	VAR_INPUT
		pThis 	: UDINT;
		config 	: UDINT;
		group 	: UDINT;
		state 	: DINT;
		parano 	: UDINT;
		ppara 	: ^DINT;
		userdata 	: ^void;(* := nil *)
		userdata_size 	: UDINT;(* := 0 *)
		userdata_id 	: UDINT;(* := 0 *)
	END_VAR

  DoMutex(TRUE);

  ActionAlarmIntern(pThis, config, group, state, parano, ppara, userdata, userdata_size, userdata_id);

  DoMutex(FALSE);

END_FUNCTION

FUNCTION _AlarmXBuffer::SeekHmiUnused
  VAR_OUTPUT
    retcode 	: UDINT;
  END_VAR
  VAR
  	diff, act, i, tmp : udint;
  END_VAR

  retcode := 16#FFFFFFFF;
  diff    := 0;
  act     := ops.tAbsolute;

  for i:=0 to ((sizeof(HmiMap)/sizeof(HmiMap[0]))-1) do
    tmp := act - HmiMap[i].tix;
    if(tmp > 10000) then // mehr als 10 Sekunden
      if(tmp > diff) then
        diff    := tmp;
        retcode := i;
      end_if;
    end_if;
  end_for;

END_FUNCTION

FUNCTION _AlarmXBuffer::SeekHmi
  VAR_INPUT
    id 	: UDINT;
  END_VAR
  VAR_OUTPUT
    retcode 	: USINT;
  END_VAR
  VAR
    ii : udint;
  END_VAR

  retcode := 16#FF;
  
  if(HmiNo > 0) then
    ii := HmiNo;
    while(ii) do
      ii -= 1;
      if(HmiMap[ii].id = id) then
        HmiMap[ii].tix := ops.tAbsolute;
        retcode := to_usint(ii);
        return;
      end_if;
    end_while;
  end_if;
  
  if(HmiNo < (sizeof(HmiMap)/sizeof(HmiMap[0]))) then
    HmiMap[HmiNo].id := id;
    HmiMap[HmiNo].tix := ops.tAbsolute;
//    HmiMap[HmiNo].no := 0;
    retcode          := to_usint(HmiNo);
    HmiNo += 1;
  end_if;

  if(retcode > (sizeof(HmiMap)/sizeof(HmiMap[0]))) then
    // suche den am längsten nicht mehr benutzten Eintrag...
    ii := SeekHmiUnused();
    if(ii < HmiNo) then
      HmiMap[ii].id  := id;
      HmiMap[ii].no  := ClassSvr;
      HmiMap[ii].tix := ops.tAbsolute;
      retcode        := to_usint(ii);
    end_if;
  end_if;

END_FUNCTION

FUNCTION _AlarmXBuffer::UnregisterHmi
  VAR_INPUT
    index 	: UDINT;
  END_VAR
  VAR_OUTPUT
    retcode : UDINT;
  END_VAR
  
  retcode := 16#FFFFFFFF;
  
  if(index < HmiNo) then
    if(HmiNo = (index +1)) then
      HmiNo -= 1;
    end_if;
    
    HmiMap[index].id  := 0;
    HmiMap[index].no  := ClassSvr;
    HmiMap[index].tix := ops.tAbsolute;
    
    retcode := index;
  end_if;

END_FUNCTION

FUNCTION _AlarmXBuffer::CreateTXBuffer
  VAR_INPUT
    tx 	: ^USINT;
    txsize 	: UDINT;
    pno 	: ^UDINT;
  END_VAR
  VAR_OUTPUT
    retcode 	: UINT;
  END_VAR
  VAR
    i, xno, sno, index : UDINT;
    txno    : UINT;
    txindex : UINT;
    pala    : ^_AB_ALARM;
    tmp     : usint;
  END_VAR

  // [4] .... alano
  // [4] .... date and time
  // [1] .... state, parano, group
  // [4] .... group (optional)
  // [4] .... lasalid (optional)
  // [n*4] .. parameter

  retcode := 0;
  
  if((MemAlarm.size = 0) | (MemAlarm.no = 0)) then
    // no entries available
    pno^ := 0;
  else
  
    xno     := pno^;
    sno     := 0;
    txindex := 1;

    i := 0;
    while(i < xno) do
      index := (ClassSvr - xno + i) mod MemAlarm.size;
      i     += 1;
      pala  := MemAlarm.ptr + (index * sizeof(_AB_ALARM));
      txno  := 9 + (pala^.parano * sizeof(pala^.para[0]));
      
      if(pala^.group <> 0) then
        txno += 8;
      end_if;
      
      if((txindex + txno) < txsize) then
        (tx + txindex)^$UDINT := pala^.alano;
        txindex += sizeof(UDINT);
        (tx + txindex)^$UDINT := pala^.dateTime;
        txindex += sizeof(UDINT);
        
        if(pala^.state = 255) then
          (tx + txindex)^$USINT := 255;
        else
          tmp := pala^.parano shl 1;
          if(pala^.state <> 0) then
            tmp := tmp or 1;
          end_if;
          if(pala^.group <> 0) then
            tmp := tmp or 16#80;
          end_if;
          (tx + txindex)^$USINT := tmp;
        end_if;
        
        txindex += sizeof(USINT);
        if(pala^.group <> 0) then
          (tx + txindex)^$UDINT := pala^.group;
          txindex += sizeof(UDINT);
          (tx + txindex)^$UDINT := pala^.lasalid;
          txindex += sizeof(UDINT);
        end_if;
        
        if(pala^.state <> 255) then 
          // keine parameter beim quittieren
          tmp := pala^.parano * sizeof(DINT);
          _memcpy(tx + txindex, #pala^.para[0], tmp);
          txindex += tmp;
        end_if;
        
        sno     += 1;
      else
        i := xno;
      end_if;
    end_while;

    pno^    := sno; // anzahl der eingetragenen alarme
    retcode := txindex;
  end_if;

END_FUNCTION

FUNCTION _AlarmXBuffer::GetConfig
	VAR_INPUT
		pDst 	: ^USINT;
		pThis 	: UDINT;
		xcmd 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UINT;
	END_VAR
  VAR
    i : UDINT;
	  anz : UINT;
    ptr : ^_AB_CONFIG;
  END_VAR

  retcode := 0;

  i := 0;
  ptr := MemConfig.ptr;
  while(i < MemConfig.no) do
    if(pThis = ptr^.pThis) then
      anz := ptr^.nopara;
      pDst^$UDINT := ptr^.config;   pDst += 4;
      pDst^$USINT := to_usint(anz); pDst += 1;
      if(xcmd = 1) then
        ptr^.configDone := true;
      end_if;
      anz := anz * 4;
      _memcpy(pDst, #ptr^.para[0], anz);
      retcode := anz + 5;
      exit;
    end_if;
    ptr += sizeof(_AB_CONFIG);
    i += 1;
  end_while;

END_FUNCTION

FUNCTION _AlarmXBuffer::GetMemConfig
	VAR_INPUT
		pdst 	: ^USINT;
		nox 	: UDINT;
		psrc 	: ^_AB_2ID;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
  VAR
  	len : udint;
  END_VAR

  retcode := 4;
  
  pdst$^UDINT^ := nox;
  pdst         += 4;
  
  while(nox) do
    pdst$^UDINT^ := psrc^.userid; pdst += 4;
    len          := GetConfig(pdst, psrc^.lasalid, 1);
    
    if(len > 0) then
      len          += 4;
      pdst         := pdst + len;
    else
      pdst$^udint^ := 0; pdst += 4;
      pdst$^usint^ := 0; pdst += 1;
      len          := 5;
    end_if;
    
    retcode += len;
    psrc    += sizeof(_AB_2ID);
    nox     -= 1;
  end_while;

END_FUNCTION

FUNCTION VIRTUAL _AlarmXBuffer::SeekMultiConfigBase
	VAR_INPUT
		alano 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^_AlarmX0Para;
	END_VAR
  VAR
    nox, end : UDINT;
    pConfig : ^_AB_CONFIG;
  END_VAR

  if(MemConfig.is_multiconfig = true) then // ask if there is any alarm with multiconfig
  
    pConfig := MemConfig.ptr;
    nox     := MemConfig.no;
    
    while(nox <> 0) do // iterate
      nox -= 1;
      if(alano >= pConfig^.config$UINT) & (pConfig^.pThis <> NIL)  then
        end := pConfig^.config$UINT + pConfig^.multiconfig;
        if(alano < end) then 
          retcode := pConfig^.pThis$^_AlarmX0Para;
          return;
        end_if;
      end_if;
      pConfig += sizeof(_AB_CONFIG);
    end_while;
  end_if;
  
  retcode := NIL;

END_FUNCTION

FUNCTION VIRTUAL _AlarmXBuffer::Quit_AlarmSingle
	VAR_INPUT
		alano 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    i : UDINT;
    pConfig : ^_AB_CONFIG;
    pAlarmXPara : ^_AlarmX0Para;
  END_VAR

  retcode := FALSE;
  //alano   := alano shl 16;

  i := 0;
  pConfig := MemConfig.ptr;
  while(i < MemConfig.no) do
    if(alano = pConfig^.config$UINT) then
      pAlarmXPara := pConfig^.pThis$^_AlarmX0Para;
      if(pAlarmXPara <> NIL) then
        pAlarmXPara^.QuitAlarm(alano);
        retcode := TRUE;
        return;
      end_if;
    end_if;
    pConfig += sizeof(_AB_CONFIG);
    i += 1;
  end_while;
  
  pAlarmXPara := SeekMultiConfigBase(alano);
  if(pAlarmXPara <> NIL) then
    pAlarmXPara^.QuitAlarm(alano);
    retcode := TRUE;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL _AlarmXBuffer::Quit_AlarmAll
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    i : UDINT;
    pConfig : ^_AB_CONFIG;
    pAlarmXPara : ^_AlarmX0Para;
  END_VAR

  retcode := TRUE;

  i := 0;
  pConfig := MemConfig.ptr;
  while(i < MemConfig.no) do
    pAlarmXPara := pConfig^.pThis$^_AlarmX0Para;
    if(pAlarmXPara <> NIL) then
      pAlarmXPara^.QuitAlarm();
    end_if;
    pConfig += sizeof(_AB_CONFIG);
    i += 1;
  end_while;

END_FUNCTION

FUNCTION VIRTUAL _AlarmXBuffer::Quit_AlarmAllEx
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    i : UDINT;
    pConfig : ^_AB_CONFIG;
    pAlarmXPara : ^_AlarmX0Para;
  END_VAR

  retcode := TRUE;

  i := 0;
  pConfig := MemConfig.ptr;
  while(i < MemConfig.no) do
    pAlarmXPara := pConfig^.pThis$^_AlarmX0Para;
    if(pAlarmXPara <> NIL) then
      pAlarmXPara^.QuitAlarmEx();
    end_if;
    pConfig += sizeof(_AB_CONFIG);
    i += 1;
  end_while;

END_FUNCTION

FUNCTION VIRTUAL _AlarmXBuffer::Quit_AlarmGroup
	VAR_INPUT
		group 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    i : UDINT;
    pConfig : ^_AB_CONFIG;
    pAlarmXPara : ^_AlarmX0Para;
  END_VAR

  retcode := FALSE;

  i := 0;
  pConfig := MemConfig.ptr;
  while(i < MemConfig.no) do
    if(pConfig^.group = group) then
      pAlarmXPara := pConfig^.pThis$^_AlarmX0Para;
      if(pAlarmXPara <> NIL) then
        pAlarmXPara^.QuitAlarm();
        retcode := TRUE;
      end_if;
    end_if;
    pConfig += sizeof(_AB_CONFIG);
    i += 1;
  end_while;

END_FUNCTION

FUNCTION VIRTUAL _AlarmXBuffer::Quit_AlarmGroupEx
	VAR_INPUT
		group 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    i : UDINT;
    pConfig : ^_AB_CONFIG;
    pAlarmXPara : ^_AlarmX0Para;
  END_VAR

  retcode := FALSE;

  i := 0;
  pConfig := MemConfig.ptr;
  while(i < MemConfig.no) do
    if(pConfig^.group = group) then
      pAlarmXPara := pConfig^.pThis$^_AlarmX0Para;
      if(pAlarmXPara <> NIL) then
        if (pAlarmXPara^.ClassSvr.Read()) then
          pAlarmXPara^.QuitAlarmEx();
          retcode := TRUE;
        end_if;
      end_if;
    end_if;
    pConfig += sizeof(_AB_CONFIG);
    i += 1;
  end_while;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL _AlarmXBuffer::QuitAll::Write
  VAR_INPUT
    input (EAX) 	: DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX) 	: DINT;
  END_VAR

  QuitAll := input;
  result  := QuitAll;
  Quit_AlarmAll();

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _AlarmXBuffer::QuitAllEx::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	QuitAllEx := input;
	result    := QuitAllEx;
  Quit_AlarmAllEx();

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _AlarmXBuffer::QuitGroup::Write
  VAR_INPUT
    input		: DINT;
  END_VAR
  VAR_OUTPUT
    result		: DINT;
  END_VAR

  QuitGroup := input;
  result    := QuitGroup;
  Quit_AlarmGroup(input$udint);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _AlarmXBuffer::QuitGroupEx::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	QuitGroupEx := input;
	result      := input;
  Quit_AlarmGroupEx(input$udint);

END_FUNCTION

FUNCTION _AlarmXBuffer::ComputeIndexAnz
  VAR_INPUT
    panz : ^UDINT;
    pidx : ^UDINT;
    clsvr : UDINT;
  END_VAR
	VAR_OUTPUT
		overflow : BOOL;
	END_VAR
  var
    maxanz, index, anz : UDINT;
  end_var

  maxanz := MemAlarm.size;
  index  := pidx^;
  anz    := panz^;
  
  if(index >= clsvr) then // check
    anz   := 0;
    index := 0;
    if(clsvr > 0) then
      index := clsvr - 1;
      anz := 1;
    end_if;
  elsif(clsvr > maxanz) then // Overflow im Ringbuffer
    if(index < (clsvr - maxanz)) then
      index := clsvr - maxanz;
      anz   := maxanz;
      overflow := true;
    end_if;
  end_if;
    
  if((index + anz) > clsvr) then
    anz := clsvr - index;
  end_if;

  panz^ := anz;
  pidx^ := index;

END_FUNCTION

FUNCTION _AlarmXBuffer::CreateTXBuffer202
	VAR_INPUT
		tx 	: ^USINT;
		txsize 	: UDINT;
		index 	: UDINT;
		anz 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
  VAR
    tmp     : usint;
    idx, maxanz : udint;
    pala    : ^_AB_ALARM;
    overflow : bool;
  END_VAR

  // out: [4] ................. index of first entry in resultbuffer
  //      [4] ................. number of entries in resultbuffer + (msb is set if overflow occured)
  //      *[4] ................ alano
  //      *[4] ................ date and time
  //      *[1] ................ state, parano, group
  //      *[4] ................ group
  //      *[4] ................ lasalid
  //      *[MAX_ALARMPARA*4] .. parameter

  retcode  := 0;
  overflow := false;
 
  if((MemAlarm.size = 0) | (MemAlarm.no = 0)) then
    // no entries available
    tx^$udint := 0; tx += 4; // index of first entry
    tx^$udint := 0; // number of entries
  else
    overflow := ComputeIndexAnz(#anz, #index, ClassSvr);
  
//    maxanz := MemAlarm.size;
//    if(index >= ClassSvr) then
//      anz := 0;
//      index := 0;
//      if(ClassSvr > 0) then
//        index := ClassSvr - 1;
//      end_if;
//    elsif(ClassSvr > maxanz) then
//      if(index < (ClassSvr - maxanz)) then
//        index := ClassSvr - MemAlarm.size;
//        anz   := MemAlarm.size;
//        overflow := true;
//      end_if;
//    end_if;
//    
//    if((index + anz) > ClassSvr) then
//      anz := ClassSvr - index;
//    end_if;
    
    tx^$udint := index; tx += 4; // index of first entry
    tx^$udint := 0; // number of entries
    
    if(index < ClassSvr) then
      maxanz := (txsize - 8) / (17 + 4 * MAX_ALARMPARA);
      if(anz > maxanz) then
        anz := maxanz;
      end_if;
      if((index + anz) > ClassSvr) then
        anz := ClassSvr - index;
      end_if;
    
      retcode    := anz;
      tx$^udint^ := anz; // number of entries
      if(overflow = true) then
        tx$^udint^ := 16#80000000 or anz; // number of entries + overflowflag
      end_if;
      tx += 4;
    
      _memset(tx, 0, txsize - 8); // clear tx-buffer
    
      while(anz) do
        anz   -= 1;
        idx   := index mod MemAlarm.size;
        index += 1;
        pala  := MemAlarm.ptr + (idx * sizeof(_AB_ALARM));
      
        tx^$udint := pala^.alano;    tx += 4; // alano
        tx^$udint := pala^.dateTime; tx += 4; // date and time
      
        if(pala^.state = 255) then
          tmp := 255;
        else
          tmp := pala^.parano shl 1;
          if(pala^.state <> 0) then
            tmp := tmp or 1;
          end_if;
          if(pala^.group <> 0) then
            tmp := tmp or 16#80;
          end_if;
        end_if;
        tx^$usint := tmp;           tx += 1; // state, parano, group
        tx^$udint := pala^.group;   tx += 4; // group
        tx^$udint := pala^.lasalid; tx += 4; // lasalid
        
        _memcpy(tx, #pala^.para[0], pala^.parano * sizeof(DINT)); // parameter
        tx += (4 * MAX_ALARMPARA);
      end_while;
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION _AlarmXBuffer::CreateTXBuffer203
	VAR_INPUT
    precsize : ^uint;
		tx 	: ^USINT;
		txsize 	: UDINT;
		index 	: UDINT;
    anz : UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
  VAR
    pala    : ^_AB_ALARM;
    overflow : bool;
    pno : ^udint;
    idx, recsize : udint;
  END_VAR

  // out: [4] ................... index of entry in resultbuffer
  //      [4] ................... number of entries (1 oder 0) in resultbuffer + (msb is set if overflow occured)
  //       [4] .................. alano
  //       [4] .................. date and time
  //       [2] .................. bytelength of single record
  //       [1] .................. nc (init with 0)
  //       [1] .................. state (bit0), parano (bit 1-6), group (bit 7)
  //       [4] .................. group
  //       [4] .................. lasalid
  //       [4] .................. userdata bytesize
  //       [4] .................. userdataid
  //       [parano * 4] ......... parameter
  //       [userdata bytesize] .. userdata

  if(txsize = 0) | (txsize > 0xFFFF) then
    txsize := sizeof(results.aData);
  end_if;

  retcode := 0;  // number of enclosed recods
  if(txsize >= 8) then // zur Sicherheit

    txsize   -= 8; // Korrektur
    overflow := false;

    tx^$udint  := index; tx += 4; // index of entry
    pno$^usint := tx;             // pointer to number of records
    tx^$udint  := 0;     tx += 4; // number of enclosed entries
 
    if((MemAlarm.size > 0) & (MemAlarm.no > 0)) then
      
      overflow := ComputeIndexAnz(#anz, #index, ClassSvr);
    
      while(anz) do
        anz -= 1;
        
        idx     := index mod MemAlarm.size;
        index   += 1;
        pala    := MemAlarm.ptr + (idx * sizeof(_AB_ALARM));
        recsize := SizeAlarmVersion5(pala);
        
        if(recsize <= txsize) then // check if there is enough space in resultbuffer
          txsize    -= recsize; // verbleibende Anzahl an Bytes im dst-Buffer
          retcode   += 1;
          precsize^ += to_uint(recsize);
          pno^      := pno^ + 1; // number of enclosed entries
    
          if(overflow = true) then
            pno^ := pno^ or 16#80000000; // number of enclosed entries + overflowflag
          end_if;
    
          tx := AddAlarmVersion5(tx, pala, recsize);
    
        else
          anz := 0; // finito
        end_if;
      end_while;
    end_if;
  end_if;

END_FUNCTION

FUNCTION _AlarmXBuffer::CreateUnregTXBuffer
	VAR_INPUT
		pres 	: ^USINT;
		startidx 	: UDINT;
		size 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UINT;
	END_VAR
  VAR
  	pidx : ^udint;
    panz : ^usint;
    plid : ^udint;
    ptr : ^_AB_CONFIG;  
  END_VAR

  pidx := pres$^udint; 
  pres += 4;
  panz := pres;
  pres += 1;
  plid := pres$^udint;
  
  
  pidx^ := 16#FFFFFFFF;
  panz^ := 0;
  
  size    -= 5;
  retcode := 5;
  
  if(startidx < MemConfig.no) then
    ptr := MemConfig.ptr + startidx * sizeof(_AB_CONFIG);
    while(startidx < MemConfig.no) do
      startidx += 1;
      
      if(ptr^.configDone = false) then
        panz^   += 1;
        size    -= 4;
        retcode += 4;
        plid^   := ptr^.pThis;
        plid    += 4;
        if(size < 4) then
          pidx^ := startidx;
          return;
        end_if;
      end_if;
    
      ptr += sizeof(_AB_CONFIG);
    
    end_while;
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL _AlarmXBuffer::ClassSvr::NewInst
  VAR_INPUT
    pPara 	: ^CmdStruct;
    pResult 	: ^results;
  END_VAR
  VAR_OUTPUT
    ret_code 	: iprStates;
  END_VAR
  VAR
    index, ii, tmp1, tmp2 : udint;
    pAlarmXPara : ^_AlarmX0Para;
  END_VAR

  ret_code := READY;

  case pPara^.uiCmd of
    0:// COMMAND_SETID ... terminal anmelden
      // in:   [4] ... unique id of hmi
        
      // out:  [1] ... handle to get access (error = 16#FF)
      DoMutex(true);
      pResult^.aData[0]$usint := SeekHmi(pPara^.aPara[0]$UDINT);
      pResult^.uiLng          := 3;
      DoMutex(false);

    1,7:// COMMAND_GETALARMCONFIG, COMMAND_GETALARMCONFIGEX ... get alarmconfig
      // in:   [4] ... lasalid of alarmserver
      
      // out:  [4] ... alarmconfiguration
      //       [1] ... number of parameterid
      //       *[4] .. parameterid
      DoMutex(true);
      pResult^.uiLng := 2;
      pAlarmXPara    := pPara^.aPara[0]$^_AlarmX0Para;
      if(pAlarmXPara <> NIL) then
        pResult^.uiLng := 2 + to_usint(GetConfig(#pResult^.aData[0], pAlarmXPara$UDINT, pPara^.uiCmd));
//          pResult^.uiLng := 2 + pAlarmXPara^.GetConfig(#pResult^.aData[0]);
//        end_if;
      end_if;
      DoMutex(false);

    11: // COMMAND_GETALARMCONFIGMULTI
      // in:   [4] .... handle 
      //       [4] .... anzahl
      //       *[4] ... user-id
      //       *[4] ... lasalid of alarmserver

      // out:  [4] .... anzahl
      //       *[4] ... user-id
      //       *[4] ... alarmconfiguration
      //       *[1] ... number of parameterid
      //       **[4] .. parameterid
      DoMutex(true);
      index := pPara^.aPara[0]$UDINT;
      if(index < HmiNo) then
        HmiMap[index].tix := ops.tAbsolute; // last update
        pResult^.uiLng := 2 + to_usint(GetMemConfig(#pResult^.aData[0], pPara^.aPara[1]$UDINT, #pPara^.aPara[2]$_AB_2ID));
      end_if;
      DoMutex(false);

    2:// COMMAND_GETALARMS ... get alarms
      // in:   [4] ... handle
      
      // out:  [1] ... number of records
      //       ??
      DoMutex(true);
      pResult^.uiLng    := 2;
      pResult^.aData[0] := 0;
      index := pPara^.aPara[0]$UDINT;
      if(index < HmiNo) then
        HmiMap[index].tix := ops.tAbsolute; // last update
        ii := HmiMap[index].no;
        //if(ii > 255) then
        //  ii := 255;
        //end_if;
        if(ii > MemAlarm.no) then
          ii               := MemAlarm.no;
          HmiMap[index].no := ii;
        end_if;
        if(ii > 0) then
          pResult^.uiLng    += CreateTXBuffer(#pResult^.aData[0], sizeof(pResult^.aData) - 2, #ii);
          HmiMap[index].no  -= ii;
          pResult^.aData[0] := to_usint(ii); // anzahl der einträge
        else
          pResult^.uiLng    += 1;
          pResult^.aData[0] := 0; // keine einträge vorhanden
        end_if;
      end_if;
      DoMutex(false);
    
    3:// COMMAND_QUITALARM ... quit alarm
      // in:   [4] ... handle
      //       [4] ... alarmnumber to quit or 0xFFFFFFFF to quit all
      
      // out:  [1] ... 0 = false, 1 = true
      pResult^.uiLng    := 3;
      pResult^.aData[0] := 0;
      index := pPara^.aPara[0]$UDINT;
      if(index < HmiNo) then
        HmiMap[index].tix := ops.tAbsolute; // last update
        ii := pPara^.aPara[1]$UDINT;
        if(ii = 0xFFFFFFFF) then
          if(Quit_AlarmAll() = true) then
            pResult^.aData[0] := 1;
          end_if;
        elsif(ii = 0xFFFFFFFE) then
          if(Quit_AlarmAllEx() = true) then
            pResult^.aData[0] := 1;
          end_if;
        else
          if(Quit_AlarmSingle(ii) = true) then
            pResult^.aData[0] := 1;
          end_if;
        end_if;
      end_if;

    4:// COMMAND_QUITGROUP ... quit alarmgroup
      // in:   [4] ... handle
      //       [4] ... groupnumber to quit
      
      // out:  [1] ... 0 = false, 1 = true
      pResult^.uiLng    := 3;
      pResult^.aData[0] := 0;
      index := pPara^.aPara[0]$UDINT;
      if(index < HmiNo) then
        HmiMap[index].tix := ops.tAbsolute; // last update
        ii := pPara^.aPara[1]$UDINT;
        if(Quit_AlarmGroup(ii) = true) then
          pResult^.aData[0] := 1;
        end_if;
      end_if;
      
    5:// COMMAND_RESETNOSENT ... reset number of already sent alarms
      // in:   [4] ... handle
      
      // out:  [1] ... 0 = false, 1 = true
      DoMutex(true);
      pResult^.uiLng    := 3;
      pResult^.aData[0] := 0;
      index := pPara^.aPara[0]$UDINT;
      if(index < HmiNo) then
        HmiMap[index].tix := ops.tAbsolute; // last update
        HmiMap[index].no := MemAlarm.no;
        pResult^.aData[0] := 1;
      end_if;
      DoMutex(false);
      
    6:// COMMAND_GETUNREGID ... get lasalid from all alarms which are actual not asked for their configuration
      // in:   [4] ... handle
      //       [4] ... startindex (initial 0, further request use endindex)
      
      // out:  [4] ... endindex (used for next request (startindex), 0xFFFFFFFF when finished)
      //       [1] ... anzahl
      //       [ ..... lasalids
      DoMutex(true);
      pResult^.uiLng          := 7;
      pResult^.aData[0]$UDINT := 16#FFFFFFFF;
      pResult^.aData[4]       := 0;
      index := pPara^.aPara[0]$UDINT;
      if(index < HmiNo) then
        HmiMap[index].tix := ops.tAbsolute; // last update
        pResult^.uiLng += CreateUnregTXBuffer(#pResult^.aData[0], pPara^.aPara[1]$udint, sizeof(pResult^.aData) - 10);
      end_if;
      DoMutex(false);
     
		200 : // register hmi
        // in:   [4] ... unique id of hmi
        //       [4] ... hmi style (1 = seperate set of index counter)
        
        // out:  [4] ... handle to get access (error = 16#FFFFFFFF)
        //       [4] ... index of last validated element
        //       [4] ... number of buffered elements
        //       [4] ... size of single element in byte
        //       [4] ... max. count of entries in buffer
        DoMutex(true);
        
        if(MemAlarm.ptr = nil) then
          CreateBufferDefault();
        end_if;
        
        pResult^.uiLng           := 2 + 20;
        pResult^.aData[0]$udint  := 16#FFFFFFFF;
        pResult^.aData[4]$udint  := 0;
        pResult^.aData[8]$udint  := 0;
        pResult^.aData[12]$udint := 17 + 4 * MAX_ALARMPARA;
        pResult^.aData[16]$udint := MemAlarm.size;
        index := SeekHmi(pPara^.aPara[0]$UDINT);
        if(index < HmiNo) then
          HmiMap[index].tix := ops.tAbsolute; // last update
          pResult^.aData[0]$udint := index;
          pResult^.aData[4]$udint := ClassSvr - HmiMap[index].no;
          pResult^.aData[8]$udint := ClassSvr;
        end_if;
        DoMutex(false);

    201 : // unregister hmi
        // in:   [4] ... handle
        
        // out:  [4] ... handle (on error = 16#FFFFFFFF)
        pResult^.uiLng          := 2 + 4;
        pResult^.aData[0]$udint := 16#FFFFFFFF;
        index := pPara^.aPara[0]$UDINT;
        
        DoMutex(true);
        if(index < HmiNo) then
          pResult^.aData[0]$udint := UnregisterHmi(index);
        end_if;
        DoMutex(false);
             
    202 : // read arbitrary entries
        // in:   [4] ... handle
        //       [4] ... startindex of entry
        //       [4] ... number of entries 

        // out:  [4] ... index of first entry in resultbuffer
        //       [4] ... number of entries in resultbuffer + (msb is set if overflow occured)
        //       [ ..... recordstream
        pResult^.uiLng := 2 + 8;
        pResult^.aData[0]$udint := 0;
        pResult^.aData[4]$udint := 0;
        
        DoMutex(true);
        index := pPara^.aPara[0]$UDINT;
        if(index < HmiNo) then
          HmiMap[index].tix := ops.tAbsolute; // last update
          ii := CreateTXBuffer202(#pResult^.aData[0], sizeof(pResult^.aData)-2, pPara^.aPara[1]$UDINT, pPara^.aPara[2]$UDINT); 
          pResult^.uiLng := to_uint(2 + 8 + ii * (17 + 4 * MAX_ALARMPARA));
          if(ii <> 0) then
            tmp1 := ClassSvr - HmiMap[index].no;
            tmp2 := pPara^.aPara[1]$UDINT + ii;
            if(tmp2 > tmp1) then
              HmiMap[index].no -= tmp2 - tmp1;
            end_if;
          end_if;
        end_if;
        DoMutex(false);

    203 : // read arbitrary entrys + ggf. vorhandene userdata (erst ab Version 5)
        // in:   [4] ... handle
        //       [4] ... startindex of entry
        //       [4] ... number of entries
        //       [4] ... bytesize of resultbuffer 
        
        // out:  [4] ... index of first entry in resultbuffer
        //       [4] ... number of entries in resultbuffer + (msb is set if overflow occured)
        //       [ ..... recordstream

        pResult^.uiLng := 2 + 8;
        pResult^.aData[0]$udint := 0;
        pResult^.aData[4]$udint := 0;
        
        DoMutex(true);
        index := pPara^.aPara[0]$UDINT;
        if(index < HmiNo) then
          HmiMap[index].tix := ops.tAbsolute; // last update
          ii := CreateTXBuffer203(#pResult^.uiLng, #pResult^.aData[0], pPara^.aPara[3]$UDINT, pPara^.aPara[1]$UDINT, pPara^.aPara[2]$UDINT); 
          if(ii <> 0) then
            tmp1 := ClassSvr - HmiMap[index].no;
            tmp2 := pPara^.aPara[1]$UDINT + 1;
            if(tmp2 > tmp1) then
              HmiMap[index].no -= tmp2 - tmp1;
            end_if;
          end_if;
        end_if;
        DoMutex(false);

    204 : // get number of entries in databuffer
        // out:  [4] ... actual catch_no value
        pResult^.aData[0]$udint := ClassSvr;
        pResult^.uiLng := 2 + 4;

    207 : // get number of entries in databuffer
        // in:   [4] ... handle
        // out:  [4] ... actual catch_no value
        index := pPara^.aPara[0]$UDINT;
        if(index < HmiNo) then
          HmiMap[index].tix := ops.tAbsolute; // last update
        end_if;    
        pResult^.aData[0]$udint := ClassSvr;
        pResult^.uiLng := 2 + 4;

    205 : // get version of DataQueueBuffer
        // out:  [4] ... versionnumber of recordbuffer
        pResult^.aData[0]$udint := GetVersion();
        pResult^.uiLng := 2 + 4;

    206 : // scan all alarms
        // in:   [4] ... handle
        //       [4] ... index start
        //       [4] ... alarmstate to scan for
        //       [4] ... 0=alle, 1=nur wenn im Buffer gefunden, 2=nur wenn im Buffer nicht gefunden
        DoMutex(true);
        index := pPara^.aPara[0]$UDINT;
        if(index < HmiNo) then
          HmiMap[index].tix := ops.tAbsolute; // last update
        end_if;
        DoMutex(false);
        pResult^.uiLng := 2 + to_uint(ScanAlarmState206(#pResult^.aData[0], sizeof(pResult^.aData), pPara^.aPara[1]$UDINT, pPara^.aPara[2], pPara^.aPara[3]$UDINT));

    208 : // scan all alarms + ggf. vorhandene userdata (erst ab Version 5)
        // in:   [4] ... handle
        //       [4] ... index start
        //       [4] ... alarmstate to scan for
        //       [4] ... 0=alle, 1=nur wenn im Buffer gefunden, 2=nur wenn im Buffer nicht gefunden
        //       [4] ... bytesize of resultbuffer
        DoMutex(true);
        index := pPara^.aPara[0]$UDINT;
        if(index < HmiNo) then
          HmiMap[index].tix := ops.tAbsolute; // last update
        end_if;
        DoMutex(false);
        pResult^.uiLng := 2 + to_uint(ScanAlarmState208(#pResult^.aData[0], pPara^.aPara[4]$UDINT, pPara^.aPara[1]$UDINT, pPara^.aPara[2], pPara^.aPara[3]$UDINT));

    210 : // get single alarm configuration
        // in:   [4] ... handle
        //       [4] ... index of configrecord

        // out:  [4] ... index or 0xFFFFFFFF
        //       [4] ... lasalid
        //       [4] ... config
        //       [4] ... group
        //       [4] ... number of parameter
        //       *[4] .. parameter
        DoMutex(true);
        index := pPara^.aPara[0]$UDINT;
        if(index < HmiNo) then
          HmiMap[index].tix := ops.tAbsolute; // last update
        end_if;
        pResult^.uiLng := CopyConfig((#pResult^.aData[0])$^udint, pPara^.aPara[1]$UDINT) + 2;
        DoMutex(false);

    else
        ret_code := ERROR;

  end_case;


END_FUNCTION

FUNCTION VIRTUAL _AlarmXBuffer::GetVersion
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR

  retcode := 5;
  // version 5: ability to add userdata of arbitrary length to each alarm
  // version 4: command 11, 201, 206, 207 (12.08.2020)
  // version 2: command 6 (COMMAND_GETUNREGID) and 7 (COMMAND_GETALARMCONFIGEX) are available
  // version 3: command 210 

END_FUNCTION

FUNCTION _AlarmXBuffer::CopyConfig
	VAR_INPUT
		pdst 	: ^UDINT;
		idx 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: uint;
	END_VAR
  VAR
  	pcf : ^_AB_CONFIG;
    nopa : udint;
    ph : ^udint;
  END_VAR

  retcode := 0;

  if(idx < MemConfig.no) then
    pdst^ := idx; pdst += 4; retcode += 4;
    pcf   := MemConfig.ptr + idx * sizeof(_AB_CONFIG);
    pdst^ := pcf^.pThis$udint; pdst += 4; retcode += 4;
    pdst^ := pcf^.config; pdst += 4; retcode += 4;
    pdst^ := pcf^.group; pdst += 4; retcode += 4;
    
    nopa  := pcf^.nopara;
    pdst^ := nopa; pdst += 4; retcode += 4;
    ph    := #pcf^.para[0];
    
    while(nopa > 0) do
      pdst^ := ph^; pdst += 4; retcode += 4;
      ph += 4;
      nopa -= 1;
    end_while;
  else
    pdst^   := 16#FFFFFFFF; pdst += 4; retcode += 4;
    pdst^   := 0; pdst += 4; retcode += 4;
    pdst^   := 0; pdst += 4; retcode += 4;
    pdst^   := 0; pdst += 4; retcode += 4;
  end_if;

END_FUNCTION

FUNCTION _AlarmXBuffer::LookupBuffer
	VAR_INPUT
		lid 	: UDINT;
		state 	: DINT;
		pnopara 	: ^UDINT;
		pdatim 	: ^UDINT;
		ppara 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	idx, cix, nox : udint;
    pta : ^_AB_ALARM;
  END_VAR

  // es wird der ringpuffer auf vorkommen von alarm durchsucht
  // wenn eintrag gefunden, so werden die parameter und der datetimestamp davon übernommen
  
  retcode  := false;
  
  DoMutex(true);
  
  if(MemAlarm.size > 0) then
    cix := ClassSvr;
    nox := cix;
    if(nox > memAlarm.no) then
      nox := memAlarm.no;
    end_if;
    
    while(nox) do
      nox -= 1;
      cix -= 1;
      
      idx := cix mod MemAlarm.size;                    // make rpos
      pta := MemAlarm.ptr + (idx * sizeof(_AB_ALARM)); // --> to alarm
   
      if(pta^.lasalid = lid) then
        if(pta^.state = state) then
        
          pdatim^ := pta^.dateTime;
          if(pta^.state <> 255) then
            _memcpy(ppara, #pta^.para[0], pta^.parano * 4);
            pnopara^ := pta^.parano;
          end_if;
          
          retcode := true;
          nox := 0; // finito
        end_if;
      end_if;
   
    end_while;
  end_if;

  DoMutex(false);

END_FUNCTION

FUNCTION _AlarmXBuffer::ScanAlarmState206
	VAR_INPUT
		pd 	: ^USINT;
		max_pd_size 	: UDINT;
		startidx 	: UDINT;
		state 	: DINT;
		buffstate 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
  VAR
  	idx, nox : udint;
    parano, datim, lid, size, spg, datimdef, tmp : udint; 
    pala : ^_AlarmX0Para;
    pcf : ^_AB_CONFIG;
    para : array[0..31] of dint;
    pdact : ^usint;
    pendidx, panzahl, ph : ^udint;
    all, addstate, found : bool;
  END_VAR
  
  // buffstate .... 0 alle alarme mit status eintragen
  //                1 nur wenn sie im Buffer gefunden wurden eintragen
  //                2 nur wenn sie nicht im Buffer gefunden wurden eintragen
  
  // out: [4] .... endidx
  //      [4] .... anzahl
  //      *[4] ................ alano
  //      *[4] ................ date and time
  //      *[1] ................ state, parano, group
  //      *[4] ................ group
  //      *[4] ................ lasalid
  //      *[parano * 4] ....... parameter
  
  retcode     := 8; // anzahl der bytes im dst-puffer
  max_pd_size -= 8;
  
  idx      := startidx;
  nox      := MemConfig.no;
  
  pendidx  := pd$^udint;
  panzahl  := pendidx + 4;
  pdact    := pd + 8;
  
  pendidx^ := idx;            // startindex initialiseren
  panzahl^ := 0;              // anzahl initialisieren
  
  pcf      := MemConfig.ptr + idx * sizeof(_AB_CONFIG);
  datimdef := MakeDateTime();    // date und time
  
  all      := true; // alle eintragen
  addstate := true; // init
  if(buffstate = 1) then
    all      := false; // nicht alle eintragen
    addstate := true;  // nur wenn im Buffer eingetragen
  elsif(buffstate = 2) then
    all      := false; // nicht alle eintragen
    addstate := false;  // nur wenn im Buffer nicht eingetragen
  end_if;
  
  
  while(idx < nox) do
    idx  += 1;
    pala := pcf^.pThis$^_AlarmX0Para;
    
    if(pala <> nil) then // check
    
      if(pala^.GetActualState(pcf^.Config) = state) then // alarmstatus ist gleich abzufragender status
        lid    := pala$udint;
        datim  := datimdef;
        parano := 0;
          
        found := LookupBuffer(lid, state, #parano, #datim, #para[0]); // alarm + parameter im aktuellen ringpuffer suchen falls vorhanden
        
        if((all = true) | (found = addstate)) then
        
  //          size := 17 + parano * 4;                // byteanzahl
          size := 17 + MAX_ALARMPARA * 4;         // byteanzahl
        
          if(size <= max_pd_size) then
            retcode     += size;
            max_pd_size -= size;
            panzahl^    += 1;                     // anzahl erhöhen

            spg := 255;
            if(state <> 255) then
              spg := 16#80 or (parano shl 1);
              if(state <> 0) then
                spg := spg or 1;
              end_if;
            end_if;
          
            pdact$^udint^ := pcf^.Config$udint;   pdact += 4;
            pdact$^udint^ := datim;               pdact += 4;
            pdact$^usint^ := spg$usint;           pdact += 1;
            pdact$^dint^  := pala^.Group.Read();  pdact += 4;
            pdact$^udint^ := lid;                 pdact += 4;

            tmp := MAX_ALARMPARA;
            ph  := pdact$^udint;
            while(tmp) do
              ph^ := 0;
              ph  += 4;
              tmp -= 1;
            end_while;
          
            if(parano > 0) then
              _memcpy(pdact, #para[0], parano*4);
            end_if;
          
            pdact += MAX_ALARMPARA * 4;
         
          else
            return;
          end_if;
        end_if;
          
      end_if;
    end_if;
    
    pendidx^ := idx;
    pcf += sizeof(_AB_CONFIG);
  end_while;
  
  if(idx >= nox) then
    pendidx^ := 0xFFFFFFFF; // finito
  end_if;
  
END_FUNCTION

FUNCTION _AlarmXBuffer::LookupBuffer208
	VAR_INPUT
		lid 	: UDINT;
		alano 	: UDINT;
		state 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^_AB_ALARM;
	END_VAR
  VAR
  	idx, cix, nox : udint;
    pala : ^_AB_ALARM;
  END_VAR

  // es wird der ringpuffer auf letztes eingetragenes Vorkommen von alarm durchsucht
  
  retcode := NIL;
  
  if(MemAlarm.size > 0) then
    cix := ClassSvr;
    nox := cix;
    if(nox > memAlarm.no) then
      nox := memAlarm.no;
    end_if;
    
    while(nox) do
      nox -= 1;
      cix -= 1;
      
      idx := cix mod MemAlarm.size;                    // make rpos
      pala := MemAlarm.ptr + (idx * sizeof(_AB_ALARM)); // --> to alarm
   
      if(pala^.lasalid = lid) & (pala^.alano = alano) & (pala^.state = state) then
        retcode := pala;
        return; // finito
      end_if;
   
    end_while;
  end_if;

END_FUNCTION

FUNCTION _AlarmXBuffer::ScanAlarmState208
	VAR_INPUT
		pd 	: ^USINT;
		max_pd_size 	: UDINT;
		startidx 	: UDINT;
		state 	: DINT;
		buffstate 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
  VAR
  	idx, nox, config, nomc : udint;
    size, datimdef : udint; 
    pobj : ^_AlarmX0Para;
    pcf : ^_AB_CONFIG;
    pdact : ^usint;
    pendidx, panzahl : ^udint;
    all, add, addstate : bool;
    pala : ^_AB_ALARM;
    dummy : _AB_ALARM;
  END_VAR
  
  // buffstate .... 0 alle alarme mit status eintragen
  //                1 nur wenn sie im Buffer gefunden wurden eintragen
  //                2 nur wenn sie nicht im Buffer gefunden wurden eintragen
  
  // out: [4] ..... Endindex
  //      [4] ..... Anzahl
  //      *[ ...... Alarm V5
  
  if(max_pd_size = 0) | (max_pd_size > 0xFFFF) then
    max_pd_size := sizeof(results.aData);
  end_if;
  
  _memset(#dummy, 0, sizeof(dummy)); // init default alarm
  
  retcode     := 8; // anzahl der bytes im dst-puffer
  max_pd_size -= 8;
  
  idx      := startidx;
  nox      := MemConfig.no;
  
  pendidx  := pd$^udint;
  panzahl  := pendidx + 4;
  pdact    := pd + 8;
  
  pendidx^ := idx;            // startindex initialiseren
  panzahl^ := 0;              // anzahl initialisieren
  
  pcf      := MemConfig.ptr + idx * sizeof(_AB_CONFIG);
  datimdef := MakeDateTime();    // date und time
  
  all      := true; // alle eintragen
  addstate := true; // init
  if(buffstate = 1) then
    all      := false; // nicht alle eintragen
    addstate := true;  // nur wenn im Buffer eingetragen
  elsif(buffstate = 2) then
    all      := false; // nicht alle eintragen
    addstate := false;  // nur wenn im Buffer nicht eingetragen
  end_if;
    
  while(idx < nox) do
    idx  += 1;
    pobj := pcf^.pThis$^_AlarmX0Para;
    
    if(pobj <> nil) then // check
    
      nomc := pcf^.multiconfig;
      repeat
        if(nomc > 0) then
          nomc -= 1;
        end_if;
        config := pcf^.Config + nomc;
        
        if(pobj^.GetActualState(config) = state) then // alarmstatus ist gleich abzufragender status
      
          DoMutex(true); // *************************************************************************
          
          pala := LookupBuffer208(pobj$udint, config, state); // alarm im ringpuffer suchen falls vorhanden
        
          add := all;
          if(all = false) then
            if(addstate = true) then
              add := (pala <> NIL);
            else
              add := (pala = NIL);
            end_if;
          end_if;
        
          if(add = true) then
            if(pala = NIL) then // create dummy alarm
              dummy.alano      := config$udint;
              dummy.group$dint := pobj^.Group.Read();
              dummy.lasalid    := pobj$UDINT;
              dummy.dateTime   := datimdef;
              dummy.parano     := 0;
              dummy.state      := state$usint;
              pala := #dummy;
            end_if;
        
            size := SizeAlarmVersion5(pala); // get dst-size of alarm
            
            if(size <= max_pd_size) then
              retcode     += size;
              max_pd_size -= size;
              panzahl^    += 1; // inc number of alarms
              
              pdact := AddAlarmVersion5(pdact, pala, size); // add alarm to dst
            else
              DoMutex(false); // not nice, but that's how it is **************************************
              return;
            end_if;
          end_if;
          
          DoMutex(false); // *************************************************************************
          
        end_if;
      until(nomc = 0) end_repeat;
    end_if;
    
    pendidx^ := idx;
    pcf += sizeof(_AB_CONFIG);
  end_while;
  
  if(idx >= nox) then
    pendidx^ := 0xFFFFFFFF; // finito
  end_if;
  
END_FUNCTION


FUNCTION _AlarmXBuffer::SizeAlarmVersion5
	VAR_INPUT
    pala : ^_AB_ALARM;
	END_VAR
	VAR_OUTPUT
    retcode : UDINT;
	END_VAR

  retcode := (6 * 4) + (2 + 1 + 1) + pala^.parano * 4 + pala^.userdata.bytesize;

END_FUNCTION

FUNCTION _AlarmXBuffer::AddAlarmVersion5
	VAR_INPUT
		tx 	: ^USINT;
		pala 	: ^_AB_ALARM;
		recsize 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^USINT;
	END_VAR
  VAR
  	tmp : usint;
  END_VAR
 
  // [4] .................. alano
  // [4] .................. date and time
  // [2] .................. bytelength of single record
  // [1] .................. nc (init with 0)
  // [1] .................. state (bit0), parano (bit 1-6), group (bit 7)
  // [4] .................. group
  // [4] .................. lasalid
  // [4] .................. userdata bytesize
  // [4] .................. userdataid
  // [parano * 4] ......... parameter
  // [userdata bytesize] .. userdata
 
  tx^$udint := pala^.alano;    tx += 4; // alano
  tx^$udint := pala^.dateTime; tx += 4; // date and time

  if(pala^.state = 255) then
    tmp := 255;
  else
    tmp := pala^.parano shl 1;
    if(pala^.state <> 0) then
      tmp := tmp or 1;
    end_if;
    if(pala^.group <> 0) then
      tmp := tmp or 16#80;
    end_if;
  end_if;

  tx^$uint  := to_uint(recsize);        tx += 2; // bytesize of record
  tx^$usint := 0;                       tx += 1; // nc, set to 0
  tx^$usint := tmp;                     tx += 1; // state, parano, group
  tx^$udint := pala^.group;             tx += 4; // group
  tx^$udint := pala^.lasalid;           tx += 4; // lasalid
  tx^$udint := pala^.userdata.bytesize; tx += 4; // bytesize of userdata
  tx^$udint := pala^.userdata.userid;   tx += 4; // id of userdata
          
  if(pala^.parano > 0) then
    _memcpy(tx, #pala^.para[0], pala^.parano * sizeof(DINT)); // parameter
    tx += (4 * pala^.parano);
  end_if;
          
  if(pala^.userdata.bytesize > 0) then
    _memcpy(tx, pala^.userdata.ptr, pala^.userdata.bytesize); // userdata
    tx += pala^.userdata.bytesize;
  end_if;

  retcode := tx;

END_FUNCTION

