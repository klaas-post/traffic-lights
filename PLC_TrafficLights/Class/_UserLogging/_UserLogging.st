//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES


#define USERLOGGING_OBJECTNAME_MAX_LENGTH   100
#define USERLOGGING_DEFAULT_MEMMARK         0
#define USERLOGGING_OBJECT_EMBED_DELIMITER  16#0000005C // ASCII "\" as DINT
#define USERLOGGING_SIZELEXEMCRC            4
#define USERLOGGING_DEFAULTLOGSIZE          (10*1024)
#define USERLOGGING_MIN_LOGFILE_ID          0
#define USERLOGGING_MAX_LOGFILE_ID          9
#define USERLOGGING_OS_STARTVERSION_SALAMANDER  16#9000
#define USERLOGGING_LF                      16#000A

//Logging Message Len:
#define USERLOGGING_WRITE_MAX_LEN           100                                                             //Maximum Length of the String that SysMsg will Accept.
#define USERLOGGING_WRITE_MAX_LEN_UNI       200                                                             //Maximum Length of the String for unicode conversion (only needed if connected to EventJournal)
#define USERLOGGING_PARAMETER_MAX_LENGTH    (44 + (4*USERLOGGING_TEXT_DELIMITER_LEN))                       //Part of the string that is reserved for Parameters: (4 x DINTs (11 Chars)) + 4 x Delimiters.
#define USERLOGGING_MSG_MAX_LENGTH          USERLOGGING_WRITE_MAX_LEN - USERLOGGING_PARAMETER_MAX_LENGTH    //Length of the Message part of the string.
#define USERLOGGING_MULTILINE_MAXLEN        400

//Text Defines:
#define USERLOGGING_ERROR_TEXT              "Error"
#define USERLOGGING_ERROR_TEXT_LEN          5
#define USERLOGGING_WARNING_TEXT            "Warning"
#define USERLOGGING_WARNING_TEXT_LEN        7
#define USERLOGGING_DEBUG_TEXT              "Debug"
#define USERLOGGING_DEBUG_TEXT_LEN          5
#define USERLOGGING_INFO_TEXT               "Info"
#define USERLOGGING_INFO_TEXT_LEN           4

//Masks:
#define USERLOGGING_MASK_INFO               16#00000001
#define USERLOGGING_MASK_WARNING            16#00000004
#define USERLOGGING_MASK_ERROR              16#00000008
#define USERLOGGING_MASK_DEBUG              16#00000010

//Internal Error Trace Messages:
#define USERLOGGING_ERR_LOGFILEID_NOT_OK        "_UserLogging: Client LogFileID is not Initialised correctly, Initialisation stopped."
#define USERLOGGING_ALLOCATING_MEM_FAILED       "_UserLogging: Allocating Memory Failed, Initialisation stopped."
#define USERLOGGING_CREATING_FILE_FAILED        "_UserLogging: Creating / Opening Log File Failed, Initialisation stopped."
#define USERLOGGING_SYSMSG_LOG_FAIL_NOT_INITED  "_UserLogging: Sending log to SysMsg failed, the SysMsg log file has not been Initialised."
#define USERLOGGING_EVENTLOG_FAIL_NOT_CONN      "_UserLogging: Sending log to EventLog failed, the cEventLog Client is not connected."

//SysMsg Defines:
#define USERLOGGING_LOGFLUSH_INTERVAL       10secs
#define USERLOGGING_FLUSH_FAIL_NO_HANDLE    -2
#define USERLOGGING_DEFAULTLOGFILE_QUOTA    -1  //-1 -> System Default is used.
#define USERLOGGING_SYSMSG_TIMESTAMP        1

//CreateMsgString() Retcodes:
#define USERLOGGING_CREATESTRING_OK         0
#define USERLOGGING_CREATESTRING_ERROR      -1

//EventQueue NewInst:
#define USERLOGGING_EQ_METHOD_NUM           8
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "_UserLogging"
	Revision           = "1.6"
	GUID               = "{CEA7BA8E-1683-4590-B812-186D4FDAAE58}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	DefBackground      = "500 ms"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(510,120)">
	<Channels>
		<Server Name="DebugCnt" GUID="{786F2187-D2EC-4241-AA27-59BE6DD0072F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This server counts up every time a Debug Message will be saved to the log file or event journal."/>
		<Server Name="Env_EventLogLevelName" GUID="{A9783C85-B58A-4E39-A146-BBDB8E3D7C97}" Class="VirtualBaseInit" Visualized="false" Initialize="true" WriteProtected="false" Retentive="false" Comment="insert the name of the environment variable you are interested&#13;&#10;( SETENV XXXX YY in autoexec.lsl -&gt;&#13;&#10;insert &quot;XXXX&quot; )"/>
		<Server Name="Env_EventLogLevelVal" GUID="{81E1997F-470D-470B-8E98-E4F8DC966114}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Value as numeric of the environment variable&#13;&#10;( SETENV XXXX YY in autoexec.lsl -&gt;&#13;&#10;&quot;YY&quot; )"/>
		<Server Name="Env_FileLogLevelName" GUID="{B03681CB-0B46-4AC7-B104-D782277C3EDD}" Class="VirtualBaseInit" Visualized="false" Initialize="true" WriteProtected="false" Retentive="false" Comment="This server displays the name of the ENV variable inside the class."/>
		<Server Name="Env_FileLogLevelVal" GUID="{A462A98E-85BF-4E5D-B888-4D10DACA7DD9}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Value as numeric of the environment variable&#13;&#10;( SETENV XXXX YY in autoexec.lsl -&gt;&#13;&#10;&quot;YY&quot; )"/>
		<Server Name="ErrorCnt" GUID="{8C5B5BF3-FCEB-4C38-B87E-677685055562}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This server counts up every time a Error Message will be saved to the log file or event journal."/>
		<Server Name="EventLogLevel" GUID="{D914DA0F-1B4E-4BEE-9A8F-655BE043661C}" Visualized="false" Initialize="true" WriteProtected="false" Retentive="File" Comment="On this server the user can write the ForwardingLevel configuration."/>
		<Server Name="FileLogLevel" GUID="{7E10BDD1-AAA4-46C3-8162-4B6E3111876A}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="File" Comment="This server shows the LoggingLevel, which is written on an environment variable inside the class."/>
		<Server Name="Flush" GUID="{AD2F26B3-7010-4BB4-92E0-8C94B092A235}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false" Comment="Writing to this server causes the Log Flush method to be called,&#13;&#10;The return value can be:&#13;&#10;-2 -&gt; No Log Handle Set, the log object has not been / failed initialising.&#13;&#10;0 -&gt; Success&#13;&#10;else -&gt; Retcode from the _SysMsg OS Interface."/>
		<Server Name="InfoCnt" GUID="{06FCB732-4985-40A2-9A61-3280F65A499B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This server counts up every time an Info Message will be saved to the log file or event journal."/>
		<Server Name="InitOK" GUID="{AED4082E-80E6-4DF7-9F33-2829D15AB944}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="This server can be used as an object server to call the &quot;AddEntry&quot; method."/>
		<Server Name="LogFileQuota" GUID="{D0D76636-5284-40C9-B662-E4A4CF8E5146}" Visualized="false" Initialize="true" DefValue="USERLOGGING_DEFAULTLOGFILE_QUOTA" WriteProtected="false" Retentive="File" Comment="Maximum size of the Logfile in Bytes. -1 =&gt; System standard is used."/>
		<Server Name="LogFlushInterval" GUID="{E6DD781C-BFF5-46B6-BCE8-1110C0CB886A}" Visualized="false" Initialize="true" DefValue="USERLOGGING_LOGFLUSH_INTERVAL" WriteProtected="false" Retentive="File" Comment="Cyclic flush interval in milliseconds."/>
		<Server Name="WarningCnt" GUID="{1B571AD7-49FB-4C63-8F91-A9ADC1FB769F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This server counts up every time a Warning Message will be saved to the log file or event journal."/>
		<Client Name="cActivateTrace" Required="false" Internal="false" DefValue="0" Comment="If this client is set to 1 Log messages are forwarded to the Trace Message system."/>
		<Client Name="cEventLog" Required="false" Internal="false" Comment="Client to be connected to the Eventlog Command Channel to forward log messages."/>
		<Client Name="cLogBufferSize" Required="false" Internal="false" DefValue="USERLOGGING_DEFAULTLOGSIZE" Comment="Log size to use for the Message Buffer."/>
		<Client Name="cLogFileID" Required="false" Internal="false" Comment="The user must initialise this client to select the Log File to save logs into."/>
		<Client Name="EnvVar_ForwLvl" Required="true" Internal="true"/>
		<Client Name="EnvVar_LogLvl" Required="true" Internal="true"/>
		<Client Name="SigCLib" Required="false" Internal="false" Comment="Client to the SigCLib OS Interface, requires no connection."/>
		<Client Name="SysMsg" Required="false" Internal="false" Comment="Client to the _SysMsg OS Interface, requires no connection."/>
	</Channels>
	<Separators>
		<Servers>
			<SepChn Position="12"/>
			<SepChn Position="8"/>
			<SepChn Position="3"/>
		</Servers>
	</Separators>
	<Dependencies>
		<Files>
			<File Path=".\Class\_UserLogging\_UserLogging_de.pdf"/>
			<File Path=".\Class\_UserLogging\_UserLogging_en.pdf"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.6" Date="2021-03-17" Author="MehMar" Company="Sigmatek" Description="Improvement: Removed not required connection to _StdLib."/>
		<Dokumentation Revision="1.5" Date="2021-03-09" Author="HubChr" Company="Sigmatek" Description="Refactoring of AddEntry() and CreateMsgString() to optimize performance and memory management. CriticalSection no longer needed."/>
		<Dokumentation Revision="1.4" Date="2020-06-23" Author="KaiAnd" Company="Sigmatek" Description="changed #define USERLOGGING_DEFAULTLOGSIZE from &quot;10kB&quot; to &quot;(10*1024)&quot;"/>
		<Dokumentation Revision="1.3" Date="2019-08-12" Author="HubChr" Company="Sigmatek" Description="Bugfix: Line Feed after log messages did not work correctly on RTOS systems"/>
		<Dokumentation Revision="1.2" Date="2019-07-09" Author="KruAle" Company="Sigmatek" Description="Bigger log-messages are now supported, by splitting them into more smaller ones."/>
		<Dokumentation Revision="1.1" Date="2019-07-09" Author="HubChr" Company="Sigmatek" Description="More than one instance of the class can now be used to cause entries in the same logfile."/>
		<Dokumentation Revision="1.0" Date="2019-05-08" Author="VelGer" Company="Sigmatek" Description="Trace Message removed if no EventLog connection as this flooded the Trace View.&#13;&#10;Renamed Clients (Correct Use of &quot;c&quot;/&quot;oc&quot; etc.)"/>
		<Dokumentation Revision="0.9" Date="2019-03-07" Author="ZilSal" Company="Sigmatek"/>
	</RevDoku>
	<Network Name="_UserLogging">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "EnvVar_ForwLvl"
				GUID       = "{7DC7FBCF-865A-4116-89A8-ADEDFF6207F3}"
				Class      = "EnvironmentVariable"
				Position   = "(330,900)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="sNumericValue"/>
					<Server Name="sRefresh"/>
					<Server Name="sStatus"/>
					<Server Name="sStringValue"/>
					<Server Name="sVariableName"/>
				</Channels>
			</Object>
			<Object
				Name       = "EnvVar_LogLvl"
				GUID       = "{74C92320-443F-4047-9043-F63B3F5A1FCD}"
				Class      = "EnvironmentVariable"
				Position   = "(330,360)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="sNumericValue"/>
					<Server Name="sRefresh"/>
					<Server Name="sStatus"/>
					<Server Name="sStringValue"/>
					<Server Name="sVariableName"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
			<Comment Position="(1140,1020)" Size="(360,210)" Text="Environment Variable Objects are used to read the Logging and Forward Level Environment Variables."/>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.EnvVar_LogLvl" Destination="EnvVar_LogLvl.sStatus"/>
			<Connection Source="this.Env_FileLogLevelName" Destination="EnvVar_LogLvl.sVariableName" Vertices="(1656,510),(880,510),"/>
			<Connection Source="this.EnvVar_ForwLvl" Destination="EnvVar_ForwLvl.sStatus"/>
			<Connection Source="this.Env_EventLogLevelName" Destination="EnvVar_ForwLvl.sVariableName" Vertices="(1656,690),(1050,690),(1020,720),(1020,1020),(990,1050),(880,1050),"/>
			<Connection Source="this.Env_FileLogLevelVal" Destination="EnvVar_LogLvl.sNumericValue" Vertices="(1656,570),(1020,570),(990,600),(960,600),(930,630),(880,630),"/>
			<Connection Source="this.Env_EventLogLevelVal" Destination="EnvVar_ForwLvl.sNumericValue" Vertices="(1656,750),(1110,750),(1080,780),(1080,1140),(1050,1170),(880,1170),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
_UserLogging : CLASS
	TYPE
	  t_e_UserLogInitRet :
	  (
	    UIR_Success,
	    UIR_LogFileIDNotOK,
	    UIR_MemAllocFail,
	    UIR_SysLogOpenFail
	  )$UDINT;
#pragma pack(push, 1)
	  t_s_AddEntryVariables : STRUCT
	    pCategory : ^CHAR;
	    pObjectname : ^CHAR;
	    pMsg : ^CHAR;
	    LevelNr : USINT;
	    LevelMsg : ^CHAR;
	    MsgGroup : UDINT;
	    MsgNbr : UDINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_s_ConnectedClients : BDINT
	  [
	    1 cEventLog,
	    2 cLogBufferSize,
	    3 cActivateTrace,
	    4 cLogFileID,
	    5 Bit5,
	    6 Bit6,
	    7 Bit7,
	    8 Bit8,
	    9 Bit9,
	    10 Bit10,
	    11 Bit11,
	    12 Bit12,
	    13 Bit13,
	    14 Bit14,
	    15 Bit15,
	    16 Bit16,
	    17 Bit17,
	    18 Bit18,
	    19 Bit19,
	    20 Bit20,
	    21 Bit21,
	    22 Bit22,
	    23 Bit23,
	    24 Bit24,
	    25 Bit25,
	    26 Bit26,
	    27 Bit27,
	    28 Bit28,
	    29 Bit29,
	    30 Bit30,
	    31 Bit31,
	    32 Bit32,
	  ];
	END_TYPE
  //Servers:
	InitOK 	: SvrChCmd_DINT;
	Flush 	: SvrCh_DINT;
	LogFlushInterval 	: SvrCh_UDINT;
	FileLogLevel 	: SvrCh_BDINT;
	LogFileQuota 	: SvrCh_DINT;
	Env_FileLogLevelName 	: SvrChCmd_UDINT;
	Env_FileLogLevelVal 	: SvrCh_DINT;
	EventLogLevel 	: SvrCh_BDINT;
	Env_EventLogLevelName 	: SvrChCmd_UDINT;
	Env_EventLogLevelVal 	: SvrCh_DINT;
	InfoCnt 	: SvrCh_DINT;
	WarningCnt 	: SvrCh_DINT;
	ErrorCnt 	: SvrCh_DINT;
	DebugCnt 	: SvrCh_DINT;
  //Clients:
	cEventLog 	: CltChCmd_DINT;
	SysMsg 	: CltChCmd__SysMsg;
	SigCLib 	: CltChCmd_SigCLib;
	cLogBufferSize 	: CltCh_UDINT;
	cActivateTrace 	: CltCh_UDINT;
	cLogFileID 	: CltCh_DINT;
	EnvVar_LogLvl 	: CltChCmd_EnvironmentVariable;
	EnvVar_ForwLvl 	: CltChCmd_EnvironmentVariable;
  //Variables:
		AddEntryVariables 	: t_s_AddEntryVariables;
		aObjectName : ARRAY [0..USERLOGGING_OBJECTNAME_MAX_LENGTH-1] OF CHAR;

		bdConnectedClients 	: t_s_ConnectedClients;
		pSystemLogBuffer 	: ^CHAR;
		udBuffSize 	: UDINT;
		udBytesToFlush 	: UDINT;
		udSysMsgHandle 	: UDINT;
		udTimestamp 	: UDINT;
		udLogBufferSize 	: UDINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION AllocateMemory
		VAR_OUTPUT
			pLog 	: ^CHAR;
		END_VAR;
	
	FUNCTION CheckLevel
		VAR_INPUT
			Level 	: UDINT;
			BDINTValue 	: BDINT;
		END_VAR
		VAR_OUTPUT
			LevelFound 	: BOOL;
		END_VAR;
	
	FUNCTION CreateMsgString
		VAR_INPUT
			pCategory 	: ^CHAR;
			Level 	: UDINT;
			MsgGroup 	: DINT;
			MsgNbr 	: DINT;
			pMsg 	: ^CHAR;
			pPara1 	: ^DINT;
			pPara2 	: ^DINT;
			pPara3 	: ^DINT;
			pPara4 	: ^DINT;
			pTmpBuffer 	: ^CHAR;			//! <Variable Comment="Pointer to a Buffer where the log string will be created (append Parameters etc.)" Name="CreateMsgString.pTmpBuffer"/>
			udTmpBufferSize 	: UDINT;			//! <Variable Comment="Size of the Buffer where the log string will be created (append Parameters etc.)" Name="CreateMsgString.udTmpBufferSize"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="returns the length of the message string. -1 if input parameters are not ok." Name="CreateMsgString.Retcode"/>
		END_VAR;
				//! <Function Comment="This method accepts a message with Parameters, builds a log string and then forwards the string to the relative locations:&#13;&#10;1. SysMsg File - if the level passed matches an activated level in the FileLogLevel Server.&#13;&#10;2. EventLog Class - if the level passed matches an activated level in the EventLogLevel Server.&#13;&#10;3. Trace - If the cActivateTrace client = 1" Name="AddEntry"/>
	FUNCTION GLOBAL AddEntry
		VAR_INPUT
			pCategory 	: ^CHAR;			//! <Variable Comment="Pointer to the Category of event. Pointer of CHAR." Name="AddEntry.pCategory"/>
			Level 	: UDINT;			//! <Variable Comment="Level Nr of the event. USINT&#13;&#10;&#13;&#10;2#00001 = Info&#13;&#10;2#00100 = Warning&#13;&#10;2#01000 = Error&#13;&#10;2#10000 = Debug" Name="AddEntry.Level"/>
			MsgGroup 	: DINT;			//! <Variable Comment="Number of the Message Group. UDINT" Name="AddEntry.MsgGroup"/>
			MsgNbr 	: DINT;
			pMsg 	: ^CHAR;			//! <Variable Comment="Pointer to the event message text. Pointer of CHAR" Name="AddEntry.pMsg"/>
			pPara1 	: ^DINT;			//! <Variable Comment="Pointer to the first parameter (number). Pointer of UDINT" Name="AddEntry.pPara1"/>
			pPara2 	: ^DINT;			//! <Variable Comment="Pointer to the second parameter (number). Pointer of UDINT" Name="AddEntry.pPara2"/>
			pPara3 	: ^DINT;			//! <Variable Comment="Pointer to the third parameter (number). Pointer of UDINT" Name="AddEntry.pPara3"/>
			pPara4 	: ^DINT;			//! <Variable Comment="Pointer to the forth parameter (number). Pointer of UDINT" Name="AddEntry.pPara4"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="0 .. ok&#13;&#10;&lt;0 .. error" Name="AddEntry.Retcode"/>
		END_VAR;
	
	FUNCTION CreateEventLog
		VAR_INPUT
			pMessage 	: ^CHAR;
		END_VAR;
				//! <Function Comment="This method allows the user to reinitialise the logging object.&#13;&#10;This method is automatically called once during the _Firstscan Init Cycle, therefor the user does not have to call the method under normal circumstances.&#13;&#10;&#13;&#10;If any of the following parameters have changed, the Log Class needs to be reinitialised by calling this method:&#13;&#10;1. cLogFileID Value.&#13;&#10;2. cLogBufferSize Value.&#13;&#10;3. Environment Variable Names: (Env_LogLevel or Env_ForwardLevel).&#13;&#10;&#13;&#10;If the either of the Environment Variables are set, this method overwrites the Level value in the respective server." Name="Initialise"/>
	FUNCTION GLOBAL Initialise
		VAR_OUTPUT
			RetCode 	: t_e_UserLogInitRet;
		END_VAR;
				//! <Function Comment="Returns the ASCII length of a DINT value. The 0-termination of the string will be counted. If the Value is negative, the &quot;-&quot; symbol will also be counted." Name="getAsciiLen"/>
	FUNCTION getAsciiLen
		VAR_INPUT
			dValue 	: DINT;
		END_VAR
		VAR_OUTPUT
			udLen 	: UDINT;			//! <Variable Comment="length of a 0-terminated character string containng the value. &quot;-&quot; is taken under account." Name="getAsciiLen.udLen"/>
		END_VAR;
				//! <Function Comment="Writing to this server causes the Log Flush method to be called,&#13;&#10;The return value can be:&#13;&#10;-2 -&gt; No Log Handle Set, the log object has not been / failed initialising.&#13;&#10;0 -&gt; Success&#13;&#10;else -&gt; Retcode from the _SysMsg OS Interface." Name="Flush.Write"/>
	FUNCTION VIRTUAL GLOBAL Flush::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Env_FileLogLevelName::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Env_FileLogLevelName::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Env_FileLogLevelVal::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Env_FileLogLevelVal::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Env_EventLogLevelName::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Env_EventLogLevelName::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Env_EventLogLevelVal::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Env_EventLogLevelVal::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using EnvironmentVariable
#pragma usingLtd _SysMsg
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _UserLogging::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__USERLOGGING
1$UINT, 6$UINT, (SIZEOF(::_UserLogging))$UINT, 
14$UINT, 8$UINT, 0$UINT, 
TO_UDINT(2236268114), "_UserLogging", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_UserLogging.InitOK.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1695565350), "InitOK", 
(::_UserLogging.Flush.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1135973919), "Flush", 
(::_UserLogging.LogFlushInterval.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(1941339757), "LogFlushInterval", 
(::_UserLogging.FileLogLevel.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(1824342827), "FileLogLevel", 
(::_UserLogging.LogFileQuota.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(1835323447), "LogFileQuota", 
(::_UserLogging.Env_FileLogLevelName.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(1251504220), "Env_FileLogLevelName", 
(::_UserLogging.Env_FileLogLevelVal.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(764260185), "Env_FileLogLevelVal", 
(::_UserLogging.EventLogLevel.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(32643146), "EventLogLevel", 
(::_UserLogging.Env_EventLogLevelName.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(2739481400), "Env_EventLogLevelName", 
(::_UserLogging.Env_EventLogLevelVal.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2675179103), "Env_EventLogLevelVal", 
(::_UserLogging.InfoCnt.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(491365813), "InfoCnt", 
(::_UserLogging.WarningCnt.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3421176171), "WarningCnt", 
(::_UserLogging.ErrorCnt.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(987008716), "ErrorCnt", 
(::_UserLogging.DebugCnt.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(440796679), "DebugCnt", 
//Clients:
(::_UserLogging.cEventLog.pCh)$UINT, _CH_CLT_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(982396215), "cEventLog", 
(::_UserLogging.SysMsg.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3591311931), "SysMsg", TO_UDINT(792524216), "_SysMsg", 0$UINT, 0$UINT, 
(::_UserLogging.SigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(77440046), "SigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 40$UINT, 
(::_UserLogging.cLogBufferSize.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3777293931), "cLogBufferSize", 
(::_UserLogging.cActivateTrace.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(219171063), "cActivateTrace", 
(::_UserLogging.cLogFileID.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2764813650), "cLogFileID", 
(::_UserLogging.EnvVar_LogLvl.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(386104795), "EnvVar_LogLvl", TO_UDINT(2870415996), "EnvironmentVariable", 1$UINT, 1$UINT, 
(::_UserLogging.EnvVar_ForwLvl.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2525667656), "EnvVar_ForwLvl", TO_UDINT(2870415996), "EnvironmentVariable", 1$UINT, 1$UINT, 
END_FUNCTION


#define USER_CNT__UserLogging 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__UserLogging] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _UserLogging::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__UserLogging, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
	InitOK.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF InitOK.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Flush.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Flush::Write() );
	IF Flush.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	LogFlushInterval.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF LogFlushInterval.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FileLogLevel.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF FileLogLevel.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	LogFileQuota.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF LogFileQuota.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, Env_FileLogLevelName.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #Env_FileLogLevelName::Read();
	vmt.CmdTable.Write		:= #Env_FileLogLevelName::Write();
	Env_FileLogLevelName.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Env_FileLogLevelName.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Env_FileLogLevelVal.pMeth			:= StoreMethod( #Env_FileLogLevelVal::Read(), #Env_FileLogLevelVal::Write() );
	IF Env_FileLogLevelVal.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	EventLogLevel.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF EventLogLevel.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, Env_EventLogLevelName.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #Env_EventLogLevelName::Read();
	vmt.CmdTable.Write		:= #Env_EventLogLevelName::Write();
	Env_EventLogLevelName.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Env_EventLogLevelName.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Env_EventLogLevelVal.pMeth			:= StoreMethod( #Env_EventLogLevelVal::Read(), #Env_EventLogLevelVal::Write() );
	IF Env_EventLogLevelVal.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION VIRTUAL GLOBAL _UserLogging::Init
  

  //If this is the Firstscan Cycle
  if _FirstScan then
    
    //==========================================
    //Based on the Init Retcode, Trace a Message
    //==========================================
    case Initialise() of
            
      //-----------------------------------------
      //Log File ID is Out of Bounds
      //-----------------------------------------
      UIR_LogFileIDNotOK:
        
        TRACE(USERLOGGING_ERR_LOGFILEID_NOT_OK);
      
      //-----------------------------------------
      //Allocating Memory Failed
      //-----------------------------------------
      UIR_MemAllocFail:
        
        TRACE(USERLOGGING_ALLOCATING_MEM_FAILED);
        
      //-----------------------------------------
      //Opening / Creating Log Failed
      //-----------------------------------------
      UIR_SysLogOpenFail:
        
        TRACE(USERLOGGING_CREATING_FILE_FAILED);
        
    end_case;
    
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _UserLogging::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  //If the Log needs to be flushed cyclically, do so.
  if  LogFlushInterval <> 0                           &
      ops.tAbsolute - udTimestamp >= LogFlushInterval then
    Flush.Write(input:=1);
    udTimestamp := ops.tAbsolute;
  end_if;

  
	state := READY;

END_FUNCTION

FUNCTION _UserLogging::AllocateMemory
	VAR_OUTPUT
		pLog 	: ^CHAR;
	END_VAR
  
  //Assume Fail
  pLog := NIL;
  
  //If the LogBufferSize client is connected, read it.
  if bdConnectedClients.cLogBufferSize then
    cLogBufferSize := cLogBufferSize.Read();
  end_if;
  
  udBuffSize := 0;
  
  //Malloc/ReAlloc Memory and return the status.
  if pSystemLogBuffer = NIL then
    pSystemLogBuffer$^void := sigclib_mallocV1(cLogBufferSize, USERLOGGING_DEFAULT_MEMMARK);
  else
    pSystemLogBuffer$^void := sigclib_reallocV1(pSystemLogBuffer, cLogBufferSize, USERLOGGING_DEFAULT_MEMMARK);
  end_if;

  if pSystemLogBuffer <> NIL then
    pLog        := pSystemLogBuffer;
    udBuffSize  := cLogBufferSize;
  else
    return;
  end_if;
    
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL _UserLogging::Env_FileLogLevelName::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	Env_FileLogLevelName := EnvVar_LogLvl.sVariableName.Read();
	output := Env_FileLogLevelName;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _UserLogging::Env_FileLogLevelName::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	Env_FileLogLevelName := input;
	result := (EnvVar_LogLvl.sVariableName.Write(Env_FileLogLevelName))$UDINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _UserLogging::Flush::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	//Assume Fail
  Flush := USERLOGGING_FLUSH_FAIL_NO_HANDLE;
  
  //If the handle is OK, call the flush method, set the retcode
  if udSysMsgHandle <> 0 then
    
    Flush := SysMsg.LFlush(hLog:=udSysMsgHandle);
    
  end_if;

	result := Flush;

END_FUNCTION


FUNCTION GLOBAL _UserLogging::AddEntry
	VAR_INPUT
		pCategory 	: ^CHAR;
		Level 	: UDINT;
		MsgGroup 	: DINT;
		MsgNbr 	: DINT;
		pMsg 	: ^CHAR;
		pPara1 	: ^DINT;
		pPara2 	: ^DINT;
		pPara3 	: ^DINT;
		pPara4 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR
  VAR
    dRet : DINT;
    bLogToFile, bLogToEventLog, bTraceLog : BOOL;
    pActBufferPos : ^CHAR;
    pLinefeed     : ^UINT;
    LFCHARS        : UINT;
    termChar      : CHAR;
    udWrittenLogMsg : UDINT;
    aLogString  : ARRAY [0..USERLOGGING_MULTILINE_MAXLEN-1] of CHAR; // local array used to ensure thread safety
    udLogLen      : UDINT;
  END_VAR
  
  
  if Level > (USERLOGGING_MASK_INFO     OR 
              USERLOGGING_MASK_WARNING  OR 
              USERLOGGING_MASK_ERROR    OR 
              USERLOGGING_MASK_DEBUG      ) |
     pCategory = NIL                        then
    return;
  end_if;
  
  // init locals
  Retcode := 0;
  LFCHARS  := 0;
  pLinefeed := NIL;
  termChar  := 0;
  udWrittenLogMsg := 0;
  
  // check where to log to
  bLogToFile      := CheckLevel(  Level       :=  Level, 
                                  BDINTValue  :=  FileLogLevel);
  bLogToEventLog  := CheckLevel(  Level       :=  Level, 
                                  BDINTValue  :=  EventLogLevel);
  if bdConnectedClients.cActivateTrace then
    cActivateTrace := cActivateTrace.Read();
  end_if;
  bTraceLog := (cActivateTrace = 1);
  
  
  

  if bLogToFile     |
     bLogToEventLog |
     bTraceLog      then
          
    dRet := CreateMsgString(  pCategory :=  pCategory, 
                              Level     :=  Level, 
                              MsgGroup  :=  MsgGroup, 
                              MsgNbr    :=  MsgNbr, 
                              pMsg      :=  pMsg, 
                              pPara1    :=  pPara1, 
                              pPara2    :=  pPara2, 
                              pPara3    :=  pPara3, 
                              pPara4    :=  pPara4,
                              pTmpBuffer := #aLogString[0],
                              udTmpBufferSize := sizeof(aLogString));

    // log string could not be created => return error!
    if dRet < 0 then
      Retcode := -1;
      return;
    end_if;
    
    if bLogToFile = TRUE then
      if udSysMsgHandle <> 0 then
        case dRet of
          
          //-------------------------------------------------------------------
          0..USERLOGGING_WRITE_MAX_LEN: // string can be logged at one go
          //-------------------------------------------------------------------
            if (_rtosversion <= USERLOGGING_OS_STARTVERSION_SALAMANDER) then
              // rtk does not add LF! 
              // We can just add it after the string because we know aLogString is long enough (case)
              aLogString[dRet-1] := USERLOGGING_LF; // (dRet is stringlength including 0-termination)
            end_if;
              
            SysMsg.LWrite(hLog            :=  udSysMsgHandle, 
                          udAddTimeStamp  :=  USERLOGGING_SYSMSG_TIMESTAMP, 
                          pData           :=  #aLogString[0], 
                          udSize          :=  to_udint(dRet));
          //-------------------------------------------------------------------
          USERLOGGING_WRITE_MAX_LEN+1..USERLOGGING_MULTILINE_MAXLEN: // string has to be split
          //-------------------------------------------------------------------
          
            pActBufferPos := #aLogString[0];
            repeat
            
              if (_rtosversion <= USERLOGGING_OS_STARTVERSION_SALAMANDER) then
                // rtk does not add LF!
                if (to_udint(dRet) - udWrittenLogMsg) >= USERLOGGING_WRITE_MAX_LEN - sizeof(CHAR) then
                  pLinefeed := pActBufferPos + USERLOGGING_WRITE_MAX_LEN - (2*sizeof(CHAR));
                else
                  if dRet <= USERLOGGING_MULTILINE_MAXLEN - (2*sizeof(CHAR)) then
                    pLinefeed := #aLogString[dRet-1]$UINT;
                  else
                    pLinefeed := #aLogString[USERLOGGING_MULTILINE_MAXLEN-2]$UINT;
                  end_if;
                end_if;
                
                // store character
                LFCHARS := pLinefeed^;
                // add linefeed
                pLinefeed^ := USERLOGGING_LF;
                // define length
                udLogLen := SigCLib.StrLen(str:=pActBufferPos);
              else
                udLogLen := USERLOGGING_WRITE_MAX_LEN-1;
              end_if;
              
              SysMsg.LWrite(hLog            :=  udSysMsgHandle, 
                            udAddTimeStamp  :=  USERLOGGING_SYSMSG_TIMESTAMP, 
                            pData           :=  pActBufferPos, 
                            udSize          :=  udLogLen+1);
              
              // now restore the characters in case of rtk
              if (_rtosversion <= USERLOGGING_OS_STARTVERSION_SALAMANDER) then
                pLinefeed^ := LFCHARS;
                
                pActBufferPos += USERLOGGING_WRITE_MAX_LEN-2;
              else
                pActBufferPos += USERLOGGING_WRITE_MAX_LEN;
              end_if;
              
              udWrittenLogMsg := pActBufferPos$UDINT - (#aLogString[0])$UDINT;
              
            until udWrittenLogMsg >= to_udint(dRet-1) end_repeat;


          //-------------------------------------------------------------------
          else // error
          //-------------------------------------------------------------------
          
        end_case;
      else
        TRACE(USERLOGGING_SYSMSG_LOG_FAIL_NOT_INITED);
      end_if;
    end_if;
      

    // Forward the message to TRACE if necessary
    if bTraceLog then
      if Level AND USERLOGGING_MASK_INFO then
        TRACE(#aLogString[0]);
      elsif Level AND USERLOGGING_MASK_WARNING then
        TRACE_WARN(#aLogString[0]);
      elsif Level AND USERLOGGING_MASK_ERROR then
        TRACE_ERR(#aLogString[0]);
      elsif Level AND USERLOGGING_MASK_DEBUG then
        TRACE(#aLogString[0]);
      end_if;
    end_if;


    // If eventlog is connected and message is to be sent, do so.
    if bLogToEventLog               &
       bdConnectedClients.cEventLog then
      CreateEventLog(pMessage:=#aLogString[0]);
    end_if;

  end_if;


  // Increment Counters
  if Level AND USERLOGGING_MASK_INFO then
    InfoCnt += 1;
  elsif Level AND USERLOGGING_MASK_WARNING then
    WarningCnt += 1;
  elsif Level AND USERLOGGING_MASK_ERROR then 
    ErrorCnt += 1;
  elsif Level AND USERLOGGING_MASK_DEBUG then
    DebugCnt += 1;
  end_if;
  
  
  
END_FUNCTION


FUNCTION _UserLogging::CheckLevel
	VAR_INPUT
		Level 	    : UDINT;
		BDINTValue 	: BDINT;
	END_VAR
	VAR_OUTPUT
		LevelFound 	: BOOL;
	END_VAR
  
  //Assume False
  LevelFound := FALSE;
  
  //If the Mask and Request overlaps, return true
  if (Level AND BDINTValue) then
    LevelFound := TRUE;     
  end_if;

END_FUNCTION


FUNCTION _UserLogging::CreateMsgString
	VAR_INPUT
		pCategory 	: ^CHAR;
		Level 	: UDINT;
		MsgGroup 	: DINT;
		MsgNbr 	: DINT;
		pMsg 	: ^CHAR;
		pPara1 	: ^DINT;
		pPara2 	: ^DINT;
		pPara3 	: ^DINT;
		pPara4 	: ^DINT;
		pTmpBuffer 	: ^CHAR;
		udTmpBufferSize 	: UDINT;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR
  VAR
    pActBufferPos : ^CHAR;
    udLength      : UDINT;
  END_VAR
  
  // Initialize return value
  Retcode := 0;

  // check buffer
  if (pTmpBuffer = NIL) | (udTmpBufferSize = 0) then
    Retcode := -1;
    return;
  end_if;
  
  // =========================================================================================
  //                          Copy the log-text into the buffer
  // =========================================================================================
  
  pActBufferPos := pTmpBuffer;
  // Copy Category
  if pCategory then
    udLength := SigCLib.StrLen(str:=pCategory);
    if udLength < (udTmpBufferSize - (pActBufferPos$UDINT - pTmpBuffer$UDINT)) then
      SigCLib.StrNCpy(dst0:=pActBufferPos, src0:=pCategory, count:=udLength+1);
      pActBufferPos         += udLength;
    end_if;
  end_if;
  if pActBufferPos >= pTmpBuffer + udTmpBufferSize - sizeof(CHAR) then  // sizeof(CHAR) because of ";"
    Retcode := to_dint(pActBufferPos$UDINT - pTmpBuffer$UDINT);
    return; // in this case we just log whatever fits in and stop
  end_if;
  pActBufferPos^ := ';';
  pActBufferPos         += sizeof(CHAR);
  
  
  
  // Copy Objectname
  //--------------------------------------
  if aObjectName[0] <> 0 then
    if udLength < (udTmpBufferSize - (pActBufferPos$UDINT - pTmpBuffer$UDINT)) then
      udLength := SigCLib.StrLen(str:=#aObjectName[0]);
      SigCLib.StrNCpy(dst0:=pActBufferPos, src0:=#aObjectName[0], count:=udLength);
      pActBufferPos         += udLength;
    end_if;
  end_if;
  if pActBufferPos >= pTmpBuffer + udTmpBufferSize - sizeof(CHAR) then  // sizeof(CHAR) because of ";"
    Retcode := to_dint(pActBufferPos$UDINT - pTmpBuffer$UDINT);
    return; // in this case we just log whatever fits in and stop
  end_if;
  pActBufferPos^ := ';';
  pActBufferPos         += sizeof(CHAR);
  //--------------------------------------

  
  
  // Copy Level
  //--------------------------------------
  if (Level AND USERLOGGING_MASK_INFO) then
    if USERLOGGING_INFO_TEXT_LEN < (udTmpBufferSize - (pActBufferPos$UDINT - pTmpBuffer$UDINT)) then
      SigCLib.StrNCpy(dst0:=pActBufferPos, src0:=USERLOGGING_INFO_TEXT, count:=USERLOGGING_INFO_TEXT_LEN);
      pActBufferPos         += USERLOGGING_INFO_TEXT_LEN;
    end_if;
  elsif (Level AND USERLOGGING_MASK_WARNING) then
    if USERLOGGING_WARNING_TEXT_LEN < (udTmpBufferSize - (pActBufferPos$UDINT - pTmpBuffer$UDINT)) then
      SigCLib.StrNCpy(dst0:=pActBufferPos, src0:=USERLOGGING_WARNING_TEXT, count:=USERLOGGING_WARNING_TEXT_LEN);
      pActBufferPos         += USERLOGGING_WARNING_TEXT_LEN;
    end_if;
  elsif (Level AND USERLOGGING_MASK_ERROR) then
    if USERLOGGING_ERROR_TEXT_LEN < (udTmpBufferSize - (pActBufferPos$UDINT - pTmpBuffer$UDINT)) then
      SigCLib.StrNCpy(dst0:=pActBufferPos, src0:=USERLOGGING_ERROR_TEXT, count:=USERLOGGING_ERROR_TEXT_LEN);
      pActBufferPos         += USERLOGGING_ERROR_TEXT_LEN;
    end_if;
  elsif (Level AND USERLOGGING_MASK_DEBUG) then
    if USERLOGGING_DEBUG_TEXT_LEN < (udTmpBufferSize - (pActBufferPos$UDINT - pTmpBuffer$UDINT)) then
      SigCLib.StrNCpy(dst0:=pActBufferPos, src0:=USERLOGGING_DEBUG_TEXT, count:=USERLOGGING_DEBUG_TEXT_LEN);
      pActBufferPos         += USERLOGGING_DEBUG_TEXT_LEN;
    end_if;
  end_if;
  if pActBufferPos >= pTmpBuffer + udTmpBufferSize - sizeof(CHAR) then  // sizeof(CHAR) because of ";"
    Retcode := to_dint(pActBufferPos$UDINT - pTmpBuffer$UDINT);
    return; // in this case we just log whatever fits in and stop
  end_if;
  pActBufferPos^ := ';';
  pActBufferPos         += sizeof(CHAR);
  //--------------------------------------
  
  
  
  // Copy Message group
  //--------------------------------------
  if getAsciiLen(MsgGroup) <= udTmpBufferSize - (pActBufferPos$UDINT - pTmpBuffer$UDINT) then
    SigCLib.IToA( val   :=  MsgGroup, 
                  dst   :=  pActBufferPos, 
                  base  :=  10);
    pActBufferPos         += SigCLib.StrLen(str:=pActBufferPos);
    if pActBufferPos >= pTmpBuffer + udTmpBufferSize - sizeof(CHAR) then  // sizeof(CHAR) because of ";"
      Retcode := to_dint(pActBufferPos$UDINT - pTmpBuffer$UDINT);
      return; // in this case we just log whatever fits in and stop
    end_if;
    pActBufferPos^ := ';';
    pActBufferPos         += sizeof(CHAR);
  end_if;
  //--------------------------------------



  // Copy Message number
  //--------------------------------------
  if getAsciiLen(MsgNbr) <= udTmpBufferSize - (pActBufferPos$UDINT - pTmpBuffer$UDINT) then
    SigCLib.IToA( val   :=  MsgNbr, 
                  dst   :=  pActBufferPos, 
                  base  :=  10);
    pActBufferPos         += SigCLib.StrLen(str:=pActBufferPos);
    if pActBufferPos >= pTmpBuffer + udTmpBufferSize - sizeof(CHAR) then  // sizeof(CHAR) because of ";"
      Retcode := to_dint(pActBufferPos$UDINT - pTmpBuffer$UDINT);
      return; // in this case we just log whatever fits in and stop
    end_if;
    pActBufferPos^ := ';';
    pActBufferPos         += sizeof(CHAR);
  end_if;
  //--------------------------------------



  // Copy Message
  //--------------------------------------
  if pMsg then
    udLength := SigCLib.StrLen(str:=pMsg);
    if udLength < (udTmpBufferSize - (pActBufferPos$UDINT - pTmpBuffer$UDINT)) then
      SigCLib.StrNCpy(dst0:=pActBufferPos, src0:=pMsg, count:=udLength);
      pActBufferPos         += udLength;
    else
      udLength := (udTmpBufferSize - (pActBufferPos$UDINT - pTmpBuffer$UDINT));
      SigCLib.StrNCpy(dst0:=pActBufferPos, src0:=pMsg, count:=udLength);
      pActBufferPos         += udLength;
    end_if;
  end_if;
  if pActBufferPos >= pTmpBuffer + udTmpBufferSize - sizeof(CHAR) then  // sizeof(CHAR) because of ";"
    Retcode := to_dint(pActBufferPos$UDINT - pTmpBuffer$UDINT);
    return; // in this case we just log whatever fits in and stop
  end_if;
  pActBufferPos^ := ';';
  pActBufferPos         += sizeof(CHAR);
  //--------------------------------------
  
  
  
  // Copy parameter 1
  //--------------------------------------
  if pPara1 then
    if getAsciiLen(pPara1^) <= udTmpBufferSize - (pActBufferPos$UDINT - pTmpBuffer$UDINT) then
      SigCLib.IToA( val   :=  pPara1^, 
                    dst   :=  pActBufferPos, 
                    base  :=  10);
      pActBufferPos         += SigCLib.StrLen(str:=pActBufferPos);
    end_if;
  end_if;
  if pActBufferPos >= pTmpBuffer + udTmpBufferSize - sizeof(CHAR) then  // sizeof(CHAR) because of ";"
    Retcode := to_dint(pActBufferPos$UDINT - pTmpBuffer$UDINT);
    return; // in this case we just log whatever fits in and stop
  end_if;
  pActBufferPos^ := ';';
  pActBufferPos         += sizeof(CHAR);
  //--------------------------------------
  
  
  
  // Copy parameter 2
  //--------------------------------------
  if pPara2 then
    if getAsciiLen(pPara2^) <= udTmpBufferSize - (pActBufferPos$UDINT - pTmpBuffer$UDINT) then
      SigCLib.IToA( val   :=  pPara2^, 
                    dst   :=  pActBufferPos, 
                    base  :=  10);
      pActBufferPos         += SigCLib.StrLen(str:=pActBufferPos);
    end_if;
  end_if;
  if pActBufferPos >= pTmpBuffer + udTmpBufferSize - sizeof(CHAR) then  // sizeof(CHAR) because of ";"
    Retcode := to_dint(pActBufferPos$UDINT - pTmpBuffer$UDINT);
    return; // in this case we just log whatever fits in and stop
  end_if;
  pActBufferPos^ := ';';
  pActBufferPos         += sizeof(CHAR);
  //--------------------------------------
  
  
  
  // Copy parameter 3
  //--------------------------------------
  if pPara3 then
    if getAsciiLen(pPara3^) <= udTmpBufferSize - (pActBufferPos$UDINT - pTmpBuffer$UDINT) then
      SigCLib.IToA( val   :=  pPara3^, 
                    dst   :=  pActBufferPos, 
                    base  :=  10);
      pActBufferPos         += SigCLib.StrLen(str:=pActBufferPos);
    end_if;
  end_if;
  if pActBufferPos >= pTmpBuffer + udTmpBufferSize - sizeof(CHAR) then  // sizeof(CHAR) because of ";"
    Retcode := to_dint(pActBufferPos$UDINT - pTmpBuffer$UDINT);
    return; // in this case we just log whatever fits in and stop
  end_if;
  pActBufferPos^ := ';';
  pActBufferPos += sizeof(CHAR);
  //--------------------------------------
  
  
  
  // Copy parameter 4
  //--------------------------------------
  if pPara4 then
    if getAsciiLen(pPara4^) <= udTmpBufferSize - (pActBufferPos$UDINT - pTmpBuffer$UDINT) then
      SigCLib.IToA( val   :=  pPara4^, 
                    dst   :=  pActBufferPos, 
                    base  :=  10);
      pActBufferPos         += SigCLib.StrLen(str:=pActBufferPos);
    end_if;
  end_if;
  if pActBufferPos >= pTmpBuffer + udTmpBufferSize - (2*sizeof(CHAR)) then  // sizeof(CHAR) because of ";0"
    Retcode := to_dint(pActBufferPos$UDINT - pTmpBuffer$UDINT);
    return; // in this case we just log whatever fits in and stop
  end_if;
  pActBufferPos^ := ';';
  pActBufferPos  += sizeof(CHAR);
  pActBufferPos^ := 0;  // end of string
  pActBufferPos  += sizeof(CHAR);
  //--------------------------------------
  
  Retcode := to_dint(pActBufferPos$UDINT - pTmpBuffer$UDINT);

  
END_FUNCTION


FUNCTION _UserLogging::CreateEventLog
	VAR_INPUT
		pMessage 	: ^CHAR;
	END_VAR
  VAR
  	NiGive  : CmdStruct;
    NiGet   : results;
    #ifdef UC_UNICODE
    aUniString : ARRAY[0..USERLOGGING_WRITE_MAX_LEN_UNI] of _CHAR;
    pTerm      : ^CHAR;
    #endif
  END_VAR
  
  //If the kernel is compiled for Unicode, the string needs to be changed
  #ifdef UC_UNICODE
    //Ensure the Message String is terminated, change into unicode, set pointer:
    pTerm$UDINT := pMessage$UDINT + USERLOGGING_WRITE_MAX_LEN_UNI;
    pTerm^ := 0x00;
    SigCLib.Utf8ToStr16(dst :=  #aUniString[0], 
                        src :=  pMessage);
    NiGive.aPara[0]$^void := #aUniString[0];    
  //If the Kernel is not compiled at all or for 8 bit CHARS, pass the message further:
  #else
    NiGive.aPara[0]$^void := pMessage;
  #endif
  
  //Call NewInst Method.
  NiGive.uiCmd := USERLOGGING_EQ_METHOD_NUM;
  cEventLog.NewInst(#NiGive, #NiGet);      
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _UserLogging::Env_EventLogLevelName::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	Env_EventLogLevelName := EnvVar_ForwLvl.sVariableName.Read();
	output := Env_EventLogLevelName;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _UserLogging::Env_EventLogLevelName::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	Env_EventLogLevelName := input;
	result := (EnvVar_ForwLvl.sVariableName.Write(Env_EventLogLevelName))$UDINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _UserLogging::Env_FileLogLevelVal::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	Env_FileLogLevelVal := EnvVar_LogLvl.sNumericValue.Read();
	output := Env_FileLogLevelVal;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _UserLogging::Env_FileLogLevelVal::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	Env_FileLogLevelVal := input;
	result := (EnvVar_LogLvl.sNumericValue.Write(Env_FileLogLevelVal))$DINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _UserLogging::Env_EventLogLevelVal::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	Env_EventLogLevelVal := EnvVar_ForwLvl.sNumericValue.Read();
	output := Env_EventLogLevelVal;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _UserLogging::Env_EventLogLevelVal::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	Env_EventLogLevelVal := input;
	result := (EnvVar_ForwLvl.sNumericValue.Write(Env_EventLogLevelVal))$DINT;

END_FUNCTION


FUNCTION GLOBAL _UserLogging::Initialise
	VAR_OUTPUT
		RetCode 	: t_e_UserLogInitRet;
	END_VAR
  VAR
	  pObj  : ^Obj;
    pName : ^CHAR;
    pLog  : ^CHAR;
  END_VAR
   
  //Assume the Init is OK
  InitOK  := 1;
  RetCode := UIR_Success;
  
  //Set the connected clients
  bdConnectedClients.cEventLog      := to_bool(IsClientConnected(#cEventLog));
  bdConnectedClients.cLogBufferSize := to_bool(IsClientConnected(#cLogBufferSize));
  bdConnectedClients.cActivateTrace := to_bool(IsClientConnected(#cActivateTrace));
  bdConnectedClients.cLogFileID     := to_bool(IsClientConnected(#cLogFileID));
  
  //Update the LogFileID, if not OK, stop.
  if bdConnectedClients.cLogFileID then
    cLogFileID := cLogFileID.Read();
  end_if;
   
  if cLogFileID < USERLOGGING_MIN_LOGFILE_ID |
     cLogFileID > USERLOGGING_MAX_LOGFILE_ID then
     
    RetCode  := UIR_LogFileIDNotOK;
    InitOK   := 0;
    return;
    
  end_if;
  
  //If the Log File Handle is already open, flush and close the log:
  if udSysMsgHandle <> 0 then
  
    Flush.Write(input:=1);
    SysMsg.LClose(hLog:=udSysMsgHandle);
    udSysMsgHandle := 0;
    
  end_if;
  
  
  // HubChr 20190709 it is possible that another instance already created our log-buffer
  udSysMsgHandle := SysMsg.LOpen(cLogFileID);
  
  if udSysMsgHandle = 0 then
    //If allocating mem fails, stop.
    pLog := AllocateMemory();
    if pLog = NIL then
      RetCode  := UIR_MemAllocFail;
      InitOK   := 0;    
      return;
    end_if;
    
    // create log object
    if udSysMsgHandle = 0 then
    
      udSysMsgHandle := SysMsg.LCreate( nID           :=  cLogFileID, 
                                        pBuffer       :=  pLog, 
                                        udBufferSize  :=  udBuffSize, 
                                        dFileQuota    :=  LogFileQuota, 
                                        udFlags       :=  0);
      
    end_if;
  end_if;
  
  // no valid handle
  if udSysMsgHandle = 0 then
    RetCode  := UIR_SysLogOpenFail;
    InitOK   := 0;
    return;
  end_if;
  
  udTimestamp := ops.tAbsolute;
  
  //If the envionment Variables have Inited OK (are set), set the Logging and Forwarding Levels respectively
  EnvVar_LogLvl.SomethingChanged(Reaseon:=0);
  if (EnvVar_LogLvl.sStatus = ENV_ValidValue) then                 
    FileLogLevel := to_udint(Env_FileLogLevelVal.Read());
  end_if;
  
  EnvVar_ForwLvl.SomethingChanged(Reaseon:=0);
  if (EnvVar_ForwLvl.sStatus = ENV_ValidValue) then                 
    EventLogLevel := to_udint(Env_EventLogLevelVal.Read());
  end_if;

  //Determine the name of the containing/current Object:
  //1. Get the current object name.
  pObj$^void  := this;
  pObj        -= sizeof(Obj);
  
  pName := #pObj^.pObjDsc^.SymName$CHAR;
  pName += USERLOGGING_SIZELEXEMCRC;
  
  SigCLib.StrNCpy(dst0  :=  #aObjectName[0], 
                  src0  :=  pName, 
                  count :=  sizeof(aObjectName));
  
  aObjectName[sizeof(aObjectName)-1] := 0x00;
  
  //2. If the object is embedded, get the name of the parent object
  pName := SigCLib.StrChr(ps1 :=  #aObjectName[0], 
                          i   :=  USERLOGGING_OBJECT_EMBED_DELIMITER);
                          
  //If found and the position of the embed char is within our array range, erase the last part of the name
  if pName                                                        &
     (pName$UDINT - (#aObjectName)$UDINT <= sizeof(aObjectName))  then
    SigCLib.MemSet( dst :=  pName, 
                    c   :=  0x00, 
                    len :=  (#aObjectName)$UDINT + sizeof(aObjectName) - pName$UDINT);
  end_if;
  
END_FUNCTION


FUNCTION _UserLogging::getAsciiLen
	VAR_INPUT
		dValue 	: DINT;
	END_VAR
	VAR_OUTPUT
		udLen 	: UDINT;
	END_VAR

  // intialise return value
  udLen := 1; // 1 is minimum because of 0-termination

  // if value is negative, we need space for "-"
  if dValue < 0 then
    udLen += 1;
  end_if;

  repeat
  
    udLen += 1;
    dValue /= 10;
    
  until (dValue = 0) end_repeat;


END_FUNCTION
