//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "OPC_UA_DataLoggerBase"
	Revision           = "1.0"
	GUID               = "{FB9C46A5-B0D6-4728-A512-404ACDACFBD6}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(540,120)"
	Comment            = "This is the base class for logging history data.&#13;&#10;&#13;&#10;All functions for logging data or events and reading them will end in this class and there need to be saved and read via bytestrings, derive this class to implement own logging.">
	<Channels>
		<Server Name="ClassSvr" GUID="{082D5FB7-B5A3-44DA-9711-6405BD19A5F1}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="not used (object channel interface)"/>
		<Client Name="OPC_UA_Server" Required="true" Internal="false" Comment="Connection to the OPC_UA_Server class."/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\OPC_UA_DataLoggerBase\OPC_UA_DataLoggerBase_de.pdf"/>
			<File Path=".\Class\OPC_UA_DataLoggerBase\OPC_UA_DataLoggerBase_en.pdf"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="FurLuk"/>
		<Dokumentation Revision="1.0" Date="2020-09-23" Author="FurLuk" Company="Sigmatek" Description="Creation"/>
	</RevDoku>
</Class>
*)
OPC_UA_DataLoggerBase : CLASS
	TYPE
	  t_e_OpcUa_LoggerType :  //! <Type Public="true" Name="t_e_OpcUa_LoggerType"/>
	  (
	    LT_Invalid,  //! <Type Comment="Used as default value of the base class " Name="t_e_OpcUa_LoggerType.LT_Invalid"/>
	    LT_RAM,
	    LT_SRAM
	  )$UDINT;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
  //Clients:
	OPC_UA_Server 	: CltChCmd_OPC_UA_Server;
  //Variables:
		currentLoggerType 	: t_e_OpcUa_LoggerType;
  //Functions:
				//! <Function Comment="This method will be called from the OPC_UA_Server class when history data shall be stored." Name="LogHistoryData"/>
	FUNCTION VIRTUAL GLOBAL LogHistoryData
		VAR_INPUT
			primaryKey 	: DINT;			//! <Variable Comment="the primary key of the node to store" Name="LogHistoryData.primaryKey"/>
			statusCode 	: UDINT;			//! <Variable Comment="the status code of the value to be stored" Name="LogHistoryData.statusCode"/>
			sourceTime 	: ^OPCUA_TimeStamp;			//! <Variable Comment="source timestamp of the value to store" Name="LogHistoryData.sourceTime"/>
			serverTime 	: ^OPCUA_TimeStamp;			//! <Variable Comment="server timestamp of the value to be stored" Name="LogHistoryData.serverTime"/>
			valueType 	: DINT;			//! <Variable Comment="the type of the value to be stored" Name="LogHistoryData.valueType"/>
			dataLength 	: UDINT;			//! <Variable Comment="the length of the bytestring to store, this bytestring gets created in c and can be built to a data value in c again" Name="LogHistoryData.dataLength"/>
			data 	: ^void;			//! <Variable Comment="the pointer to the bytesting to store" Name="LogHistoryData.data"/>
			userData 	: ^void;			//! <Variable Comment="Additional parameter which can be used later in order to be able to use the correct logger for the given data value or any further information which might be of help." Name="LogHistoryData.userData"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="returncode for storing&#13;&#10;0 .. storing fine&#13;&#10;&lt;&gt; 0 .. failure with errornumber" Name="LogHistoryData.retcode"/>
		END_VAR;
				//! <Function Comment="This method will be called via the OPC_UA_Server class when history events shall be stored.&#13;&#10;&#13;&#10;Not implemented yet!" Name="LogHistoryEvent"/>
	FUNCTION VIRTUAL GLOBAL LogHistoryEvent
		VAR_INPUT
			primaryKey 	: DINT;			//! <Variable Comment="primary key of the event to be stored" Name="LogHistoryEvent.primaryKey"/>
			noOfEvents 	: DINT;			//! <Variable Comment="number of events to store" Name="LogHistoryEvent.noOfEvents"/>
			variants 	: ^OPC_UA::tOpcUa_Variant;			//! <Variable Comment="the variant containing the events" Name="LogHistoryEvent.variants"/>
			userData 	: ^void;			//! <Variable Comment="Additional parameter which can be used later in order to be able to use the correct logger for the given event or any further information which might be of help." Name="LogHistoryEvent.userData"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="returncode of the function &#13;&#10;0 .. success&#13;&#10;&lt;&gt; 0 .. failure with errorcode" Name="LogHistoryEvent.retcode"/>
		END_VAR;
				//! <Function Comment="This method will be called via the OPC_UA_Server class when history data should be read." Name="ReadHistoryData"/>
	FUNCTION VIRTUAL GLOBAL ReadHistoryData
		VAR_INPUT
			primaryKey 	: DINT;			//! <Variable Comment="primary key of the node to read" Name="ReadHistoryData.primaryKey"/>
			startTime 	: ^OPCUA_TimeStamp;			//! <Variable Comment="start time of values for the node to read" Name="ReadHistoryData.startTime"/>
			endTime 	: ^OPCUA_TimeStamp;			//! <Variable Comment="end timeof values for the node to read" Name="ReadHistoryData.endTime"/>
			isInverse 	: USINT;			//! <Variable Comment="if the data should be read in inverse direction" Name="ReadHistoryData.isInverse"/>
			numValues 	: ^UDINT;			//! <Variable Comment="pointer to the number of values to be read" Name="ReadHistoryData.numValues"/>
			results 	: ^void;			//! <Variable Comment="pointer to where the results should be stored, the memory is already allocated" Name="ReadHistoryData.results"/>
			continuationPoint 	: ^OPC_UA::tOpcUa_ByteString;			//! <Variable Comment="pointer to the continuation point which needs to be set if needed&#13;&#10;&#13;&#10;the continuation point contains a timestamp where the last values has been written from and an continuation offset, which indexes the number of values that have been read at the exact same time" Name="ReadHistoryData.continuationPoint"/>
			continuationOffset 	: DINT;			//! <Variable Comment="the continuation offset from the request,&#13;&#10;if set, it indexes the number of values that have been read at the exact same start time" Name="ReadHistoryData.continuationOffset"/>
			userData 	: ^void;			//! <Variable Comment="Additional parameter which can be used later in order to be able to use the correct logger for the given data value or any further information which might be of help." Name="ReadHistoryData.userData"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="returncode of reading&#13;&#10;0 .. reading fine&#13;&#10;&lt;&gt;0 .. error (for example out of memory)" Name="ReadHistoryData.retcode"/>
		END_VAR;
				//! <Function Comment="Returns the logger type as an enum. The logger type specifies where the data is actually stored. This can bei either in the RAM, the SRAM or in a file." Name="GetLoggerType"/>
	FUNCTION VIRTUAL GLOBAL GetLoggerType
		VAR_OUTPUT
			loggerType 	: t_e_OpcUa_LoggerType;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd OPC_UA_Server


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB OPC_UA_DataLoggerBase::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_OPC_UA_DATALOGGERBASE
1$UINT, 0$UINT, (SIZEOF(::OPC_UA_DataLoggerBase))$UINT, 
1$UINT, 1$UINT, 0$UINT, 
TO_UDINT(3115338217), "OPC_UA_DataLoggerBase", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::OPC_UA_DataLoggerBase.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
//Clients:
(::OPC_UA_DataLoggerBase.OPC_UA_Server.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3179222780), "OPC_UA_Server", TO_UDINT(3179222780), "OPC_UA_Server", 3$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_OPC_UA_DataLoggerBase 4

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_OPC_UA_DataLoggerBase] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION OPC_UA_DataLoggerBase::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_OPC_UA_DataLoggerBase, pCmd := #vmt.CmdTable);
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #LogHistoryData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #LogHistoryEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #ReadHistoryData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #GetLoggerType();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
//{{LSL_ENCRYPTION 16#800
411C9B53F342212FF2412A957A14F9956E3CC1E5BFAED63D0451C2CE8623AB83982F12E5BBDDAF632BBD0E3F8FB475885FB7068E182404B40C38BFB9D56816857D7DE721B4178407C96F701D3A5B183F206E39051904746C96F9DEBB766A666EF4CEC7DB
2F7D488DA180E4DEA6DDD539A2E68E6E926F6FC055F1209876F0CDDDC6DC740D991BBA6EACAF646CC5C2E8A35146C05D10B42EDB7C92D0031947B7BD9F68C4342C5512CD2470353B85EE75CED57D70F8A3EA4B3679D701DEF2BBA711821A93EFE35B7859
687C9023B74D47A88C470CD429BAD6B43AC028442220E9FE557A504CD2900BE0B0EA6532BD76893BC78793DEF012EB983AB8B555C4BC14D07C76EC989BD1ED9AB7C76343C9CF7E9129A9022F06AAFE290972DFE1F2FA78EE7458770A6F180C69518A8494
B40329C023B05C8F27829930F5AF5797CD7975F05420562B1D198FE796131A05317D162B502A47BB0299BB74B45FD03F7BC1521A6E78E0B879A7E38A34D695153657B1E27E58FEB34BB22933048413FFDFC9F55BB44EA4C66BF599AD34D054D8CB8D8CCB
D1CC9886597D22B7F6697F667B1A63C2293E75116CF7A2E14FC829D2939E687D1F85E2D7F453CEAFFA083E181572BC7980A51968379811AB8899C9F4B250751C8B0DB2076E9C94FE2B3B15FC8ACEAA49FBB2CAEA2E09D3431D324A578B4A0E72DA492ED6
B2A16B703FFA37DEB9CDEDD9536BB27B9036C712640A8746ACACAFE8E1E0428AC0C1C5C8F288B30F784A70B0311502F944B0926B6B95D78ECA2DDF22FA0ECB37C0C8B654C37A0678E510116CF639DD45152AA3ED54C306332C0F0A374FF0993B91049E21
4522AA52BEB37EBC38A799B0E45C481186F6C17F5C070C5A9082A8268553C5F82DF0E1D2DFB8A0A4F980FF53AC21896048649FA2C389556CF7CA840D2C4D19B4493A7B9956482A839B9BB25D0FA3CA16F2CFC23F849F5CA30F98AFBD69AFF65772BEBA5D
DE8C7B7F4D8F30137E6520177C54CF6887ED87B8ECA8ADA6534476096BABAB6F4DADD0480FF76443803392B7C226A1B2A420DC808BBA6107467F7D16E51AB5ACB6EA6C310C6263DC669C54D32AB0209DCD0F3AC95F66432E14CC48D8865914DCE9FA280D
8515644E99E4043C4B7914F3966B44E88496D69AEB2B4DBBE05106544381AAA50D789B0C46F5132A34159FCE5AC50FA3134AC4E68FD791238D026CE8A3BF4BBCCD8E9469AE7896E2F334542390BCD73D159510591EF343EC44A981DCB5EFAFA417906EF9
22CC160EA353A397F11144CCD03470490520DF165C4768D249D474553E2FF124CC4F8B5BC155CAF4698C744791EA94216CC2F15AE6AF400C7CEFCC22274797E85E1A2079664CF7D52E745EE43A090D16072FA1D219524E33A7811C3FEFE2F6E2D768E00B
7BD77408F6A1CBD74FAB8F269C9298281666E6819BC246CA25FA2C1A17AD62FFC5F141061527B4496B480A629A8F07561D2CFC14682919B0138436D991737124FBA4D46C1840109A67E4AFBB24B801A398DB8BD949262B823BE9D3B087A67BA88E829327
DB6839E5289050D016582A299BD1C48786C24C8F388622E06B9532F3845AB57FDDF45683D6915E19BA1FCC9A54BF15E64A79BBF2FEE08E8898EA3F733A0703C0F5BD2B7E7E364E39F1F022064E5D55321D75133E9AC8912ADF5114D1B1B419C9F415F416
B3453E877B144759E31D9EE230129C0E0C56C5D84EE136E4FD027593818F99C78D3E79AF44E77C39DBD81DFEAD986EAD5216433FB3EA171C005174FCB7EF332FF7981C90F387044FFCC48424F5678324C5FC77B7B451BF893DF25D093DAC8F33EF855779
CC1405E9C73DBEBB568AADE1329B7B7D99DB8735AB835F97DFF646817C01B2DA14F41C6F27A0F03A967859D4B2CA9E8EF5703A8F2393CE367B036ADF586F072578932926D829A47254C75CB6E814D2A283062683F1394544E537BC5324ADA199FC3A3D5B
87C3EB851F5BAC70F53B66194FAFEF4AE1F8546ECD34F8D457351A74AC2A77CD5F5B3C50C74179C4080BECD5510A4243620C1D734C1C31973EDBCF55A45F4C1D66E1C3EED89CE6034C9BB64DD9D90E3672EA66EDCCB3B4337D82206DA35B13AA8CF81B9F
4DDD6EE42867CFB4D3A8A7D3EEE39798C591A66585DA837410D98926E9B221DBA72790F8E1F5EC12E6015D0BE7398FC6C1CBED9D54833D7AE7306BF6994AF5E2DDA06790FB13A631E37685BAE331C887CFE10A3281E276E515A169F2504120A05BD9E430
7000E368E262F1F4D3359A9720919C060CD71C8D06DB1B01205BA167CEC05E2558D52B60D4D848D0C81E458BB6F5E990D8DEC10AC2DED9C77C0D6177F3D1AEE830C46E0C1F45702955927443A8D9AF88DB91EC43FB3DFF4493F5FB2D287AD6D0B4D1E956
385E4B71CFFF44FC03C3762B147CE400915B94FBB5C0A7D1D8FD5A84B1DC30F846558EFB8984721624D1C8D38431C27E092EF806D2D82F1A91F98174FF2FE3A13827B8CEECBC10C0A0F6101A7FAD69589111A90C3D010A912E384162DA55B6DF520A05E7
3B74BE98755DD01DBB68F89515D1ECD12536AE49B962917A7B62AA2E9FCAF62650C2D8E2330DAD3286BABD882F9C05CE85C20B92FCAB6B4821FBE1A80931EBFF4AFE7458400D8B156F63FB9329AADEC0871090B6D0B925A52243FB37310243AC7DE20BC0
00201B08097E3392F26339162CACF0D410B4CD400D50336E5B5BF9B4A211B8F401F6BF3EC8C9996FB93DA86C10D1901AD19AFC889A058F304C67B7FCE1CEF390B3CF7497CB2EE4AD077E56620CF867D3DAA9BCC07905C364F3C60D0C30104FAE69D3F4A3
8CBCBAA63BF576D02F5206818B68031A611D50BF1DA0E2D53E1216EA4E68C5AB915863BF788372384CA0B1BBF727455F5CCCC2D137CB46633DDA493E4F741A46BEF15961CE9DD1570DEB99702697AA13